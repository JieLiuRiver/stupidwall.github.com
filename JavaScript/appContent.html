				<div class="container" >
					<div class="row">
						<div class="col-md-12">

							<button class="btn pull-right"  ui-sref="index" style="background: hsl(30, 20%, 25%); color:#fff;margin-bottom:10px; margin-right: 15px;">返回</button>
							<pre style="margin-bottom: 10px; background: hsl(30, 20%, 25%);text-indent:20px; " >
							<code class="language-css" style="color:#fff; font-size:15px; text-shadow: none;" >
						
		 /*===============================================================================*/
		 /*  	学习笔记
		 /*===============================================================================*/
							1.总共消费 00: 00元：
				补零函数：
				function toZero( num ){
				If( num&lt;10 ){
				return ‘0’ + num;
				}else{
				return ‘’ + num;
				}
				};

				2. Var str = ‘abc’;
				str.charAt(0);
				当我需要取字符串里的某一个字符时。

				3.	无缝切换
				/*
				conditions:
				css:
				wrap---min-width:1000px;
				ie:
				*html .ie6_out{ margin-left:1000px; zoom:1;}
				*html .ie6_in{ position:relative; float:left; margin-left:-1000px;}

				html:
				&lt;!--[if lte IE 6]&gt;
				&lt;div class=&quot;ie6_out&quot;&gt;
				&lt;div class=&quot;ie6_in&quot;&gt;
				&lt;! [endif]--&gt;
				.....
				&lt;!--[if lte IE 6]&gt;
				&lt;/div&gt;
				&lt;/div&gt;
				&lt;![endif]--&gt;
				*/

				//setInterval(seamlessRun,3000);
				var iNow = 0;
				var iNow2 = 0;
				function seamlessRun(){
				if( iNow == aLi.length-1 ){
				aLi[0].style.position = &#x27;relative&#x27;;
				aLi[0].style.left = aLi.length * imgWidth + &#x27;px&#x27;;
				iNow = 0;
				} else {
				iNow++;
				}
				iNow2++;
				startMove(oUl,{left : - iNow2*imgWidth} ,function(){
				if(iNow==0){
				    aLi[0].style.position = &#x27;static&#x27;;
				    oUl.style.left = 0;
				    iNow2 = 0;
				}
				});

				}

				4.下拉菜单，多级
				&lt;script&gt;
				window.onload = function(){
				var sl = new sel(&#x27;div1&#x27;);
				sl.add(&#x27;0&#x27;,[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]);//第一级

				//二级菜单
				sl.add(&#x27;0_0&#x27;,[&#x27;1_1&#x27;,&#x27;1_2&#x27;,&#x27;1_3&#x27;])

				sl.add(&#x27;0_0_0&#x27;,[&#x27;1_1_1&#x27;,&#x27;1_1_2&#x27;,&#x27;1_1_3&#x27;]);
				sl.add(&#x27;0_0_1&#x27;,[&#x27;1_2_1&#x27;,&#x27;1_2_2&#x27;,&#x27;1_2_3&#x27;]);
				sl.add(&#x27;0_0_2&#x27;,[&#x27;1_3_1&#x27;,&#x27;1_3_2&#x27;,&#x27;1_3_3&#x27;]);



				sl.add(&#x27;0_1&#x27;,[&#x27;2_1&#x27;,&#x27;2_2&#x27;,&#x27;3_3&#x27;]);

				sl.add(&#x27;0_1_0&#x27;,[&#x27;2_1_1&#x27;,&#x27;2_1_2&#x27;,&#x27;2_1_3&#x27;]);
				sl.add(&#x27;0_1_1&#x27;,[&#x27;2_2_1&#x27;,&#x27;3_2_2&#x27;,&#x27;2_2_3&#x27;]);
				sl.add(&#x27;0_1_2&#x27;,[&#x27;2_3_1&#x27;,&#x27;2_3_2&#x27;,&#x27;2_3_3&#x27;]);






				sl.add(&#x27;0_2&#x27;,[&#x27;3_1&#x27;,&#x27;3_2&#x27;,&#x27;3_3&#x27;]);

				sl.add(&#x27;0_2_0&#x27;,[&#x27;3_1_1&#x27;,&#x27;3_1_2&#x27;,&#x27;3_1_3&#x27;]);
				sl.add(&#x27;0_2_1&#x27;,[&#x27;3_2_1&#x27;,&#x27;3_2_2&#x27;,&#x27;3_2_3&#x27;]);
				sl.add(&#x27;0_2_2&#x27;,[&#x27;3_3_1&#x27;,&#x27;3_3_2&#x27;,&#x27;3_3_3&#x27;]);


				sl.int(3); //创建3个下拉菜单

				}
				function sel(id){
				this.oparent = document.getElementById(id);
				this.data = {};  // 建立大的json，装数据
				}

				sel.prototype = {

				init : function(num){
				for(var i=1; i&lt;=num; i++){
				var oSel = document.createElement(&#x27;select&#x27;);
				var oPt = document.createElement(&#x27;option&#x27;);
				 oPt.innerHTML = &#x27;默认&#x27;;
				 oSel.appendChild(oPt);
				 this.oParent.appendChild(oSel);
				}
				this.first
				}, // 初始化

				add : function(key,value){  //内部关联起来
				this.data[key] = value;
				},
				first : function(){
				var arr = this.data[&#x27;0&#x27;];
				for(var i=0; i&lt;arr.length; i++){
				var oPt = document.createElement(&#x27;option&#x27;);

				oPt.innerHTML = arr[i];
				}
				}
				}
				&lt;/script&gt;

				5.有这么一种思维：
				左中右三列的ul
				取模处理
				switch
				分别操作它们：
				var aLi = document.getElementsByTagName(&#x27;li&#x27;);

				var aHeight = {L : [], C : [], R :[]}
				//运用取模；
				//把高度值存起来，方便用。
				for( var i=0; i&lt;aLi.length; i++ ){
				var iNow = i%3;
				switch(iNow){
				case 0:
				    aLi[i].style.left = &#x27;5px&#x27;;
				    aHeight.L.push( aLi[i].offsetHeight );

				    var step = Math.floor(i/3);
				    if(!step){ //当步骤为0的时候
				        aLi[i].style.top = 0;
				    }else{
				            var sum = 0;
				            for(var j=0;j&lt;step; j++){
				                sum += aHeight.L[j] + 5 ;
				            }
				            aLi[i].style.top = sum + &#x27;px&#x27;;
				    }
				break;
				case 1:
				    aLi[i].style.left = &#x27;240px&#x27;;
				    aHeight.C.push( aLi[i].offsetHeight );
				    var step = Math.floor(i/3);
				    if(!step){ //当步骤为0的时候
				        aLi[i].style.top = 0;
				    }else{
				            var sum = 0;
				            for(var j=0;j&lt;step; j++){
				                sum += aHeight.L[j] + 5 ;
				            }
				            aLi[i].style.top = sum + &#x27;px&#x27;;
				    }
				break;
				case 2:
				    aLi[i].style.left = &#x27;475px&#x27;;
				    aHeight.R.push( aLi[i].offsetHeight );
				    var step = Math.floor(i/3);
				    if(!step){ //当步骤为0的时候
				        aLi[i].style.top = 0;
				    }else{
				            var sum = 0;
				            for(var j=0;j&lt;step; j++){
				                sum += aHeight.L[j] + 5 ;
				            }
				            aLi[i].style.top = sum + &#x27;px&#x27;;
				    }
				break;
				}
				}

				6.微博登陆：面向对象写法

				7. 输入的时候，同时触发：
				IE下： onpropertychange  输入连续触发
				    标准下： oninput

				8.写兼容的时候
				区分ie 非ie浏览器
				if(-[1,]){
				        alert(&quot;这不是IE浏览器！&quot;);
				}else{
				       alert(&quot;这是IE浏览器！&quot;);
				};

				或者： if(!+[1,]){
				alert(&#x27;ie&#x27;)
				}else{
				alert(&#x27;no_ie&#x27;)
				}

				9. 写个函数，判断双字节还是单字节
				     function getLength(str){
				        return String(str).replace(/[^\x00-\xff]/g,&#x27;aa&#x27;).length;  //正则
				     }

				10.超过140个字：
				        if(num1&lt;140){
				            oSpan.innerHTML = 140 - num1;
				        }else{
				            oSpan.innerHTML = num1 - 140;
				            oSpan.style.color = &#x27;red&#x27;;
				        }
				        if(oT.value= &#x27;&#x27; || num1 &gt; 140){
				                oA.className = &#x27;dis&#x27;;
				        }else{
				                oA.className = &#x27;&#x27;;
				        }




				11.创建一个变量iNow，怎么利用它，输出： 0 2 0 2 0
				var num = 0
				timer = setInterval(function(){

				if(num == 5){
				clearInterval(timer);
				num = 0;
				}else {
				num++;
				}

				if(num%2){
				oT.style.background = &#x27;red&#x27;;
				}else{
				oT.style.background = &#x27;&#x27;;
				}
				},100)


				12.无缝切换
				1.  1  2  3  4
				---&gt;点击
				5  1  2  3
				---&gt;点击
				4  5  1  2
				---&gt;点击
				2  4  5  1
				......


				2. 点击的时候，复制出来 1 2 3 4来扔到5的后面
				紧接着把前面的 1 2 3 4 给删掉
				5 1 2 3

				再点击的时候，把 5 1 2 3复制出来，扔到4的后面
				紧接着把5 1 2 3删掉
				4 5 1 2

				.....
				实现无缝切换

				oInput
				oUl
				aLi
				动态计算ul的宽度
				var oneSize = aLi[0].offsetWidth + 10; // 10是margin值
				var bBtn = true;

				 function getWidth(){
				  oUl.style.width = aLi.length * oneSize + &#x27;px&#x27;;
				  }
				  getWidth();

				  var  iNum = 4; //复制4个
				  oInput.onclick = function(){

				  if(bBtn){
				        bBtn = false;

				        复制前四个，添加到后面
				      剪切节点：appendChild  直接剪切掉没了，不好
				      赋值节点：cloneNode(); 参数true 复制子节点； false, 只会复制li  不会复制里面的内容
				      for(var i=0; i&lt;iNum; i++){
				          var oLi = aLi[i].cloneNode(true);
				          oUl.appendChild(oLi); //宽度不够
				          getWidth();
				      }

				      startMove(oUl,{left : -iNum*oneSize },function(){
				                回调函数里干的事，删除4个
				                for(var i=0; i&lt;iNum; i++){
				                    oUl.removeChild(aLi[0]);//每次删第一个就好了，删四回
				                    删一次我们要把left拉回为0
				                    oUl.sytle.left = 0;
				                }
				                bBtn = true; //回调完成后才打开开关
				      }); //跑4个li的width

				      //有一个bug，快速点击多次的时候，会出现很多数字， 原因是，每次回调函数还没有完成，就执行下一次的点击了，这样就覆盖了。 怎么办，我们用一个开关，当回调函数走完以后，才能执行下一次的切换。

				   }

				}


				13.小米Ico图标网址: &lt;link rel=&quot;shortcut icon&quot; href=&quot;http://s01.mifile.cn/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;

				14. 这个时间是干嘛的：&lt;script type=&quot;text/javascript&quot;&gt;var _head_over_time = (new Date()).getTime();&lt;/script&gt;



				15.同域名下的是这样的： 看href:
				&lt;a class=&quot;link active&quot; href=&quot;/hongmi3/&quot;&gt;功能&lt;/a&gt;
				&lt;span class=&quot;sep&quot;&gt;|&lt;/span&gt;
				&lt;a class=&quot;link&quot; href=&quot;/hongmi3/design/&quot;&gt;设计&lt;/a&gt;
				&lt;span class=&quot;sep&quot;&gt;|&lt;/span&gt;
				&lt;a class=&quot;link&quot; href=&quot;/hongmi3/camera/&quot;&gt;相机&lt;/a&gt;
				&lt;span class=&quot;sep&quot;&gt;|&lt;/span&gt;
				&lt;a class=&quot;link&quot; href=&quot;/hongmi3/miui/&quot;&gt;应用&lt;/a&gt;
				&lt;span class=&quot;sep&quot;&gt;|&lt;/span&gt;
				&lt;a class=&quot;link&quot; href=&quot;/hongmi3/specs/&quot;&gt;参数&lt;/a&gt;
				&lt;span class=&quot;sep&quot;&gt;|&lt;/span&gt;
				&lt;a class=&quot;link&quot; href=&quot;http://order.mi.com/queue/f2code&quot; target=&quot;_blank&quot;&gt;F码通道&lt;/a&gt;


				16.加载的时候，几个字有点动的效果，结构
				&lt;h1 class=&quot;title webfont&quot;&gt;&lt;span class=&quot;step-w&quot;&gt;红&lt;/span&gt;&lt;span class=&quot;step-n&quot;&gt;米&lt;/span&gt;&lt;span class=&quot;step-s&quot;&gt;手&lt;/span&gt;&lt;span class=&quot;step-e&quot;&gt;机 3&lt;/span&gt;&lt;/h1&gt;

				17，插入video
				            &lt;div class=&quot;video-wrapper&quot;&gt;
				                &lt;video class=&quot;video&quot; data-autoplay=&quot;true&quot; preload=&quot;none&quot; poster=&quot;//s1.mi.com/v/hongmi3/intro-demo-video-01.jpg&quot; loop&gt;
				                    &lt;source type=&quot;video/mp4&quot; src=&quot;//s1.mi.com/v/hongmi3/intro-demo-video-01.mp4&quot; /&gt;
				                    &lt;source type=&quot;video/webm&quot; src=&quot;//s1.mi.com/v/hongmi3/intro-demo-video-01.webm&quot; /&gt;
				                &lt;/video&gt;
				            &lt;/div&gt;


				18.
				所有主流浏览器都不支持 appearance 属性。
				Firefox 支持替代的 -moz-appearance 属性。
				Safari 和 Chrome 支持替代的 -webkit-appearance 属性。
				定义和用法
				appearance 属性允许您使元素看上去像标准的用户界面元素。
				默认值：	normal
				继承性：	no
				版本：	CSS3
				JavaScript 语法：	object.style.appearance=&quot;button&quot;
				语法
				appearance: normal|icon|window|button|menu|field;
				值	描述
				normal	将元素呈现为常规元素。
				icon	将元素呈现为图标（小图片）。
				window	将元素呈现为视口。
				button	将元素呈现为按钮。
				menu	将元素呈现为一套供用户选择的选项。
				field	将元素呈现为输入字段。


				19.box-sizing:
				box-sizing 属性允许您以特定的方式定义匹配某个区域的特定元素。
				例如，假如您需要并排放置两个带边框的框，可通过将 box-sizing 设置为 &quot;border-box&quot;。这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。

				div.box
				{
				box-sizing:border-box;
				-moz-box-sizing:border-box; /* Firefox */
				-webkit-box-sizing:border-box; /* Safari */
				width:50%;
				border:1em solid red;
				float:left;
				}
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;

				&lt;div class=&quot;container&quot;&gt;
				&lt;div class=&quot;box&quot;&gt;这个 div 占据左半部分。&lt;/div&gt;
				&lt;div class=&quot;box&quot;&gt;这个 div 占据右半部分。&lt;/div&gt;
				&lt;/div&gt;

				&lt;/body&gt;
				&lt;/html&gt;


				20.transition:
				注意，使用的时候，可以输入all ,width，height,进行有目的的选择
				{
				width:100px;
				height:100px;
				background:blue;
				transition:width 2s;
				-moz-transition:width 2s; /* Firefox 4 */
				-webkit-transition:width 2s; /* Safari and Chrome */
				-o-transition:width 2s; /* Opera */
				}

				可以延迟，可以这样写：
				div
				{
				width:100px;
				height:100px;
				background:blue;
				transition-property:width;
				transition-duration:5s;
				transition-delay:2s;

				/* Firefox 4 */
				-moz-transition-property:width;
				-moz-transition-duration:5s;
				-moz-transition-delay:2s;

				/* Safari and Chrome */
				-webkit-transition-property:width;
				-webkit-transition-duration:5s;
				-webkit-transition-delay:2s;

				/* Opera */
				-o-transition-property:width;
				-o-transition-duration:5s;
				-o-transition-delay:2s;
				}

				div:hover
				{
				width:300px;
				}

				这样写：
				-webkit-transition:all .2s linear;
				-webkit-transition:border-color .2s linear;
				-webkit-transition:color .2s .2s linear;

				21.获取焦点的输入框，边框设置为0：
				.input-text:focus{outline:0}

				22.-webkit-transform:translate3d(0, 5px, 0);

				23.backface-visibility
				backface-visibility 属性定义当元素不面向屏幕时是否可见。
				如果在旋转元素不希望看到其背面时，该属性很有用


				div
				{
				position:relative;
				height:60px;
				width:60px;
				border:1px solid #000;
				background-color:yellow;
				transform:rotateY(180deg);
				-webkit-transform:rotateY(180deg); /* Chrome and Safari */
				-moz-transform:rotateY(180deg); /* Firefox */
				}
				#div1
				{
				-webkit-backface-visibility:hidden;
				-moz-backface-visibility:hidden;
				-ms-backface-visibility:hidden;
				}
				#div2
				{
				-webkit-backface-visibility:visible;
				-moz-backface-visibility:visible;
				-ms-backface-visibility:visible;
				}
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;

				&lt;p&gt;本例有两个 div 元素，均旋转 180 度，背向用户。&lt;/p&gt;

				&lt;p&gt;第一个 div 元素的 backface-visibility 属性设置为 &quot;hidden&quot;，所以应该是不可见的。&lt;/p&gt;

				&lt;div id=&quot;div1&quot;&gt;DIV 1&lt;/div&gt;

				&lt;div id=&quot;div2&quot;&gt;DIV 2&lt;/div&gt;

				&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例只在 Internet Explorer 10、Firefox、Chrome 以及 Safari 中有效。&lt;/p&gt;

				&lt;/body&gt;



				24.选中文字分享：
				效果：
				当我选中文字的时候，鼠标抬起来的时候，
				出现一个“微博”的图标，用于分享。
				出现的位置也在鼠标抬起来的地方

				当点击图标的时候，弹出分享的页面
				里面是选中的文字，加上链接的地址。

				当选中的文字数量小于十的时候，不弹出

				怎么样找到选中的文字？

				&lt;p&gt;xxxxx&lt;/p&gt;
				&lt;div&gt;&lt;img src=&quot;&quot;/&gt;&lt;/div&gt;

				function selectText(){
				if(document.selection){ //针对IE的
				    return document.selection.createRange().text; // 找到文字
				}else{
				    return window.getSelection().toString(); // 对象转为字符串， 利用它的length
				}
				}


				oP.onmouseup = function(ev){
				var ev = ev || window.event;
				var left = ev.clientX;
				var top = ev.clientY;
				if(selectText().length&gt;10){
				    setTimeout(function(){ // 延迟一下在弹出来，体验好一点；  注意下面不能用ev.clientX， 我们把它们传进去；
				        oDiv.style.display = &#x27;block&#x27;;
				        oDiv.style.left = left + &#x27;px&#x27;;
				        oDiv.style.top = top + &#x27;px&#x27;;
				    },100)

				}else{
				    oDiv.style.display = &#x27;none&#x27;;
				}
				}


				点任意位置消失：
				注意，用这个的时候，上面的事件会冒泡到来这里的，因此我们需要阻止一下冒泡。
				oP.onclick = function(ev){
				var ev = ev || window.event;
				ev.cancelBubble = true;
				}

				document.onclick = function(){
				oDiv.style.display = &#x27;none&#x27;;
				}



				oDiv.onclick = function(){
				window.location.href = &#x27;http://xxxxxx&amp;title=&#x27;+ selectText() +&#x27;&amp;url=&#x27;要链接的页面的网址 &#x27; &#x27;;
				}



				javascript中的location.href有很多种用法，主要如下。
				self.location.href=&quot;/url&quot; 当前页面打开URL页面
				location.href=&quot;/url&quot; 当前页面打开URL页面
				windows.location.href=&quot;/url&quot; 当前页面打开URL页面，前面三个用法相同。
				this.location.href=&quot;/url&quot; 当前页面打开URL页面
				parent.location.href=&quot;/url&quot; 在父页面打开新页面
				top.location.href=&quot;/url&quot; 在顶层页面打开新页面



				25. this传进定时器里去用： 在定时器里面不能直接用this
				aA[i].onmouseout = function(){
				var that = this; // 注意看，这里怎么把this， 传进定时器里去，定时器里不能直接用this,因为指向的是window。
				timer = setTimeout(function(){
				     aSpan[that.index].style.display = &#x27;none&#x27;;
				},1000)
				}

				26. css3属性选择器
				1.transition:1s;
				过渡
				兼容问题：
				ie10以下不兼容
				怎么办？
				js来实现

				前缀 -webkit-   -moz-  -o-
				js里写成这样：
				WebkitTransition
				MozTransition
				OTransition


				2.新增的选择器：
				属性选择器：
				p[miaov]{background:red;}
				&lt;p miaov = &#x27;leo&#x27;&gt;&lt;/p&gt;

				p[miaov=leo]{background:red};

				p[miaov~=old]{background:red;}
				&lt;p miaov = &#x27;leo old&#x27;&gt;&lt;/p&gt;

				p[miaov^=b]{background:red}
				&lt;p miaov = &#x27;bleo&#x27;&gt;&lt;/p&gt;

				p[miaov$=M]{background:red}
				&lt;p miaov = &#x27;leoM&#x27;&gt;&lt;/p&gt;

				p[miaov*=o]{background:red}
				&lt;p miaov = &#x27;leo&#x27;&gt;&lt;/p&gt;
				&lt;p miaov = &#x27;ovh&#x27;&gt;&lt;/p&gt;

				p[miaov|=b]{background:red;}
				&lt;p miaov = &#x27;b-leo&#x27;&gt;&lt;/p&gt;
				&lt;p miaov = &#x27;b-eeo&#x27;&gt;&lt;/p&gt;
				&lt;p miaov = &#x27;eo&#x27;&gt;&lt;/p&gt;
				&lt;p miaov = &#x27;b&#x27;&gt;&lt;/p&gt;


				27.css3文本新增属性
				1. not()

				&lt;style&gt;
				h1:not(.h2){ background:Red;}
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;h1&gt;h1&lt;/h1&gt;
				&lt;h1 class=&quot;h2&quot;&gt;h1&lt;/h1&gt;
				&lt;h1&gt;h1&lt;/h1&gt;

				2.first-line、 first-letter、 selection、 before、 after

				&lt;style&gt;
				p{width:300px;border:1px solid #000;font:12px/30px &quot;宋体&quot;;padding:10px;}
				p:first-line{ background:red;}
				p:first-letter{ font-size:30px;}
				p::selection{background:#F60;color:#690;}
				p:before{ content:&quot;MiaoV&quot;; display:block; border:1px solid #000;}
				p:after{ content:&quot;MiaoV&quot;; display:block; border:1px solid #000;}
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p&gt;前端开发的世界从未有过无声的寂静，精彩纷呈的互联网也不曾出现片刻安宁，
				在 HTML5&amp;CSS3 被炒至沸沸扬扬的今天，
				全面系统的掌握此项技能，是加重技术含金量的重要砝码！
				妙味课堂现已为你开启一个崭新的职业规划……&lt;/p&gt;

				3.文字阴影
				text-shadow:2px 2px 4px #000;

				4.超出文字提供省略号
				p{width:300px;border:1px solid #000;font:14px/30px &quot;宋体&quot;; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p&gt;妙味课堂具有人性化的IT培训机构妙味课堂具有人性化的IT培训机构&lt;/p&gt;


				5.文字排版
				p{width:300px;border:1px solid #000;font:14px/30px &quot;宋体&quot;;direction:rtl;unicode-bidi:bidi-override;}
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;p&gt;妙味课堂&lt;/p&gt;

				6.文字描边 有兼容问题
				h1{ font:100px/200px &quot;微软雅黑&quot;; text-align:center; color:#000;-webkit-text-stroke:3px red;}


				7.文字模糊

				h1{ font:100px/200px &quot;微软雅黑&quot;; text-align:center; color:#000; text-shadow:0 0 0 rgba(0,0,0,1); border:1px solid #000; transition:1s;}
				h1:hover{color:rgba(0,0,0,0);text-shadow:0 0 100px rgba(0,0,0,0.5);}


				8.文字阴影

				h1{ font:100px/200px &quot;微软雅黑&quot;; text-align:center; text-shadow:-5px -10px 1px red,5px 10px 2px green,1px 1px 5px yellow;}


				9.rgba  文字透明

				.box{width:200px;height:190px;background:url(miaov.jpg) no-repeat center; color:#fff; font:80px/90px &quot;微软雅黑&quot;; text-align:center; color:rgba(255,255,255,0.5);border:10px solid rgba(0,0,0,0.5);}

				10. 北背景透明
				body{background:url(miaov.jpg);}
				.box{width:200px;height:200px;background:rgba(0,0,0,0.5); color:#fff; font:40px/100px &quot;微软雅黑&quot;; text-align:center;}


				28.css3结构选择器
				1.结构选择器：
				p:nth-child(1){xx}===p:first-child{}
				p:nth-child(odd){background:red;}
				p:nth-child(even){xxxx}
				p:nth-child(2n){}
				p:nth-child(2n-1){}

				这个是，找到p的父级，然后看父级的子节点，有几个子节点。
				注意它是你选得p标签或者其他标签
				如果子节点有不是你选择，但它处于第n个位置，
				也是选不到的
				如果我想要达到，不管里面是什么标签，只看位置：
				body*:nth-child(2){xxxx}


				p:nth-last-child{xxx}
				这个是从后往前选


				p:nth-of-type(2){xxxxx};
				这个跟nth-child(2)一样
				区别在于：of-type找的是，父级下第几个什么类型的标签;  nth-child找的是，父级下的子节点；


				例：
				.list li:nth-child(3) a:nth-child(2){xxx}


				选择后面的兄弟元素：
				p~h1{ background:Red;}

				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;h1&gt;h1&lt;/h1&gt;
				&lt;p&gt;p&lt;/p&gt;
				&lt;h1&gt;h1&lt;/h1&gt;
				&lt;h1&gt;h1&lt;/h1&gt;


				29.css3新增伪类
				1.关于锚点

				div:target{ display:block;}
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;a href=&quot;#div1&quot;&gt;div1&lt;/a&gt;
				&lt;a href=&quot;#div2&quot;&gt;div2&lt;/a&gt;
				&lt;a href=&quot;#div3&quot;&gt;div3&lt;/a&gt;
				&lt;div id=&quot;div1&quot;&gt;div1&lt;/div&gt;
				&lt;div id=&quot;div2&quot;&gt;div2&lt;/div&gt;
				&lt;div id=&quot;div3&quot;&gt;div3&lt;/div&gt;


				2.checked

				&lt;style&gt;
				input:checked{ width:100px;height:100px;}
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;input type=&quot;checkbox&quot; /&gt;

				3.enabled、 disabled

				input:enabled{ color:red;}
				input:disabled{ color:blue;}
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;input type=&quot;text&quot; value=&quot;请输入&quot;/&gt;



				p:target
				锚
				href ...
				id ...


				30.弹性盒模型
				1.弹性盒模型：
				.box{height:100px;border:10px solid #000;padding:10px; display:-webkit-box;}
				.box div{width:100px;height:100px;background:red;border:1px solid #fff;}


				-webkit-box-orient:横向  默认  常用这个
				-webkit-box-direction: 排列顺序
				normal  正
				reverse 反

				如果要随意的排列每一个元素呢：
				.box div:nth-of-type(1){ -webkit-box-ordinal-grounp:2;}
				.box div:nth-of-type(2){ -webkit-box-ordinal-grounp:5}
				.box div:nth-of-type(3){ -webkit-box-ordinal-grounp:1}
				.box div:nth-of-type(4){ -webkit-box-ordinal-grounp:3}
				.box div:nth-of-type(5){ -webkit-box-ordinal-grounp:4}



				按照比例展开宽度：
				子元素的尺寸=
				        盒子的尺寸*  (子元素的box-flex属性值/所有子元素的box-flex)


				富裕空间的管理：
				水平方向-webkit-box-pack
				 start  子元素左侧 空间在右侧
				 end	子元素右侧 空间在左侧
				 center 子元素居中
				 justify	富裕空间在子元素之间平均分布（）

				垂直方向-webkit-box-align
				    start
				    end
				    center




				盒模型新增属性：
				 盒子阴影
				    box-shadow: 10px 10px 30px blue;  x方向偏移 y方向偏移 模糊半径  阴影颜色

				新增参数：insert 写在开头
				    内投影

				扩展半径---扩展多少px才开始模糊  写在模糊半径下一个


				渐变：
				线性渐变		background:-webkit-linear-gradient(red 0,100%)



				倒影：-webkit-box-reflect
				    direction  below left right above
				    倒影距离px

				    -webkit-linear-gradient(right,rgba(0,0,0,1) 0,rgba(0,0,0,0) 50%)






				resize:both; 配合 overflow:auto;
				拖拽盒子变大变小


				盒模型的怪异解析：
				  content-box标准盒模型
				    width/height = border+padding+content
				  border-box怪异盒模型
				    width/height = content

				  .box{width:200px;height:200px;padding:50px;border:10px solid #000; 		box-sizing:border-box;}
				  .div{height:50px;background:red;}



				box-sizing有两个值一个是content-box，另一个是border-box。

				当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；

				当设置为box-sizing:border-box时，将采用怪异模式解析计算；

				目前使用此属性需要前缀如下:

				-webkit-box-sizing: content-box;
				-moz-box-sizing: content-box;

				在怪异模式下的盒模型如下图所示，盒子的总宽度和高度是包含内边距padding和边框border宽度在内的，盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin;




				布局相关：
				1.分栏布局


				CSS3里的column系列属性提供了各种不同的功能，通过组合使用它们，你能得到相应的任何分栏式布局：
				column-count: 列数目
				column-gap: 各列之间间隙宽度
				column-width: 建议宽度；未必会使用，浏览器基于此数值进行计算
				column-rule-width：列之间分割线宽度
				column-rule-style：列之间分割线风格
				column-rule-color：列之间分割线演示
				column-span: 允许一个元素的宽度跨越多列
				column-fill: 分列方式



				div.col {
				-webkit-column-count: 2;
				-webkit-column-gap: 5px;
				-webkit-column-rule:1px solid red;

				-moz-column-count: 2;
				-moz-column-gap: 5px;
				-moz-column-rule:1px solid red;

				font-size:12px;
				border:1px solid #e2e2e6;
				}

				div.col h3 {
				-webkit-column-span: all;

				-moz-column-span: all;

				text-align:center;
				background: #eee;
				}

				HTML:  div也可换成&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 式
				[html] view plaincopyprint?在CODE上查看代码片派生到我的代码片
				&lt;div class=&quot;col&quot;&gt;
				&lt;h3&gt;表头&lt;/h3&gt;
				&lt;div&gt;列 1&lt;/div&gt;
				&lt;div&gt;列 2&lt;/div&gt;
				&lt;div&gt;列 3&lt;/div&gt;
				&lt;div&gt;列 4&lt;/div&gt;
				&lt;div&gt;列 5&lt;/div&gt;
				&lt;div&gt;列 6&lt;/div&gt;
				&lt;div&gt;列 7&lt;/div&gt;
				&lt;div&gt;列 8&lt;/div&gt;
				&lt;div&gt;列 9&lt;/div&gt;
				&lt;div&gt;列 10&lt;/div&gt;
				&lt;/div&gt;
				效果图：
				    方法1  -webkit-column-width: 250px;

				    方法2  -webkit-column-count:4;


				栏目间隔：-webkit-column-gap:10px;

				栏目间隔线 ： -webkit-column-rule:1px solid #000;

				加上-weib-kit
				只有它兼容

				2.响应式布局


				响应式Web设计(Responsive Web design)的理念是：
				页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整。具体的实践方式由多方面组成，包括弹性网格和布局、图片、CSS media query的使用等。无论用户正在使用笔记本还是iPad，我们的页面都应该能够自动切换分辨率、图片尺寸及相关脚本功能等，以适应不同设备；换句话说，页面应该有能力去自动响应用户的设备环境。响应式网页设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这样，我们就可以不必为不断到来的新设备做专门的版本设计和开发了。


				一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本
				media这种不兼容ie6、7、8
				需要js去判断屏幕的分辨率 宽度 根据宽度不同 去引入不同的样式表
				第一种：根据宽度不同去引入不同的样式表



				横竖屏切换



				媒体特性
				(max-width:600px)
				(max-device-width: 480px)  设备输出宽度
				(orientation:portrait)  竖屏
				(orientation:landscape)	横屏
				(-webkit-min-device-pixel-ratio: 2) 像素比



				&lt;link rel=”stylesheet” media=”all and (orientation:portrait)” href=”portrait.css”&gt;
				&lt;link rel=”stylesheet” media=”all and (orientation:landscape)”href=”landscape.css”&gt;
				@media screen and (min-width:400px) and (max-width:500px) {.box {margin: 0 auto;}}




				&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleA.css&quot;  media=&quot;screen and (min-width: 800px)&quot;&gt;
				&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleB.css&quot; media=&quot;screen and (min-width: 600px) and (max-width: 800px)&quot;&gt;
				&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;styleC.css&quot;    media=&quot;screen and (max-width: 600px)&quot;&gt;


				&lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;
				width [pixel_value | device-height]
				height [pixel_value | device-height]
				user-scalable 是否允许缩放 （no||yes）
				initial-scale 初始比例
				minimum-scale 允许缩放的最小比例
				maximum-scale 允许缩放的最大比例
				target-densitydpi [dpi_value | device-dpi | high-dpi | medium-dpi | low-dpi]


				线性渐变  ie下
				background:-webkit-linear-gradient(red,blue);background:-moz-linear-gradient(red,blue);background:linear-gradient(red,blue); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=&#x27;red&#x27;,endColorstr=&#x27;blue&#x27;,GradientType=&#x27;0&#x27;);


				背景尺寸
				background:url(../jQuery/img/6.jpg) no-repeat;
				background-size:100% 100%;}

				放两张背景图
				background:url(../jQuery/img/1.jpg) no-repeat
				,url(../jQuery/img/289406.jpg) no-repeat 0 bottom;
				background-size:contain, 300px 200px;

				背景图原点设置：
				background-origin:content-box

				背景裁切:
				background-clip:content-box;


				文字clip:

				.wrap{
				width:400px;
				height:400px;
				line-height:400px;
				margin:100px auto 0;
				border:1px solid #0F0;
				padding:50px;
				font-size:200px;
				text-align:center;
				color:rgba(0,0,0,0.2);
				text-shadow:10px 10px 10px #000;
				background:url(img/01.png);
				background-size:100%,100%;
				-webkit-background-clip:text;
				transition:6s;}

				.wrap:hover{
				background-position:-200px -200px;}


				iphone开机：

				&lt;style&gt;
				body{
				background:#000;}
				#wrap{
				width:1200px;
				height:400px;
				line-height:400px;
				color:rgba(250,250,250,0.3);
				text-align:center;
				font-size:100px;
				background:-webkit-linear-gradient(
				-30deg,rgba(255,255,255,0) 100px,
				rgba(255,255,255,1) 200px,
				rgba(255,255,255,1) 250px,
				rgba(255,255,255,0) 300px)
				-300px 0 no-repeat;
				-webkit-background-clip:text;
				margin:0 auto;
				text-shadow:3px 3px 2px red;}


				&lt;/style&gt;
				&lt;/head&gt;

				&lt;body&gt;
				&lt;div id=&quot;wrap&quot;&gt;
				CSS3 HTML5
				&lt;/div&gt;
				&lt;script&gt;
				var oWrap = document.getElementById(&#x27;wrap&#x27;);

				var left = -300;
				var timer = null;
				toRun();
				function toRun(){

				timer = setInterval(function(){
				left +=20;
				if( left == 1200 ){
				    left = -300;
				    clearInterval(timer);
				}
				oWrap.style.backgroundPosition = left + &#x27;px&#x27;;

				},30)
				}
				setInterval(function(){
				toRun();
				},3000)
				&lt;/script&gt;


				遮罩
				#wrap{
				width:1200px;
				height:500px;
				border:1px solid #ccc;
				margin:50px auto;
				background:url(img/01.png) no-repeat;
				background-size:100% 100%;
				-webkit-mask:url(img/mask.png) no-repeat;
				transition:3s;}

				#wrap:hover{
				-webkit-mask-position:800px 200px;}


				31.UI新样式：
				1.圆角：
				border-radius:半径
				两个值：border-radius: a左上角 右下角  b右上角 左下角
				三个值 a b c  左上角  右上角左下角  右下角

				四个值 a b c d  顺时针


				2.椭圆x y 值不同
				x轴/y轴半径  border-radius:100px/150px
				border-radius: {20px 50px 100px 150px/ 10px 40px 80px 140px}


				3. %用起来更方便



				4.边框背景
				-webkit-border-image:url() 0 10;
				border-left-width:10px;
				border-right-width:10px;

				参数border-image-sourceg引入图片
				border-image-slice切割图片： 上下  左右 	不加px，会根据边框宽度进行缩放

				border-image-repeat图片的排列方式
				round 平铺
				repeat  重复
				stretch 拉伸

				在-webkit-内核下，
				-webkit-border-image：xxxx
				里面内容会平铺



				5.边框多种颜色
				没太大实际意义 在火狐下：
				-moz-border-left-colors{red blue yellow}



				6.线性渐变
				background-image:-webkit-linear-gradient(left top, red,blue)
				起点也可以用这个:(30deg)
				具体坐标：
				(60deg,red 30px,blue 100px)
				(60deg,red 0,blue 50%,green,100%)

				平铺：
				backgrouond-image: -webkit-repeating-linear-gradient(60deg,red 0,blue 30px)


				ie下怎么兼容：
				ie9以下无效
				滤镜：filter:xxx





				7.一个元素可以加多个背景
				background:url() no-repeat,url() repeat -y right 0;

				背景尺寸

				background-size:100% 100%;
				background-size: 100px 100px;
				background-size: cover/contain,100px 100px(两张背景图的话); // 覆盖，有出去 // 包含，就包含


				背景图的原点设计：
				0 0点： 边框左上角开始计算： background-origin:border-box;
				默认值： background-origin:padding-box；
				从内容框的左上角开始算0 0：
				background-origin:content-box;


				背景裁切：
				背景在边框也显示：  background-clip:border-box;默认
				背景不要在边框显示：background-clip:padding-box;
				背景在内容区显示：background-clip:content-box;

				-webkit-独有的：
				-webkit-background-clip:text;
				只给文字加了背景





				8.径向渐变
				background:-webkit-radial-gradient(left top, circle,red 30px,blue 30px)
				起点 只能是关键字 或者具体的一个数值
				circle也可以换成：x y半径值 20px 20px

				-moz-
				火狐下，
				参数：closest-side 最近端
				closest-corner最近角
				farthest-side最远端
				farthest-corner最远角
				contain 放在元素里  不出去
				cover 覆盖  铺面 有出去

				32.过渡transition:
				1.过渡
				transition
				1.参数： 过渡时间 1s 2000ms
				2.筛选过渡的样式： width.... all所有
				3.过渡的形式：ease默认逐渐慢
				    /ease-in加速
				    /ease-out减速
				    /linear匀速
				    /ease-in-out先加速后减速
				    /cublic-bezier 贝赛尔曲线(x1, y1, x2, y2)
				    cublic-bezier(0.145,1.295,0.000,1.610)


				多个样式同时需要过渡：
				transition:1s width,2s height,3s background;
				:hover{width:500px; height:300px; background:red;}



				延迟时间过渡：
				transition:1s width,2s 1s height,3s 2s background;
				:hover{width:400px; height:200px; background:red;}



				transition End的事件
				发生在过渡完成之后
				function addEnd(obj,fn)
				{
				obj.addEventListener(&#x27;WebkitTransitionEnd&#x27;,fn,fasle);
				obj.addEventListener(&#x27;transitionend&#x27;,fn,false)
				}


				&lt;script&gt;
				oBox.onclick = function()
				{
				this.style.width = this.offsetWidth + 100 + &#x27;px&#x27;;
				}

				addEnd(oBox,function()
				{
				alert(&#x27;end&#x27;);
				})

				&lt;/script&gt;

				问题： 1.当两个样式的时候，会触发两次End的事件
				2.end函数是下面这样的话，会一直循环加Width. 怎么解决： end函数

				addEnd(oBox,function()
				{
				this.style.width = this.offsetWidth + 100 + &#x27;px&#x27;;
				})

				function end()
				{
				this.style.width = this.offsetWidth + 100 + &#x27;px&#x27;;
				removeEnd(this,end);
				}


				function removeEnd(obj,fn)
				{
				obj.removeEventListener(&#x27;WebkitTransitionEnd&#x27;,fn,fasle);
				obj.removeEventListener(&#x27;transitionend&#x27;,fn,false)
				}



				2D变换：
				 body:hover .box{ -webkit-transform:rotate(360deg)}


				斜切的函数：
				拉成棱形....
				body:hover .box{ -webkit-transform:skewX(45deg);}--- x轴
				    skewY()----y轴
				    skew( 15deg,30deg )-----x y都....



				斜切的导航
				....
				文字不需要倾斜，怎么出来：
				给a标签一个负的deg



				缩放：
				body:hover .box{ -webkit-transform:scaleX(2);}
				scaleY(0.5)
				scale(2)

				位移：
				body:hover .box{ -webkit-transform:translateX(100px);}
				translateY(100px)
				translate(100px,200px)



				变换的基点：
				 .box{
				 -webkit-transform-origin:right;}
				关键字//right bottom/ left/ left top....
				具体数值/10px 10px/0 0/200px 200px


				body:hover .box{
				-webkit-transform:rotate(360deg) scale(0.2)}



				问题：
				  -webkit-transform
				  执行顺序：
				    先执行写在后面。
				    会出现，同样的样式，出来的结果不同的现象。





				钟表：



				transform另外的属性：
				矩阵：
				-webkit-transform:matrix(0.5,0.38,-0.38,2,0,0);

				martrix(1,0,0,1,0,0):
				martrix(a,b,c,d,e,f)
				a:x轴的缩放
				d:y轴的缩放
				e是x轴的位移
				f是y轴的位移
				    标准下  6位参数
				    ie下 有点长

				progid:DXImageTransform.Microsoft.Matrix( M11= 1, M12= 0, M21= 0 , M22=1,SizingMethod=&#x27;auto expand&#x27;);
				Matrix( M11= a, M12= c, M21= b , M22=d,SizingMethod=&#x27;auto expand&#x27;);
				ie的没有e f 位移参数






				动画：
				animation

				@-webkit-keyframes move(
				0%{
				    width:100px;
				}
				100%{
				    width:500px;
				}
				)
				.box{-webkit-animation:2s 1s move; animation:2s 1s move ease-in 5;}延迟1s; 重复5次；加速；

				@-moz-keyframs move({})

				动画帧
				关键帧
				参数：linear
				     ease-in
				     ease-out
				延迟时间
				重复次数





				box-sizing 属性允许您以特定的方式定义匹配某个区域的特定元素。
				例如，假如您需要并排放置两个带边框的框，可通过将 box-sizing 设置为 &quot;border-box&quot;。这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。


				.box{width:100px;height:100px; border-width:20px; -webkit-border-image:url(border.png) 27 27 round stretch;}



				;background:-webkit-repeating-linear-gradient(15deg,green 0,green 10px,#fff 10px,#fff 20px)




				过渡的样式：
				transition:2s width;

				贝塞尔曲线：
				transition:5s width cubic-bezier(0.145,1.295,0.000,1.610);

				同步进行：
				.box{width:100px;height:100px;background:red; transition:1s width,2s height,3s background;}
				.box:hover{width:500px;height:300px;background:blue;}


				延迟：
				transition:2s width,2s 3s height,2s 3s background;}


				当过渡完成后触发
				事件监听：
				obj.onclick = function(){
				this.style.width = obj.offsetWidth + &#x27;200&#x27; + &#x27;px&#x27;;
				}

				addEnd(obj,function(){
				alert( &#x27;展现出来了&#x27; )
				this.style.width = obj.offsetWidth + 200 + &#x27;px&#x27;; ////这样会一直加下去。。。。
				})

				function addEnd(obj,fn){
				obj.addEventListener(&#x27;WebkitTransitionEnd&#x27;,fn,false)
				obj.addEventListener(&#x27;transitionend&#x27;,fn,false)
				}




				过度完触发完，取消监听：
				oBox.onclick=function()
				{
				this.style.width=this.offsetWidth+100+&quot;px&quot;;
				addEnd(oBox,end);
				};
				function end()
				{
				this.style.width=this.offsetWidth+100+&quot;px&quot;;
				removeEnd(this,end);
				}

				function addEnd(obj,fn)
				{
				obj.addEventListener(&#x27;WebkitTransitionEnd&#x27;,fn,false);
				obj.addEventListener(&#x27;transitionend&#x27;,fn,false);
				}
				function removeEnd(obj,fn)
				{
				obj.removeEventListener(&#x27;WebkitTransitionEnd&#x27;,fn,false);
				obj.removeEventListener(&#x27;transitionend&#x27;,fn,false);
				}
				&lt;/script&gt;





				-webkit-transform:rotate(60deg);
				-webkit-transform:skewX(15deg);
				-webkit-transform:skew(30deg,60deg);

				倾斜的导航：
				li{float:left;width:100px; text-align:center;height:30px;border:1px solid #fff; background:Red; font:12px/30px &quot;宋体&quot;; -webkit-transform:skewX(30deg); }
				a{text-decoration:none;-webkit-transform:skewX(-30deg); display:block;}


				放大或者缩小：
				li:hover{
				-webkit-transform:scale(2);
				background:blue;}


				位移：
				li:hover{
				-webkit-transform:translateX/Y/Z(100px)}

				变换基点
				div{
				-webkit-transform-origin:right/200px,100px/top;}






				风车+ie修复

				var oDiv = document.getElementById(&#x27;div1&#x27;);
				var iDeg = 0;
				setInterval(function(){
				iDeg++;
				toRotate(oDiv,iDeg)
				},30)

				function toRotate(obj,iDeg){
				var a =Math.round(Math.cos(iDeg/180*Math.PI)*100)/100;;
				var b=Math.round(Math.sin(iDeg/180*Math.PI)*100)/100;
				var c=-b;
				var d=a;
				obj.style.WebkitTransform=&quot;matrix(&quot;+a+&quot;,&quot;+b+&quot;,&quot;+c+&quot;,&quot;+d+&quot;,0,0)&quot;;
				obj.style.MozTransform=&quot;matrix(&quot;+a+&quot;,&quot;+b+&quot;,&quot;+c+&quot;,&quot;+d+&quot;,0,0)&quot;;
				obj.style.transform=&quot;matrix(&quot;+a+&quot;,&quot;+b+&quot;,&quot;+c+&quot;,&quot;+d+&quot;,0,0)&quot;;
				obj.style.filter=&quot;progid:DXImageTransform.Microsoft.Matrix( M11=&quot;+a+&quot;, M12= &quot;+c+&quot;, M21= &quot;+b+&quot; , M22=&quot;+d+&quot;,SizingMethod=&#x27;auto expand&#x27;)&quot;;
				obj.style.left=(obj.parentNode.offsetWidth-obj.offsetWidth)/2+&quot;px&quot;;
				obj.style.top=(obj.parentNode.offsetHeight-obj.offsetHeight)/2+&quot;px&quot;;
				}


				33.关键帧 3d变换
				1.
				.box:hover .div{ -webkit-transform:rotateX(180deg)}
				给box变为3D空间：
				-webkit-transform-style:(preserve-3d);
				景深：-webkit-perspective:100px;
				意思是站在100px外看这个元素

				y轴：
				.box:hover .div{ -webkit-transform:rotateY(180deg)}

				Z轴:
				.box:hover .div{ -webkit-transform:rotateZ(180deg)}


				-web-kit-transform:translateZ(100px)
				正值向前移动 离我更近
				负值向里移动  离我更远


				从哪个角度看：
				.wrap{
				-webkit-perspective-origin:center center;}




				动画：
				关键帧：
				@-webkit-keyframes move{
				0%{
				width:100px;
				}
				100%{
				width:500px;
				}
				}

				@-moz-keyframes move{
				0%{
				width:100px;
				}
				100%{
				width:500px;
				}
				}

				@keyframes move{
				0%{
				width:100px;
				}
				100%{
				width:500px;
				}
				}

				.box{ -webkit-animation:2s 1s（延迟） move ease-in 5（重复次数） normal/	alternate(偶数次的时候倒着走)  ; -moz-animation:2s move ease-in; animation:2s move ease-in;}

				infinite无限次


				走回字型：
				@-wbkit-keyframes domove{
				%{
				    top:0;left:0;
				}
				25%{
				    top:0; left:300px
				}
				55%{
				    top:300px;left:300px;
				}
				75%{
				    top:300px; left:0;
				}
				100%{
				    top:0; left:0;
				}
				}

				.box{ -webkit-animation:4s domove}

				#wrap:hover .box{ -webkit-animation-play-state: paused/running }

				动画帧： 跑到目标点后，最后会回到样式表的设置的值，比方说width:100px
				如何让他停在目标点：
				给div加一个class----move
				把运动写到里面
				.move { -webkit-animation:2s move; width:500px;}


				这里的animation也有监听事件,动画完成后：
				function addEnd(obj,fn){
				obj.addEventListener(&#x27;webkitAnimationEnd&#x27; ,fn,false);
				obj.addEventListener(&#x27;animationend&#x27;,fn,false)
				}

				document.getElementById(&#x27;box&#x27;).onclick = function(){
				this.className = &#x27;box move&#x27;;
				addEnd(this,fn);
				}

				function fn(){
				alert(0)
				}



				34.歌手素香单曲:
				折纸的结构：
				&lt;div&gt;
				&lt;h3&gt;&lt;/h3&gt;
				&lt;div&gt;
				&lt;span&gt;1&lt;/span&gt;
				&lt;div&gt;
				&lt;span&gt;2&lt;/span&gt;
				&lt;div&gt;
				    &lt;span&gt;&lt;/span&gt;
				    &lt;div&gt;
				        ....
				    &lt;/div&gt;
				&lt;/div&gt;
				&lt;/div&gt;
				&lt;/div&gt;
				&lt;/div&gt;



				35.当前li，前一个li，的运用：
				var iNow = 0;
				var iZindex = 0;
				aBtn[0].onclick = function(){
				for(var i=0;i&lt;aLi.length;i++){
				aLi[i].style.display = &#x27;none&#x27;;
				}
				if(iNow&lt;1){
				iNow = 5;
				aLi[5].style.display = &#x27;block&#x27;;
				}
				iNow2 = iNow;
				iNow--;
				aLi[iNow2].className = &#x27;show1&#x27;;
				aLi[iNow].style.display = &#x27;block&#x27;;
				aLi[iNow2].style.display = &#x27;block&#x27;;
				aLi[iNow].className = &#x27;hide1&#x27;;
				}


				36.UC浏览器图片切换
				var oActive=document.getElementById(&quot;active&quot;);
				var iZindex=1;
				var i=0;
				var iNow=0;
				for(i=0;i&lt;aBtns.length;i++)
				{
				aBtns[i].index=i;
				aBtns[i].onclick=function()
				{
				iZindex++;
				aLi[this.index].style.zIndex=iZindex;
				aLi[iNow].style.opacity=0;
				aLi[this.index].style.opacity=1;
				iNow=this.index;
				oActive.style.left=this.offsetLeft-2+&quot;px&quot;;
				};
				}
				当我点击每一个li的时候，当前的li就是i,对应的图片展示，就是this.index, 当我第二次点击的时候，我要把上一次展示的图片给隐藏了，因此我要回去，上一次做完展示图片的事情之后，我们把this.index交给一个叫iNow的哥们，保存起来，以便我下一次来的时候，直接跟他要来用。

				37.我想通过角度，斜边长，来获得对应的x,y坐标
				getXY(deg,radius);


				38.阻止事件冒泡
				/*document.oncontextmenu = function(){
				return false;
				}*/     //----&gt; 这样是阻止了。


				document.addEventListener(&#x27;contextmenu&#x27;,function( ev ){
				//return false;
				ev.preventDefault();
				},false)  // 这样没有阻止掉，这个时候用的是event下的一个方法


				document.attachEvent(&#x27;oncontextmenu&#x27;,function(){
				return false;
				},false);  /// ie下的attach方式，要阻止，还是用return false;


				39.关于cookie
				/*
				cookie: 存储数据。可以设置存储时间。当用户访问了某个网页的时候，我们可以通过cookie来向访问者的电脑上存储数据。
				1， 不同的浏览器，存放的cookie位置不一样，不能通用的。
				2，cookie的存储，以域名的形式，进行区分。存在硬盘当中的文件。
				3，怎么存放，格式怎样？相当于一个json一样，可以给数据设置名字： document.cookie = &#x27;名字=值&#x27;;
				4，一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数，不一样。
				5，每一个cookie存放的内容大小也是有限制的，不同浏览器的不一样。


				长时间保存一些东西。

				我们通过document.cookie来获取当前网站下的cookie的时候，得到的是字符串形式的值，它包含了当前网站下所有的cookie;它会把所有的cookie通过一个分好+空格的形式串联起来。

				如果我们想长时间存放一个cookie，需要在设置这个cookie的时候同时给它设置一个过期的时间。怎么设置的： document.cookie = &#x27;名称=值;expires=&#x27; + 时间;    注意：时间必须是字符串形式。
				cookie默认是临时存储的。当浏览器关闭进程的时候，自动销毁。

				如果你存放类似于“您好”这样的数据，是需要转换为编码的。 encodeURI
				*/

				document.cookie = &#x27;username = leo&#x27;;//存
				alert( document.cookie ) //操作

				var oDate = new Date();
				oDate.setDate(oDate.getDate() + 5);//访问那天的5天以后
				document.cookie = &#x27;usename=&#x27;+ encodeURI(&#x27;leo\n你好&#x27;)+&#x27;;expirs=&#x27;+ oDate.toGMTString(); //存

				alert( decodeURI( document.cookie ) );//读


				alert( encodeURI(&#x27;您好&#x27;) );


				封装：
				//var oDate = new Date();
				//	document.cookie = &#x27;usename=leo;expires=&#x27;+oDate.toGMTString();

				//	document.cookie = &#x27;age=32&#x27;;

				//我希望读取出里面的单个值，比方说，usename 的leo




				//  封装成一个函数,用来获取里面的单个数据。
				alert( getCookie(&#x27;usename&#x27;) );

				function getCookie( key ){
				var arr1 = document.cookie.split(&#x27;;&#x27;);
				for( var i=0; i&lt;arr1.length; i++ ){
				    var arr2 = arr1[i].split(&#x27;=&#x27;);
				    if( arr2[0] == key ){
				        return decodeURI( arr2[1] );
				    }
				}
				}

				//封装成函数，用来存cookie数据
				function setCookie( key,value, t ){
				var oDate = new Date();
				oDate.setDate( oDate.getDate() + t );
				document.cookie = key + &#x27;=&#x27; + value + &#x27;;expires=&#x27; + oDate.toGMTString();
				}

				setCookie(&#x27;sex&#x27;,&#x27;男&#x27;,10)


				//封装函数，用来删除cookie
				function removeCookie( key ){
				setCookie(key,&#x27;&#x27;,-1);
				}

				removeCookie(&#x27;usename&#x27;);

				}




				例子：
				if( getCookie(&#x27;username&#x27;)  ){
				oUsername.value = getCookie(&#x27;username&#x27;);
				alert( getCookie(&#x27;username&#x27;)  )
				}

				oLogin.onclick = function(){

				alert(&#x27;登录成功&#x27;);
				setCookie(&#x27;username&#x27;,oUsername.value,5);

				}

				oDel.onclick = function(){
				removeCookie(&#x27;Username&#x27;);
				oUsernam.value = &#x27;&#x27;;
				}



				40. 自己做一个滚动条以及显示框
				&lt;div id=&quot;box&quot;&gt;
				&lt;div id=&quot;content&quot;&gt;

				    &lt;div id=&quot;text1&quot;&gt;
				    xxxxxx
				    &lt;/div&gt;
				&lt;/div&gt;
				&lt;div id=&quot;scroll&quot;&gt;
				&lt;div id=&quot;scroll_bar&quot;&gt;&lt;/div&gt;
				&lt;/div&gt;
				&lt;/div&gt;


				js:
				var TextC =  oText1.offsetHeight;
				if( TextC &gt; 398){
				oScr_B.style.display = &#x27;block&#x27;;
				oScr_B.style.height = 398 - (TextC-398)/5 +&#x27;px&#x27;;
				}  else if( TextC &lt;= 398 ){
				oScr_B.style.height = 398 + &#x27;px&#x27;;
				oScr_B.style.display = &#x27;none&#x27;;
				}
				var MaxTop = oScroll.offsetHeight - oScr_B.offsetHeight;
				oScr_B.onmousedown = function( ev ){
				var ev = ev || event;
				var disY = ev.clientY - this.offsetTop;
				document.onmousemove = function( ev ){
				var ev = ev || event;
				var T = ev.clientY - disY;
				if( T &lt; 0 ){
				    T = 0;
				} else if( T &gt; MaxTop ) {
				    T = MaxTop;
				}
				oScr_B.style.top = T + &#x27;px&#x27;;
				var Scale = T / MaxTop;
				oText1.style.top = ( oCon.offsetHeight - oText1.offsetHeight  )*Scale + &#x27;px&#x27;;
				}
				document.onmouseup = function(){
				document.onmousemove = document.onmouseup = null;
				}
				return false;
				}


				41.onmousewheel、event.wheelDeta、
				/*
				鼠标滚轮事件

				鼠标放在div上，当滚轮向上滚动的时候，height变小，反之变大。

				*/
				/*
				    ie/chrome:  onmousewheel
				    ff: 没有这个； 用的是另外一个：DOMMouseScroll;  而且，一定要用这种方式：addEventListener来绑定事件。

				    event.wheelDeta
				        向上滚：120
				        向下滚：-120
				        火狐里是没有这个属性的
				        火狐里用的是event.detail
				        上： -3
				        下: 3

				        这样子写在ff下可以弹出来，但是在ie8以下，不支持，因为ie8以下的方法是attachEvent， 来一个判断。

				*/
				window.onload = function(){

				var oDiv = document.getElementById(&#x27;div1&#x27;);


				oDiv.onmousewheel = fn;  //  google ie  绑定
				if( oDiv.addEventListener ){
				oDiv.addEventListener(&#x27;DOMMousescroll&#x27;,fn,false); // 火狐下绑定
				}


				function fn( ev ){
				var ev = ev || event;
				var b = true;  //中间变量
				if( ev.wheelDelta ){//如果有wheelDelta，说明是ie和chorme浏览器，如果它值大于0，让它等于true，小于0，false;
				b = ev.wheelDelta &gt; 0 ? true : false;
				} else {  // 火狐下，小于0，true,否则false
				b = ev.detail &lt; 0 ? true : false;
				}  // 结果是： 向上为true； 向下为false;

				if( b ){  //如果true, 也就是向上滚动
				this.style.height = this.offsetHeight - 10 + &#x27;px&#x27;;
				} else {
				this.style.height = this.offsetHeight + 10 + &#x27;px&#x27;;
				}

				if( ev.preventDefault ){  // 阻止addEvent的自发
				ev.preventDefault();
				}
				return false;
				}



				42.回放  top left
				var get = { X:[],Y:[] };
				oImg.onmousedown = function( ev ){
				var ev = ev || event;
				var disX, disY;
				disX = ev.clientX - this.offsetLeft;
				disY = ev.clientY - this.offsetTop;
				get.X.push( oImg.offsetLeft );
				get.Y.push( oImg.offsetTop );


				document.onmousemove = function( ev ){  //document!!!!!

				  var ev = ev || event;
				  if( ev.clientX - disX &lt; 0 ){
				    oImg.style.left = 0+&#x27;px&#x27;;
				  } else if ( ev.clientX - disX &gt; MaxLeft ){
				      oImg.style.left = MaxLeft;
				  } else if( ev.clientY - disY &lt; 0 ){
				      oImg.style.top = 0 + &#x27;px&#x27;;
				  } else if ( ev.clientY - disY &gt; MaxTop ){
				      oImg.style.top = MaxTop;
				  } else{
				  oImg.style.left = ev.clientX - disX + &#x27;px&#x27;;
				  oImg.style.top =  ev.clientY - disY + &#x27;px&#x27;;
				  }
				  clearInterval( timer );
				  timer = setInterval(function(){
				      get.X.push( oImg.offsetLeft );
				      get.Y.push( oImg.offsetTop );
				  },20); //每过20毫秒，就把oImg的offsetleft/top扔到数组里去

				}
				document.onmouseup = function (){
				clearInterval( timer )
				document.onmousemove = document.onmouseup = null;
				}
				return false;
				}



				oBtn.onclick = function(){
				clearInterval( timer1 );
				timer1 = setInterval( function(){
				oImg.style.left = get.X.pop() + &#x27;px&#x27;;
				oImg.style.top =  get.Y.pop() + &#x27;px&#x27;;
				if( get.X.length == 0 ){
				    clearInterval( timer1 );
				}
				},50);

				timer2 = setInterval(function(){
				oImg.src = arrPic[num];
				num++;
				num%= 5;
				if( get.X.length == 0 ){
				    clearInterval( timer2 );
				}
				},1000)
				}


				43.九宫格排除 碰撞

				function drag( obj ){
				obj.onmousedown = function( ev ){
				var ev = ev || event;
				var disX = ev.clientX - this.offsetLeft;
				var disY = ev.clientY - this.offsetTop;
				if( obj.setCapture ){
				    obj.setCapture();
				}
				document.onmousemove = function(){
				    var ev = ev || event;
				    var L = ev.clientX - disX;
				    var T = ev.clientY - disY;
				/////////////////////////////////////////////
				    var L1 = L;
				    var R1 = L1 + obj.offsetWidth;
				    var T1 = T;
				    var B1 = T1 + obj.offsetHeight;

				    var L2 = oImg.offsetLeft; // img是固定的，所以直接这样。
				    var R2 = L2 + oImg.offsetWidth;
				    var T2 = oImg.offsetTop;
				    var B2 = T2 + oImg.offsetHeight;

				    if( R1 &lt; L2 || L1 &gt; R2 || B1 &lt; T2 || T1 &gt; B2){
				        oImg.src = &#x27;logo_mi.png&#x27;;
				    } else {
				        oImg.src = &#x27;logo_mi2.png&#x27;;
				    }
				/////////////////////////////////////////////
				    obj.style.left = L + &#x27;px&#x27;;
				    obj.style.top = T + &#x27;px&#x27;;
				}
				document.onmouseup = function(){

				    document.onmousemove = document.onmouseup = null;
				    if( obj.releaseCapture ){
				        obj.releaseCapture();
				    }
				}
				return false;
				}
				}


				44.全局捕获
				var aInput = document.getElementsByTagName(&#x27;input&#x27;);

				aInput[0].setCapture(); // 给aInput[0]加这个，会出现，无论点那里都出现 ---1； 这个叫做设置全局捕获。 当我们给一个元素设置全局捕获以后，这个元素就会监听后续发生的所有事件。当有事件发生的时候，就会被当前设置了全局捕获的元素所触发。
				/*
				它有兼容性问题：
				IE 下：有，并且有效果
				ff: 有， 但是没有效果
				chrome： 没有
				*/
				aInput[0].onclick = function(){

				alert(1);
				}
				aInput[1].onclick = function(){

				alert(2);
				}




				45.拖拽时，如果文字或者img,被选中的状态。怎么处理：如果页面中有蚊子被选中，会触发浏览器默认拖拽文字的效果。
				oDiv.onmousedown = function( ev ){
				var ev = ev || event;
				var disX = ev.clientX - this.offsetLeft;
				var disY = ev.clientY - this.offsetTop;
				/*if( oDiv.setCapture ){
				        oDiv.setCapture;
				    }*/

				document.onmousemove = function( ev ){
				    var ev = ev || event;
				    oDiv.style.left = ev.clientX - disX + &#x27;px&#x27;;
				    oDiv.style.top = ev.clientY - disY + &#x27;px&#x27;;

				    document.onmouseup = function(){

				    document.onmousemove = document.onmouseup = null;
				        /*if( oDiv.releaseCapture ){
				            oDiv.releaseCapture;
				        }*/
				    }
				}

				return false;//
				}


				/*
				拖拽的问题：
				    如果有文字被选中，拖拽的时候会产生问题。
				    原因：当鼠标按下的时候，如果页面中有蚊子被选中，会触发浏览器默认拖拽文字的效果。 它的效果实现的过程也类似我们拖动div的实现过程。 这两个发生了冲突。我们阻止它。他是mousedown时发生的，因此在这里阻止。标准下可以这样得到解决，但是非标准的ie8以下的浏览器呢？怎么解决？
				    用全局捕获解决： setCapture()
				    用它要进行判断，有兼容性问题。

				    这哥们会监听，一旦发现有事件，就把事件抢过来，触发自己对应的函数。
				    我们可以应用在这里：
				    对于oDiv,当鼠标down下去的时候，给它来个：
				    if( oDiv.setCapture ){
				        oDiv.setCapture();
				    }
				    这样，文字就不会跑了，因为压根就没有事件给到它
				    但是接下来，当我up下鼠标后，再次进行操作是，它还是全局捕获，无论点哪里都一样可以操作div。因此我们应该在up时，甩开它。
				    down ---- setCapture  -----un
				    在它们之间有效果就可以了。

				    up的时候，释放掉它：

				    if( oDiv.releaseCapture ){
				        oDiv.releaseCapture;
				    }
				    注意： 图片也会这样，自发行为。同样也可以这样去处理。
				*/


				46.拖拽封装

				function drag( obj ){

				obj.onmousedown = function( ev ){
				var ev = ev || event;
				var disX = ev.clientX - this.offsetLeft;
				var disY = ev.clientY - this.offsetTop;
				if( obj.setCapture ){
				    obj.setCapture();
				}
				document.onmousemove = function(){
				    var ev = ev || event;
				    obj.style.left = ev.clientX - disX + &#x27;px&#x27;;
				    obj.style.top = ev.clientY - disY + &#x27;px&#x27;;
				}

				document.onmouseup = function(){

				    document.onmousemove = document.onmouseup = null;
				    if( obj.releaseCapture ){
				        obj.releaseCapture();
				    }
				}

				return false;//这个return false是用了阻止自发事件的行为。onmousedown这个事件，有可能隐藏着内在的自发行为。

				}
				}



				47.拖拽   拉大或者拉小宽 高  未完善版：
				oDiv.onmousedown = function( ev ){
				var ev = ev || event;

				var disW = this.offsetWidth;
				var disX = ev.clientX;
				var disL = this.offsetLeft;
				var b = &#x27;&#x27;;

				var disH = this.offsetHeight;
				var disY = ev.clientY;
				var disT = this.offsetTop;
				var a = &#x27;&#x27;;

				if( disY &lt; disT + 10 ){
				a = &#x27;top&#x27;;
				}
				if( disY &gt; disH + disT - 10 ){
				a = &#x27;bottom&#x27;;
				}


				if( disX &gt; disL + disW -10 ){
				b = &#x27;right&#x27;;
				}
				if( disX &lt; disL + 10 ){
				b = &#x27;left&#x27;;
				}

				document.onmousemove = function( ev ){
				var ev = ev || event;
				switch( b ){

				    case &#x27;left&#x27; :
				    oDiv.style.width = disW - ( ev.clientX - disX ) + &#x27;px&#x27;;
				    oDiv.style.left = disL + ( ev.clientX -disX ) + &#x27;px&#x27;;
				    break;

				    case &#x27;right&#x27;:
				    oDiv.style.width = disW + ( ev.clientX - disX ) + &#x27;px&#x27;;
				    break;
				}

				switch( a ){

				    case &#x27;top&#x27; :
				    oDiv.style.Height = disH + ( ev.clientY - disY ) + &#x27;px&#x27;;
				    oDiv.style.top = disT + ( ev.clientY -disY ) + &#x27;px&#x27;;
				    break;

				    case &#x27;bottom&#x27; :
				    oDiv.style.Height = disH + ( ev.clientY - disY ) + &#x27;px&#x27;;
				    break;
				}

				}
				document.onmouseup = function(){

				document.onmousemove = document.onmouseup = null;
				}
				}


				48.call()
				// call（） :   函数下的一个方法。
				//    第一个参数，可以改变函数执行过程中的内部this的指向.
				//         第二个参数，就是原来函数要用的传参的变量。

				function fn1(a,b) {

				alert(this);
				alert(a+b)
				fn1();  // this ----&gt;window
				fn1.call(); // 调用函数call()  this---&gt;还是window
				fn1.call(1); //  this====》1
				//    如果说，fn1()原来就有要传参的变量。写成这样：
				fn1.call(1,10,20);
				//如果 第一个值为空
				fn1.call(null,10,20); //那this指向的就是window


				//知道了call()，那么我们就可以写成这样：
				document.attachEvent(&#x27;onclick&#x27;,function(){fn1.call(document)});


				49.//如何取消一个绑定好的事件函数。
				// 有2种:
				/*
				1,普通形式的取消：
				*/
				function fn1(){
				    alert(1);
				};
				function fn2(){
				    alert(2);
				};
				//	document.onclick = fn1;
				//	document.onclick = null; //这样取消

				/*
				ie:  obj.detachEvent(事件名称，事件函数);
				标准下: obj.removeEventListener(事件名称，事件a函数，是否捕获)
				*/
				//ie:
				/*document.attachEvent(&#x27;onclick&#x27;,fn1);
				document.attachEvent(&#x27;onclick&#x27;,fn2);
				document.detachEvent(&#x27;onclick&#x27;,fn1);*/

				//标准：
				document.addEventListener(&#x27;click&#x27;,fn1,false);
				document.addEventListener(&#x27;click&#x27;,fn1,true);
				document.addEventListener(&#x27;click&#x27;,fn2,false);

				document.removeEventListener(&#x27;click&#x27;,fn1,false);


				50.键盘上下左右控制div 位置   解决停顿问题
				var oDiv = document.getElementById(&#x27;div1&#x27;);
				var left = false;
				var timer = null;
				var right = false;
				var top = false;
				var bottom = false;
				setInterval(function(){
				    if( left ){
				        oDiv.style.left = oDiv.offsetLeft - 5 + &#x27;px&#x27;;
				    } else if( right ){
				        oDiv.style.left = oDiv.offsetLeft + 5 + &#x27;px&#x27;;
				    } else if( top ){
				        oDiv.style.top = oDiv.offsetTop -5 + &#x27;px&#x27;;
				    } else if( bottom ){
				        oDiv.style.top = oDiv.offsetTop + 5 + &#x27;px&#x27;;
				    }
				},20);

				document.onkeydown = function(ev){
				    var ev = ev || event;
				    var keyCode = ev.keyCode;
				    switch( keyCode ){
				        case 37 : left = true; break;
				        case 39 : right = true; break;
				        case 38 : top = true; break;
				        case 40 : bottom = true; break;
				    }
				}

				document.onkeyup = function(ev){
				    var ev = ev || event;
				    var keyCode = ev.keyCode;
				    switch( keyCode ){
				        case 37 : left = false; break;
				        case 38 : top = false; break;
				        case 39 : right = false; break;
				        case 40 : bottom  = false; break;
				    }
				}

				}


				51.键盘事件
				/*
				onkeydown: 当键盘键按下的时候触发。
				onkeyup:当键盘按键抬起的时候触发。
				*/

				//  我想知道按下具体哪个键，对应不同的事件。这个是当前发生的这个事件的细节。因此我们需要在event对象里找属性。
				//keyCode： 这是一个属性，属于数字类型； 指的是键盘按键的指。 也就是键值。

				document.onkeydown = function(){
				//	alert(1);  //键盘按下，一直按着。

				var ev = ev || event;
				//	alert( ev.keyCode );  //这样能找到每一个你想知道的某个键对应的keyCode;

				};

				/*
				ctrlKey, shiftKey,altKey  布尔值
				当一个事件发生的时候，如果ctrl ||  shift  || alt  是按下状态的， 那么会返回true; 否则会返回false;
				注意，没有说一定是对应键盘事件。

				*/

				document.onclick = function( ev ){
				var ev = ev || event;
				alert( ev.ctrlKey );
				}
				// 当document被点击的时候，返回ev.ctrlKey；要么是true;要么是false;


				52.焦点：
				/*
				焦点：
				页面有多个Input元素，text,当我点，就能进到里面，然后输入。JS是怎么知道
				焦点在那里的呢?
				如果一个元素，有焦点的话，就可以响应用户的输入操作。
				使浏览器能，区分用户输入的对象。
				我们可以通过一些方式给元素设置焦点。
				1，点击
				2，tab
				3,js

				不是所有元素都能接受焦点，能够响应用户操作的元素，才有焦点。
				*/


				53.			文字选择
				oBtn.onclick = function(){
				    oText.select();  // 全选了，然后ctrl+C就能完成复制。
				};


				54.   事件流  流的方向
				function fn1(){
				alert( this.id );
				}
				//  当有一个出去的事件触发了div3， div3就去执行fn1；  false ===&gt;代表出去的事件
				/*oDiv3.addEventListener( &#x27;click&#x27;,fn1,false );
				oDiv2.addEventListener( &#x27;click&#x27;,fn1,false );
				oDiv1.addEventListener( &#x27;click&#x27;,fn1,false );*/


				/*
				如果我改改为true，点击div3的时候出来结果是： div1-&gt;div2-&gt;div3;  这叫做事件捕获。
				*/
				//  如果有一个进去的事件触发了div3，div3就去h执行fn1； trur====&gt;代表进去的。


				/*oDiv1.addEventListener(&#x27;click&#x27;,fn1,true);
				oDiv2.addEventListener(&#x27;click&#x27;,fn1,true);
				oDiv3.addEventListener(&#x27;click&#x27;,fn1,true);*/


				oDiv1.addEventListener(&#x27;click&#x27;,function(){
				alert(1)
				},false);
				oDiv2.addEventListener(&#x27;click&#x27;,function(){
				alert(2)
				},true);
				oDiv3.addEventListener(&#x27;click&#x27;,function(){
				alert(3)
				},false);

				// 当点击div1时  ---&gt; 1
				//  当点击div2时 -----&gt; 2 、1
				//  当点击div3时  ----&gt; 2 、 3 、 1



				事件流-----
				事件捕获：  可以理解为事件绑定的第二种形式。
				我们要给一个元素绑定一个事件处理函数的话，有多种形式的，事件捕获就是其中的一种。

				给一个对象绑定一个事件的处理函数的第一种形式：
				        obj.onclick = fn;

				*/
				        function fn1(){
				            alert(1);
				        }
				    document.onclick = fn1;
				//第一种形式，点击文档，弹出。
				//这种形式，有一个问题：
				//如果我再加一个：
				    function fn2(){
				        alert(2);
				    }
				    document.onclick = fn2;

				    //问题： fn2第二个会覆盖前面绑定的fn1
				    //  也就是只弹出2;



				    // 就是针对同一个对象，同一个事件，做不同的事情，我有这个需求。而且不能被覆盖。应该怎么样去做？

				   /*
				    给一个对象，比方说div，它的同一个事件，比方说都是点击事件，绑定不同的函数，比方说，一个是函数弹出1，一个函数弹出0；
				    给一个元素绑定事件函数的第二种形式：
				    这种形式有兼容问题：
				    IE下： obj.attachEvent(事件名称,事件函数);
				    特点：1，没有捕获；
				         2，事件名称有on
				         3, 事件函数执行的顺序： 标准IE下--&gt;正顺序；  非标准IE下----&gt;倒序。
				         4，this指向window；



				    标准下： obj.addEventListener(事件名称，事件函数，是否捕获)；

				        特点：1，有捕获；
				             2， 没有on
				             3,  执行顺序是：正序
				             4，this 指向触发该事件的对象。



				    是否捕获：默认是false，不捕获。相当于冒泡；
				    true: 捕获； 相当于不冒泡
				    */



				    document.attachEvent(&#x27;onclick&#x27;,fn1); // 这样就是iE下的。
				    document.attachEvent(&#x27;onclick&#x27;,fn2);    //现在2个函数都能够执行，互不影响。


				document.addEventListener(&#x27;click&#x27;,fn1, false);
				document.addEventListener(&#x27;click&#x27;,fn2,false);  // 注意它是没有加on的


				//它们之间 this指向的不同的对象，这个问题怎么解决：涉及到一个方法：call();

				.attachEvent(&#x27;onclick&#x27;,function(){fn1.call(document)});

				//最后我们来一个封装：
				function bind( obj,evname,fn ){
				  if( obj.addEventListener ){
				      obj.addEventListener(evname,fn,false);
				  } else {
				       obj.attachEvent(&#x27;on&#x27;+ evname,function(){
				       fn.call( obj );
				       })
				  }
				}

				bind(document,click,fn1);


				55.事件冒泡
				/*
				事件流： 中有一个叫：事件冒泡；

				*/
				window.onload = function(){

				    var oDiv1 = document.getElementById(&#x27;div1&#x27;);
				    var oDiv2 = document.getElementById(&#x27;div2&#x27;);

				    var oDiv3 = document.getElementById(&#x27;div3&#x27;);

				    function fn1() {

				        alert(this.id);
				    }

				    oDiv1.onclick = fn1;
				    oDiv2.onclick = fn1;
				    oDiv3.onclick = fn1;
				    //  这个时候 3个都弹出来了。
				//  如果我给div3一个定位，给它个top值。
				//  div3已经弹出来了，点击它，还是弹出啊123
				//  这意味着  跟它的样式表现没有关系，  跟HTML结构有关系。


				/*
				    事件冒泡：  当一个元素接收到事件的时候，会把它接受到的所有传播给它的父级。
				    意味着，当一个元素接收到事件以后，除了能够触发当前自己以外，它还会把它接受到的事件，传播给父级。
				    父级接收到子级传播过来的事件，父级又会把它接收到的事件传播给它的父级。 就这样，一层层的传播，一直到顶部。  一直到window。   这种机制，我们叫事件冒泡机制。

				    div3被点击之后， 它接受到点击事件，同时它还会把它接受到的点击事件传递给他的父级div2......
				//     如果我把这个代码注释起来：        oDiv2.onclick = fn1;
				    那dvi1  div3弹出来。 意味着，注释掉之后，没有影响到，它传递给div3

				     通常我们说，给xxx加点击事件，其实，就是给元素添加事件处理函数。
				     oDiv1.onclick = fn1;   这句就是说： 告诉div1，如果它接收到了一个点击事件，那么它就去执行fn1；也就是我们加的不是事件，而是事件发生以后做的事情。  把这种行为称为：  事件函数绑定，就是把函数给到某个事件。让这个事件发生的时候，去执行这个函数。

				 也就是说当我们注释掉这个： oDiv2.onclick = fn1；   意味着我们只是取消了，div2点击的时候，去做的事情。并没有取消掉div2的点击。 不会影响它接受点击事件，只是没有告诉它去做的事情。
				 这样一种冒泡的机制，它默认会存在的。
				 */



				56.  下拉菜单：
				如果我想要的下拉菜单效果如下：
				        当我点击按钮的时候，下拉出来。
				        如果我点击除了按钮以外的东西，就隐藏起来。
				        这里按钮以外的东西，这是一个区域，怎么选择？ 不可能一个一个的去设置，当点击某某某的时候，怎样怎样。因此这个时候冒泡机制就起到重要的作用。 我们只需要，给他们除了按钮以外的元素，的共同父级document，一个点击事件。


				    我们现在要达到效果，只需要给 oBtn按钮  取消掉它的冒泡。而对于其他的，就利用它自带的冒泡机制。
				    怎么阻止当前事件的冒泡:
				    阻止冒泡： 当前要阻止冒泡的事件函数中调用 event.cancelBubble = true;

				    写成代码如下：
				    oBtn.onclick = function(ev){
				        var ev = ev || event;

				        ev.cancelBubble = true;

				        oDiv.style.display = &#x27;block&#x27;;
				    }
				    当去点击的时候，上面这个再也不会冒泡。


				    这个是mouseover的阻止冒泡方法

				    oBtn.onmouseover = function(ev){

				            var ev = ev || event;
				            ev.cancelBubble = true;

				    }


				57.BOM  open close
				/*
				BOM:  Browser  Object Model  浏览器对象模型

				*/
				window.onload = function(){

				var aInput = document.getElementsByTagName(&#x27;input&#x27;);
				var opener = window.open();


				/*
				open( 页面的地址,打开的方式 )
				如果url为空，默认打开一个空白页面；
				如果打开方式为空，默认为新窗口方式。
				方法：  作用： 打开一个新的窗口（页面）   window.open(); ----&gt;相当于 open();
				*/

				aInput[0].onclick = function(){

				// window.open();  //---&gt; 新窗口打开空白的页面。
				//window.open(&#x27;http://www.baidu.com&#x27;,&#x27;_self&#x27;);  //--&gt;本窗口打开百度； 返回的是新打开窗口的window对象

				opener = window.open();  //
				opener.document.body.style.background = &#x27;red&#x27;;
				}


				/*
				close()方法 关闭窗口
				*/

				aInput[1].onclick = function(){

				window.close();// 有很多兼容性问题。

				/*
				1，Firefox: 默认无法关闭
				2,Chrome： 默认直接关闭
				3，ie： 询问用户
				*/

				}

				aInput[2].onclick = function(){

				opener.close();
				/*
				可以关闭在本窗口中通过JS方法打开的新窗口
				*/
				}



				58
				//BOM 的属性：
				//  window.navigator.userAgent  --- &gt;浏览器信息
				//判断是什么浏览器
				if( window.navigator.userAgent.indexOf(&#x27;MSIE&#x27;)!= -1 ){
				alert( &#x27;我是IE&#x27; )
				} else {
				alert( &#x27;我不是IE&#x27; )
				}

				/*
				属性：	window.location:  浏览器地址信息


				*/
				//alert( window.location )
				// alert( window.location.href ) //地址栏地址

				//	alert( window.location.search )  //url？ 后面的内容

				//window.locatioin.hash  //:url #后面的内容

				59.Dom 表单操作：
				&lt;form id=&quot;form1&quot;&gt;
				&lt;input type=&quot;text&quot; value=&quot;内容&quot; name=&quot;text1&quot;/&gt;


				&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;男&quot; checked /&gt;男
				&lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;女&quot; /&gt;女


				&lt;input type=&quot;checkbox&quot; name=&quot;box1&quot; value=&quot;a&quot;  checked/&gt;a
				&lt;input type=&quot;checkbox&quot; name=&quot;box1&quot; value=&quot;b&quot; /&gt;b
				&lt;input type=&quot;checkbox&quot; name=&quot;box1&quot; value=&quot;c&quot; /&gt;c


				&lt;select name=&quot;sl1&quot;&gt;
				&lt;option value=&quot;&quot;&gt;请选择城市&lt;/option&gt;
				&lt;option value=&quot;广州&quot; &gt;广州&lt;/option&gt;
				&lt;option value=&quot;深圳&quot; selected&gt;深圳&lt;/option&gt;
				&lt;/select&gt;


				&lt;input type=&quot;button&quot; name=&quot;btn&quot; value=&quot;按钮&quot;  /&gt;
				&lt;/form&gt;

				js:
				//表单当中也有设置好了特有的方法来选择操作它们

				//一个事件 onchange
				var oForm = document.getElementById(&#x27;form1&#x27;);
				//表单中，我要获取里面的input
				//表单中，有一个很重要的属性： name
				//name有什么用？
				//表单是用来收集前端用户操作的信息，然后提交这些信息到后端。要提交数据，name属性是必不可少的。
				//可以不用id， 用name 来访问表单的东西
				oForm.text1   //  ----&gt;这样就获取了表单中的input
				alert( oForm.text1.value )  // ----&gt;内容

				//onchange: 当值发生改变的时候触发。
				//text/textarea：当光标离开的时候，如果内容有变化就触发。


				oForm.text1.onchange = function(){
				alert( this.value ); // 值改变的时候先不弹出，等你鼠标离开它的时候，弹出它的value；
				}
				//radio:  注意，如果我们要达到 “非1即0”的效果，就应该把radio他们绑定为一组，通过取相同的name属性值。比方下面的 name = &quot;sex1&quot;， 他们两个就被绑在一起了。

				//怎么选中表单中的radio:
				oForm.sex1 // ====&gt;这是一组元素
				alert( oForm.sex1[0].value )  //----&gt;男
				alert( oForm.sex1[1].value ) // ---&gt;女

				oForm.sex1[1].onchange = function(){
				alert( &#x27;变了&#x27; );
				alert( this.value );//  ----&gt;女
				//标准浏览器下，就这里例子来说，点击oForm.sex1[1]它的值发生变化，就弹出来。 有差异性的，针对标准和非标准下的差异。
				//非标准下：焦点离开的时候，如果this的值变了，就会触发。

				}

				//对于checkbox
				//一样，我给它一样的name----box1
				//
				oForm.box1[0].onchange = function(){
				alert(&#x27;第0个变了&#x27;)
				//跟radio一样的
				//标准下....
				//非标准下...
				}

				//对于select:
				//我要取得option里的“广州”或者“深圳”，如何实现？
				//alert( oForm.sl1.value ); // ----》空
				//现在我给“广州”的那个option， 加上: selected
				alert( oForm.sl1.value )  // ---&gt;弹出广州
				//这意味着什么？自己总结...
				//select也有onchange事件

				oForm.sl1.onchange = function(){
				alert( &#x27;somgthing happen~&#x27; )
				}


				//当我点击这个按钮的时候，我想知道radio是否选中了。
				oForm.btn.onclick = function(){
				//给它们其中一个加个checked,我们就利用这个
				alert( oForm.sex1[0].checked ) // --- &gt; true
				for( var i=0; i&lt;oForm.sex1.length; i++ ){ // for循环去遍历它，
				if( oForm.sex1[i].checked ){  //如果找到一个，是被checked，
				    alert(&#x27;对&#x27;+ &#x27;:&#x27; + oForm.sex1[i].value +&#x27;干点什么呗&#x27;);  //do something
				}  else {
				    alert( oForm.sex1[i].value + &#x27;落榜了！&#x27; )
				}
				}
				for( var i=0; i&lt;oForm.box1.length; i++ ){
				if( oForm.box1[i].checked ){
				    alert( oForm.box1[i].value + &#x27;YES&#x27; );
				}else{
				    alert( oForm.box1[i].value + &#x27;NO&#x27; );
				}
				}
				}


				60.
				/*
				onscroll:当滚动条滚动的时候触发// 拉滚动条、拉得越慢，获取到次数越多，数字越大； 拉得越快，数字越小。
				onresize: 当窗口大小发生改变的时候触发。
				*/
				var i = 0;
				window.onscroll = function(){

				document.title = i++;
				}

				window.onresize = function(){

				document.title = i++;

				};
				// 它们是按时间来算的。


				61.表单事件
				var oForm = document.getElementById(&#x27;form1&#x27;);
				//    onsubmit:  提交事件； 当提交表单的时候触发
				//   submit()方法： 提交表单
				oForm.onsubmit = function(){

				if( this.text1.value == &#x27;&#x27; ){
				    alert(&#x27;请输入内容&#x27;);
				    return false;
				}

				}

				//通过JS来实现提交：
				/* setTimeout(function(){
				oForm.submit();
				},1000) */

				/*
				onreset :事件  当提交表单重置的时候触发。
				*/

				oForm.onreset = function(){
				alert(&#x27;重置&#x27;)

				/*var re = confirm(&#x27;你确定要重置？&#x27;);
				if( re ){
				return true;
				} else {
				return false;
				}*/
				//上面代码简写成：

				return confirm( &#x27;你确定要重置？&#x27; );
				}


				62.表格的获得：
				&lt;table id=&quot;tab1&quot; width=&quot;100%&quot; border=&quot;1px&quot;&gt;
				&lt;thead&gt;
				&lt;tr&gt;
				    &lt;th&gt;编号&lt;/th&gt;
				    &lt;th&gt;姓名&lt;/th&gt;
				    &lt;th&gt;性别&lt;/th&gt;
				    &lt;th&gt;操作&lt;/th&gt;
				&lt;/tr&gt;
				&lt;/thead&gt;
				&lt;tbody&gt;
				&lt;tr&gt;
				&lt;td&gt;1&lt;/td&gt;
				&lt;td&gt;leo&lt;/td&gt;
				&lt;td&gt;男&lt;/td&gt;
				&lt;td&gt;&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
				&lt;td&gt;2&lt;/td&gt;
				&lt;td&gt;小美&lt;/td&gt;
				&lt;td&gt;女&lt;/td&gt;
				&lt;td&gt;&lt;a href=&quot;javascript:;&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
				&lt;/tr&gt;
				&lt;/tbody&gt;
				&lt;/table&gt;

				js:
				window.onload = function(){
				var oTab = document.getElementById(&#x27;tab1&#x27;)
				//alert( oTab.children[1].children[1].innerHTML ); //=====&gt;报错
				//写表格的时候，应该把&lt;tbody&gt;加上
				//alert( oTab.children[0].children[1].children[1].innerHTML );  //----&gt;‘小美’
				//上面的方法，不直观，
				//有个属性： tHead、tBodies、tFoot、rows、cells
				/*
				tHead  : 表格头   只有一个
				tBodies : 表格正文
				tFoot  :  表格尾   只有一个
				rows :  行
				cells  ：列
				*/
				alert( oTab.tBodies[0].row[1].cells[1].innerHTML );  //维护起来好

				}


				63. 关键字提醒：
				&lt;div id=&quot;box&quot;&gt;
				&lt;span class=&quot;explain&quot;&gt;JavaScript&lt;/span&gt;是面向web的编程语言。绝大多数现代网站都使用了&lt;span class=&quot;explain&quot;&gt;JavaScript&lt;/span&gt;,斌且所有的现代Web浏览器--基于桌面系统、游戏机、平板电脑和职能手机的浏览器--包含了JavaScript解析器。这使得JavaScript能够称得上史上使用最广泛的变成语言。JavaScript也是前端工程师必须掌握的三种技能之一：描述网页内容的&lt;span class=&quot;explain&quot;&gt;HTML&lt;/span&gt;、描述网页样式的&lt;span class=&quot;explain&quot;&gt;CSS&lt;/span&gt;以及描述网页行为的JavaScript。
				&lt;strong&gt;&lt;/strong&gt;
				&lt;/div&gt;

				js:
				var arr = [&#x27;JavaScript是一门非常强大的语言&#x27;,&#x27;JavaScript&#x27;,&#x27;HTML&#x27;,&#x27;CSS&#x27;]
				var json ={ top:[30,30,10,30],left:[4,460,670,48 ] }

				for( var i=0; i&lt;aSpan.length; i++ ){
				aSpan[i].index = i;
				var oStr = document.createElement(&#x27;strong&#x27;);
				aSpan[i].onmouseover = function(){
				    oStr.style.display = &#x27;block&#x27;;
				    oStr.innerHTML = arr[this.index];
				    oBox.appendChild( oStr );
				    oStr.style.top = json.top[this.index] +&#x27;px&#x27;;
				    oStr.style.left =json.left[this.index] + &#x27;px&#x27;;

				}

				aSpan[i].onmouseout = function(){
				        oStr.style.display = &#x27;none&#x27;;
				}

				}



				64.
				/*
				我要获得整个浏览器窗口的大小

				可视区的尺寸
				clientWidth
				clientHeight

				document.documentElemment.clientWidth;
				文档里的文档元素的宽

				document.documentElement.clientHeight;

				*/

				//  alert( document.documentElement.clientWidth ); //可以看见的宽

				//滚动距离：  就是除了可视区域外的，空隙距离，这个距离是可以滚动的。
				//	document.documentElement.scrollTop/Left;
				//	 div.scrollTop;


				document.onclick = function(){

				//alert( document.documentElement.scrollTop );
				//  alert( document.body.scrollTop );
				//解决兼容问题，我们可以写成这样：
				//  var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;

				/*
				内容高： oDiv.scrollHeight(width)
				*/
				//  alert( document.getElementById(&#x27;div1&#x27;).scrollHeight );  //   ---&gt; 210
				alert( document.body.offsetHeight );// 推荐使用这个


				65.滚动条回到顶端
				var timer = null;
				timer = setInterval(function(){
				var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
				scrollTop = scrollTop -100;
				if( scrollTop &lt; 100 ){
				    scrollTop = 0;

				    clearInterval( timer )
				}
				window.scrollTo(scrollTop,scrollTop);
				},600)


				66. offsetParent
				offsetParent  是只认有定位的父节点   有多个定位的话 选择最近的
				注意的问题：
				1，如果没有定位父级的话。默认是body； 存在一个问题，当自身也有定位的时候，在IE7一下的版本中，对应的不是body，而是HTML；  还有一种情况会影响：  如果说当前的元素的某个父级啊，有触发了layout，那么这个时候offsetParent指向的是触发的那个父级


				67.
				中括号的用在什么情景下：
				如果当前这个我要获得的属性值，的属性名是声明的变量的话，就用这个[]， 例如：
				var  name = &#x27;value&#x27;;

				oText.name //有问题
				oText[name] // 0K


				第三种：
				获取：   元素.getAttribute(&#x27;属性名称&#x27;);  //这是一个方法；也就是一个封装函数。   不是属性。 这样可以获得元素的指定属性的值。括号里是属性的名称。
				     oText.getAttribute(&#x27;id&#x27;)  --------&gt;  text1


				        元素.setAttrubute(属性名称，属性值);  给这个元素的这个属性设置属性值。

				        oText.setAttribute(&#x27;value&#x27;,&#x27;hello &#x27;);



				        元素.removeAttribute(属性名称)；  方法，移除这个元素的这个是属性。
				        oText.removeAttribute(&#x27;value&#x27;)



				对于自定义的属性：下面的abc = ’啊父级‘，怎么获得
				1，首先,用.和[]是无法获取和操作它的。
				2，getAttribute()可以做到


				&lt;img src=&quot;1.png&quot; /&gt;
				有点时候我们需要获取img 里面的属性src的值，进行一些判断，
				我们要用getAttribute()可以获得 1.png
				如果用.或者[]， 出来的是相对路径的全部内容，没用。
				最好不要拿这个值进行判断。IE7下不管怎样还是会返回相对路径



				68.父级.replaceChild( 新节点,被替换节点 )    替换子节点



				69.		 width height
				style.width :样式宽
				clientWidth: 可视宽
				offsetWidth: 占位宽

				alert( oDiv.style.width )   -----&gt;100px
				alert( oDiv.clientWidth )   =====&gt;120px   样式宽+padding值
				alert( oDiv.offsetWidth )  =====&gt; 122px  可视区宽 + 边框


				70.
				aDiv.style.cssText = &#x27;这里什么样式都可以写&#x27;;


				71.
				for( var i=0; i&lt;aLi.length; i++ ){
				aLi[i]...
				for( var i=0; i&lt;aLi[i].length; i++ ){
				aLi[i][j];   //for套for找到数组里面的数组
				}
				}
				//  比方说当遇到，多个ul 里面都有各自的li，就需要这样for套for来访问到最里面的每一个li


				72.
				判断this指向谁：
				fn1();   =====》 这样执行的，里面的this，肯定是window

				ox = fn1;   ---- &gt; 这样代表的是x
				function fn1(){
				this.style.background = &#x27;red&#x27;;
				}


				73.
				for( var i=0; i&lt;oBtn.length; i++ ){
				oBtn[i].onclick = function(){
				this.style.background = &#x27;red&#x27;;  // ===&gt; this代表oBtn；

				fn1();  //  ----&gt;调用的fn1函数里的this代表的是window
				that = this;
				fn1();   //我要用调用函数，而且我还要用this，那怎么样让this指向oBtn呢: 新建变量that, fn1()里面this改为变量that ,在外头用上this, 扔到that；
				}
				}



				74.
				当我们点击某一样元素： 1，如果只希望点一次，出现对应的效果，而后面的点击，不能起到效果这样子，我们可以这样子写：

				oBtn[2].onclick = function(){
				//1： 每次点击的时候清空所有，再生成；
				//2；来个判断：
				if( onOff ){
				xxxxxx;
				onOff = false; //这一步锁死，给予假值或进不来了。
				}
				}


				75.
				单价计算加减的问题要注意的事项：
				1，x.innerHTML =====》 找到数字，但它是字符串形式，我们给他转换一些var n = Number( x.innerHTML );  这个时候n即使数字类型的了，不管是多少。 后面随着点击事件可能会增加或减少，n++; n--；


				76.
				isNaN( str );    我也不知道str是什么，弹出它来看看，如果弹出来的是true，那它肯定不是数字；如果弹出来的是false，它有可能是数字，也有可能是字符串。

				77.判断输入内容是否是数字：
				var str = oInp.value;  // 这是从HTML取得值，那肯定是字符串。
				可以测试：alert(typeof str )  //所以如果我要判断HTML里，用户输入内容是否是数字的时候，这样的方法不靠谱，因此我们可以这样：

				if( isNaN( str ) ){
				str不是数字
				} else {
				str是数字
				}

				78.
				Number( x ) ==&gt;   x=&#x27;5&#x27;  ----&gt;5
				      x=&#x27;&#x27;  ---&gt;  0
				x=false  ---&gt; 0
				      x= true ----&gt;1


				79.
				alert( &#x27;10&#x27;&gt;9 )  -----&gt;肯定是true
				alert( &#x27;10&#x27;&lt;&#x27;8&#x27; )  -----&gt;肯定时true



				80.
				找出，不是数字的数字类型：
				for( var i=0; i&lt;arr.length; i++ ){
				if( typeof arr[i] === &#x27;number&#x27; &amp;&amp; isNaN( arr[i] ) ){
				    arrNew.push( arr[i] )	//这里取到的是：不是数字的数字类型
				}
				}

				for( var i=0; i&lt;arr.length; i++ ){
				if( typeof arr[i] === &#x27;number&#x27; &amp;&amp; !isNaN( arr[i] ) ){
				    arrNew.push( arr[i] );  //这里选到的是是数字的数字类型。
				}


				for( var i=0; i&lt;arr.length; i++ ){
				if( !NaN( parseFloat( arr[i] ) ) ){
				    arrNew.push( arr[i] ) //这里找到的是可以换成数字的
				}
				}


				一堆数据中获取最大的那个：
				var max =0;
				for( var i=0; i&lt;arr.length ){
				if( arr[i] &gt; max ){
				    max = arr[i];  //获得最大值
				}
				}

				判断输入的有没有小数：
				if( isNaN( x.value ) ) { 不是数字 }
				if( parseInt( x.value ) !== parseFloat( x.value ) ) { 您输入的有小数 }



				81. 作用域：
				var num = 0;
				function fn1()
				{
				num++;
				}
				function fn2()
				{
				num--;
				}
				fn2();
				fn1();    //这里的上下顺序一旦变了，就会影响到执行的先后。全局的变量是肯定可以通过部局来改变的，因为如果函数内没有，它就会往外面找。
				alert(num);


				//看下面的：
				function fn1()
				{
				var a = &#x27;大鸡腿&#x27;;
				}

				alert(a);//这个时候外面的a跟里面的a是没关系的，这里不能去里边找到a.也就是不能从外到里。

				//如果我想要获取函数内的值，怎么去做？
				//至少有2个方法：
				//第一个，巧妙的运用作用域的相关原则：先来个空的，var str = &#x27;&#x27;; 这个是全局的。然后进到函数里面：str = a; 改完之后，再去访问全局的变量alert(str);
				var str = &#x27;&#x27;;
				function fn1()
				{
				var a =&#x27;大鸡腿&#x27;;
				str = a;
				}
				fn1();
				alert(str);

				//第二个方法：看下面代码，我想在f3函数里得到fn2里的a值：   我们先来分析一下：fn3 fn2都是全局的函数对吧，我们把fn2调用。之后呢，我们的fn2开始预解析，解析到var a=...； 然后开始执行，把a=99999; 然后读到fn3();的时候，发现里头的仓库，没有fn3，再跑到父级大仓库来，这个时候父级的仓库有函数fn3， 所以说在函数里面是可以找到外面的函数的，也就是说可以调用fn3();好，抓住这个特点，既然里面能调用外面的函数，那我们想办法偷偷的把a弄到手带出来。我们来个传参！然后用b来接受它。    fn3跑到人家fn2屋子里去，把a偷出来了。
				function fn2()
				{
				var a = &#x27;999999&#x27;;
				fn3(a);
				}
				fn2();
				function fn3(b)
				{
				alert(b);
				}

				//////////////////////////////////////////////////////
				/*
				alert(a);
				var a = 1;
				alert(a);
				function a(){ alert(2)}
				alert(a)
				var a=3;
				alert(a);
				function a() { alert(4); }
				alert(a);
				// 上面的代码，我们来看一看，1，找东西： a = ...  ; a = function a(){alert(2)};   两个都是a这个时候怎么办，我们说有一个原则：遇到重名的，只留一个，留下谁，留下函数，拿掉未定义。  当变量和函数重名了，留下函数。 读到下面还有一个var a=3; 经过PK，还是留下函数。 再往下遇到：function a(){alert(4)};都是函数，同级别。这个时候是遵循优先级，后面的取代前面的。 所以说，预解析的结果是：仓库留的东西：function a() { alert(4); }
				//2，解读代码： 当遇到第一个alert(a)时，看仓库=》弹出函数4； 读到var a=1;这个时候遇到的是表达式，表达式是可以修改预解析的值，会改一些东西，1把函数取代。=》1；  再遇到alert(a);就是1；   遇到function a(){alert(2)},这是一个声明，不会改值。不会变化。  遇到alert(a); =&gt;1;   遇到var a=3；表达式； 仓库a=3;    遇到alert(a); =》3；   遇到 function a() { alert(4); }； 声明，不变； 遇到alert(a); =》3;
				//注意，走到最后，仓库就留下a=3; 如果我在下面写a(); 是会报错的，3不是函数。
				a();
				alert(typeof a);*/


				//作用域，这个域，之前我们说过。 至少分为2方面的走....出来了这2方面我们在来往深入一点分析： script 全局变量全局函数 域，我们也分为全局啊，局部啊这些东西。我们说在script这个东西，你在里面设的全局变量全局函数什么的，都会经过2步。一个script，就是一个域，只要它是一个域，就会进行预解析，逐行解读。我们来理解一下，如果说我们写两个script,就是两个域，由上往下写。它是一个域一个域先完成，也就是先进性第一个域的预解析，逐行解析。然后再第二个域。如果说上一个域的仓库留下一个a=1，那在下一个域里面，能起到作用吗，是可以的，也就是说仓库里还留着a=1;
				//函数的内部也是一个域。看下面的代码：
				var a =1;				//1,全局的a=...    2,a=1
				function fn1()          //1,全局的fn1=all  2,读到这里，不是表达式，不会改变值，往下走。
				{
				alert(a);			//
				var a =2;			//
				}
				fn1();					//			2，读到函数调用，实际上就是让里面的东西执行，而函数本身也是一个局部的域，这个时候又发生两件事：1，函数内预解析，找到var a=2；相当于有个小仓库，a=...；2，逐行解码:读到alert(a);=&gt;undefinded;  表达式a=2; 注意，局部的a跟外面的一点关系都没有。    这一块的读写就完了。
				alert(a);				//     2，这里会要的a是全局的，所以就是1;
				&lt;/script&gt;


				/////////////////////
				全局  部局；
				var a = 1;               //1,a = ... //2,a=1;
				function fn1(a)
				{
				alert(a);
				a=2;
				}
				fn1(a);		  //2, 一，参数a； a...；二，读代码，fn1(a)这里的a开始读起，a传参传进来了，相当于fn1(var a=1)    所以往下: alert(a) =&gt;1;   a=2;
				alert(a);      //全局的a =》1;


				82. if语句下的 声明函数，或者变量的不兼容问题：
				function fn1()
				{

				}    //函数，是作用域。

				if(i==0)
				{

				}    //if语句，不是作用域。
				for(var i=0; i&lt;a; i++)
				{

				}  //for循环，不是作用域



				//注意:alert(fn1)指的是整个函数式； alert(fn1()) 意味着调用了函数。

				//既然if不是作用域，那看下面的代码： 开始预解析的时候，可以找到var=&gt;a=...； 解码的时候，alert(a)应该是 =&gt;underfined  对吧。
				alert(a);
				if(true)
				{
				var a=1;
				}

				//如果我们在if下放一个函数fn1, 按理说，alert(fn1); 应该=&gt; function fn1(){alert(123);}  对吧。 对的，是这样的，所有浏览器都这样，除了火狐！！！！火狐什么问题呢？火狐它不能对if里面的函数进行预解析处理。所以说有兼容性问题。怎么解决，没有解决方法，只能避免：我们以后写代码的时候，不能在if语句里或者for循环里，定义var变量，或者函数啊！！！！！！把它们放到外面去，因为if本身不是作用域，所以放哪里都可以，因为你的意图是要写全局的变量或者全局的函数嘛，所以okay的。
				alert(fn1);
				if(true)
				{
				function fn1()
				{
				alert(123);
				}
				}





				83.字符串方法：
				当我要通过字符串里个别的字符，来找出，它在这个字符串中所处的位置：

				var str = &#x27;www.miaov.com/2013&#x27;;
				//查找字符串里，某个子字符的索引编号

				str.indexOf(&#x27;m&#x27;);  //找到了m，弹出索引编号
				str.indexOf(&#x27;m&#x27;,5);  //送索引编号5后面找m ，弹出找到的m的编号
				//如果弹出-1, 意味着没有找到子字符

				str.indexOf(&#x27;ww&#x27;)  //ww作为一个单位，返回第一次出现的编号 -====&gt; 0
				str.indexOf(&#x27;ww&#x27;,2) //从索引编号为2处开始找。。

				str.lastIndexOf(&#x27;妙味&#x27;,   38   );  //从后往前找
				          此值为负数-------&gt;当成0处理




				84.split  字符串---&gt;数组
				var str = &#x27;www.miaov.com&#x27;;
				var arr = str.split(&#x27;.&#x27;);  // ----&gt; [&#x27;www&#x27;,&#x27;miaov&#x27;,&#x27;com&#x27;] 变成数组,存在一个变量里。
				arr[1]

				////////////////////////////
				var str1 = &#x27;leo&#x27;;
				str1.split();  //  不放分隔符， ====&gt;  [&#x27;leo&#x27;]

				str1.split(&#x27;&#x27;)  //   ===&gt; [&#x27;l&#x27;,&#x27;e&#x27;,&#x27;o&#x27;]


				//////////////////////////////////
				var str2 = &#x27;妙味课堂&#x27;;

				str2.split(&#x27;味&#x27;);  // &#x27;妙&#x27;&#x27;课堂&#x27; -----&gt;  [妙,课堂]



				////////////////////////////////////////

				var str3 = &#x27;/www.miaov.com/&#x27;;

				str3.split(&#x27;/&#x27;);  //  [ ,www.miaov.com, ]
				str3.split(&#x27;/&#x27;).length  -----&gt; 3


				//////////////////////////////////////

				var  str4 = &#x27;2015-11-15-23-08&#x27;;
				str4.split(&#x27;-&#x27;,3) //  ------&gt;   [,2015,11,15]  留下3段


				85.字符串转成大、小写
				str.toUpperCase();  //针对字母 转成大写
				str.toLowerCase();


				86. 文本内容太长，来个 展开  收缩  利用一个方法  来切字符串：str.substring

				oA.onclick = function(){
				if( onOff ){
				oSpan.innerHTML = str.substring(0,18);
				oA.innerHTML = &#x27;&gt;&gt;展开&#x27;;
				}else{
				oSpan.innerHTML = str;
				oA.innerHTML = &#x27;&gt;&gt;收缩&#x27;;
				}
				onOff = !onOff  //点击的时候，来个取反，真假之间切



				87. 文字 一个一个 的出来的效果：


				var timer = null;   //声明变量，赋值空；0
				var n = 0;    //声明变量，赋值0
				$(&#x27;p&#x27;).onclick = function(){      //点击事件
				if($(&#x27;textA&#x27;).value == &#x27;&#x27;){        //判断：如果没内容
				alert(&#x27;请输入需要转移的文本信息！&#x27;);	//对应的指令
				}else if( $(&#x27;textA&#x27;).value !== &#x27;&#x27; ){   //如果有内容
				$(&#x27;p&#x27;).style.color = &#x27;#000&#x27;;  //点击处发生变化
				$(&#x27;right&#x27;).innerHTML = &#x27;&#x27;;   //先把右边框清空
				clearInterval(timer);   //关掉定时器
				var strN = $(&#x27;textA&#x27;).value;   //声明变量strN，里面的内容，不放在定时器内，固定的值，后面有用。
				timer = setInterval(function(){   //设置定时器
				var str = $(&#x27;textA&#x27;).value;   //重新声明一个str变量，输入的内容保存进去，每个半秒钟会重新检查一遍
				var textLength = str.length;   //输入内容这个字符串的长度，保存到变量里
				var arrText = str.split(&#x27;&#x27;);  //把输入的内容剪切第一个数组  就像这样：[及 就 就 就.....]
				var firstword = str.substring(0,1);   //从str字符串里找到开头的那个信息；
				arrText[0] = &#x27;&#x27;;  // 数组里，清掉第一个对象；
				var strRest = str.substring(1,str.length);  //从str字符串里找到除了第一个信息以外的其他信息。保存到变量里。
				var  strR = $(&#x27;right&#x27;).innerHTML;   //右边的内容，声明变量，赋值。

				$(&#x27;textA&#x27;).value = strRest;   // 除掉第一个信息以外的剩余信息，给予到value
				$(&#x27;right&#x27;).innerHTML += firstword;   // 第一个信息给予到右边的内容，并用+=，加上先前的信息。
				$(&#x27;span1&#x27;).innerHTML = strR.length +&#x27;/&#x27;+ strN.length;	//

				for(var i=0; i&lt;aDiv.length; i++){     //把所有div的背景色提前设为白色
				aDiv[i].style.backgroundColor = &#x27;#fff&#x27;;
				}

				aDiv[n].style.backgroundColor = &#x27;red&#x27;;   //当前div设为红色，利用n
				n++;    //n递增
				n%=aDiv.length;   //取模，达到的目的是：n从0-7不断循环；
				if( str == &#x27;&#x27; ){    //判断：  当.....跑到左侧框没内容时
				    clearInterval( timer );   //不用隔0.1秒又做这些事了。
				    for(var i=0; i&lt;aDiv.length; i++){   //还原div背景色
				    aDiv[i].style.backgroundColor = &#x27;#fff&#x27;;
				    }
				}
				},100)
				}
				}


				88.字符串的比较
				&#x27;莫&#x27;.CharCodeAt()  // 编码1
				&#x27;杜&#x27;.CharCodeAt()  // 编码2

				//字符串比较，比较他们的编码号。
				&#x27;莫&#x27;.CharCodeAt()  // 编码1
				&#x27;杜&#x27;.CharCodeAt()  // 编码2

				//字符串比较，比较他们的编码号，而且是头一个，后面的都不用比较了。
				// 返回的值是布尔值。

				&#x27;1000&#x27;&gt;2  //  这样的比较会直接转为数字的比较，这是true的
				&#x27;1000&#x27;&gt; &#x27;2&#x27;  //如果是这样的，就比较编号。

				var str = &#x27;妙味课堂是一只独具特色的IT培训团队&#x27;；

				str.substring(4); // =======&gt;  一只独具特色的IT培训团队
				str.substring(0,2) // ====&gt; 妙味
				//这个substring就是截取部分

				str.substring(2,0)// 这样的话====》妙味
				//这玩意，可以检测里面的2个数字，自动调整数字的位置。

				str.substring(); //截取全部，跟写个0 一样的

				str.substring(-3,2); // -3当成0处理。


				str.slice(0,2) // ====&gt; 妙味
				str.slice(2,0)  //不会自动调整位置。一个都找不着。
				str.slice(-2,3)  // -2 会从头部跑到尾部去，然后再从左往右。


				编码、 编码找字符串
				var str =&#x27;妙味课堂&#x27;;  //敲了空格也算
				str.length;
				str.charAt(0);   //找到子字符串，如果超出值，找不到是空的
				str.charCodeAt(1);  // 计算机存字符串的时候，用编码存到，出来就是编码。 如果子字符串是0-9,编码是48-57; 如果子字符串是a-z的话，编码在：97-122； A-Z ====》65-90；

				String.fromCharCode();  //小括号里放编号，出来的是字符串对应的子字符串
				String.fromCharCode(22937,22619);  //两个字符


				89. 查找、替换文字的内容：
				$(&#x27;btn&#x27;).onclick = function(){
				var str = aInp[0].value;
				var strText = $(&#x27;text&#x27;).innerHTML;
				var arr1 = strText.split(str);
				    if(str ==&#x27;&#x27;){
				        alert(&#x27;请输入要查找的内容!&#x27;)
				    } else if (strText.indexOf(str) ===-1){
				        alert(&#x27;对不起，没找到您输入的：&#x27;+str)
				    } else {
				        $(&#x27;text&#x27;).innerHTML = arr1.join(&#x27;&lt;span&gt;&#x27;+ str +&#x27;&lt;/span&gt;&#x27;);
				    }
				}


				$(&#x27;btn1&#x27;).onclick = function(){
				var str = aInp[0].value;
				var strNew = aInp[1].value;
				var arr1 = $(&#x27;text&#x27;).innerHTML.split(str)
				if(str == &#x27;&#x27; &amp;&amp; strNew == &#x27;&#x27;){
				    alert(&#x27;需要输入内容&#x27;)
				}else if( str ==&#x27;&#x27; &amp;&amp; strNew !== &#x27;&#x27; ){
				    alert(&#x27;请输入替换的内容！&#x27;)
				}else if ( str !== &#x27;&#x27; &amp;&amp; strNew == &#x27;&#x27; ){
				    $(&#x27;text&#x27;).innerHTML = arr1.join(&#x27;&#x27;)
				}else if( $(&#x27;text&#x27;).innerHTML.indexOf(str) ===-1 ){
				    alert(&#x27;对不起，没找到您输入的：&#x27;+str)
				}else{
				    $(&#x27;text&#x27;).innerHTML = arr1.join(&#x27;&lt;span&gt;&#x27;+ strNew +&#x27;&lt;/span&gt;&#x27;)
				}


				90. 检测你输入的内容是否全部符合都是数字的条件：
				aInp[1].onclick = function(){
				var val = aInp[0].value;
				if( detectNum( val ) ){
				alert( &#x27;恭喜，&#x27;+val+&#x27;全是数字&#x27; )
				}else{
				alert( &#x27;输入有误&#x27; )
				}
				}


				function detectNum( str ){
				var n=0;
				for(var i=0; i&lt;str.length; i++){
				n = str.charCodeAt(i);
				if( n&lt;48 || n&gt;57 ){  //如果这样，不是数字
				return false;   //返回false,有一个不是数字的，后面不用检查了
				}
				}
				return true;
				}




				91.字符串里的每一个字符都拿出来，写样式
				var arrColor = [&#x27;red&#x27;,&#x27;blue&#x27;,&#x27;green&#x27;,&#x27;yellow&#x27;];

				aInp[1].onclick = function(){
				var str = aInp[0].value;  // 第一个input元素的属性值，保存到变量str上
				var arr = str.split(&#x27;&#x27;);  //把字符串用分隔符，一刀切成数组；

				for( var i=0; i&lt;arr.length; i++){  //arr数组的对象，一个个拿来加入span
				arr[i] = &#x27;&lt;span style = &quot;background:&#x27;+ arrColor[i%arrColor.length] +&#x27;;&quot;&gt;&#x27;+ arr[i] +&#x27;&lt;/span&gt;&#x27;; //取模加入颜色样式
				}
				oDiv.innerHTML += arr.join(&#x27;&#x27;);  //数组转回字符串
				}


				92.鼠标移上去，变成统一的颜色，移开之后，之前的颜色，还回去：
				for(var i=0; i&lt;aLi.length; i++)  //注意，这里是li的个数
				{
				aLi[i].style.background = arr[i%arr.length];  //注意这里！！

				//这里我希望鼠标移入的时候，让li变个颜色
				aLi[i].onmouseover = function()
				{
				str = this.style.background; //先存颜色
				this.style.background = &#x27;gray&#x27;;
				}
				aLi[i].index =i;
				aLi[i].onmouseout = function() //当鼠标移开的时候，还原回它们各自的颜色,方案有很多，先说2个：第一个：如果鼠标移到第一个，再移开，应该还原红色0，第二个应该还原黄色1，第三个应该还原蓝色2. 所以我们右边要找回012；但是不能用i，我们用索引值this.index，往下走，如果不把它拉012的话，就成了0123456....而这些3456....在数组里面都没办法采到的，因此我们在来一个取模，让他们回来：this.index%arr.length;

				//第二个实现思路：  当我们把鼠标移入去之前，我们可以先记录一下，就是说先存一下：var str = &#x27;&#x27;; 当鼠标移入的时候，我们把this.style.background扔给str. 这就意味着，当我们鼠标移入当前的时候，当前的颜色已经存到了str里面了，当然了，当鼠标移开的时候，我们再把颜色还回去。 用来一个变量。
				{
				/*this.style.background = arr[this.index%arr.length];*/
				this.style.background = str;
				}
				}


				93. true false
				//真假的问题： 数据类型有：数字，数字里面有个奇葩NaN；字符串；布尔、对象（elem元素、[]数组、{}、null）
				//真：非0的数字、非空字符串、true、函数、元素（能找到的）、数组[]、{}
				//假： 0、NaN、空字符串、不能找到的元素、null、未定义


				if(2344)  //这里填的所有的数字，都满足，可以判断为真的。除了0；认为0是假的。  里面放的任何的字符串都是真的。 注意，如果填的是：&#x27;&#x27;   ==&gt;这是假的；  如果是里面有空格： &#x27; &#x27; ==&gt;是真的。     总结：这里括号填的，对象写对的情况下，都能判断出来，要么是真的，要么是假的。
				{
				alert(&#x27;真&#x27;)
				}
				else
				{
				alert(&#x27;假&#x27;);
				}



				94.简单的if判断，写的简洁一点：
				//上面的，可以写成这样：
				/* 如果 */ 12&lt;45?     /* 那么弹出这个 */alert(1)    /* 否则的话弹这个 */ :alert(0);
				12&lt;45? alert(1) :alert(0)
				alert(12&lt;45? 1 :0);   	                //还可以简化成这



				95.while循环  当我需要跳过循环中的某一个点的时候，continue
				//while循环,跟for一个样。
				var i=0;
				while(i&lt;3)
				{
				alert(i);
				i++;
				}
				for(var i=0; i&lt;3; i++)
				{
				alert(i);
				}


				for(var i=0; i&lt;6; i++)
				{
				if(i==4)
				{
				/*break;*/  //跳出。这里就跳出for循环
				continue; //跳过这一次的for赋值为4的一轮循环，直接从5开始。
				}
				alert(i)
				}



				95.  &amp;&amp;  ||  ！ 灵活运用
				//  &amp;&amp; 与   ||或   ！否
				alert(12&lt;90 &amp;&amp; 23&lt;90);  // 两个都成立才成立。 ==》true；它先判断左边的，成立则判断右边的，否则不往下判断。  ==》false;

				var a = 120&gt;90 &amp;&amp; 20;   //左边靠谱==》获取右边的值。
				alert(a);



				alert(12&lt;90 || 23&lt;90);  //左边右边只要一个靠谱就成立 ==&gt;true； 左边靠谱，它懒的去看右边的了，直接true； 如果两个都不靠谱 ==》false;

				var a= 120&lt;90 || 20;   //左边不靠谱，==&gt;照样取右边值
				alert(a);


				var c = !true;  //黑白跌倒；
				alert(c);


				var d = !200;  //!这哥们，跟着数字，数字有反面吗？没有！直接以布尔值来判断，200是真的，加了！，就是false;  所以说从这个例子看这哥们也有数字转换的功能。
				alert(d);


				96.当一组数组，我想在适当的时候，让它们随机的排列：
				var arr = [ &#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;,&#x27;g&#x27;,&#x27;h&#x27; ]
				var arrNew =  arr.sort(function(a,b){
				return Math.random() - 0.2;
				})
				alert( arrNew )


				如果我想让数组里的内容，从小到大，或者从大到小进行排列：
				var arrWidth = [&#x27;345px&#x27;,&#x27;23px&#x27;,&#x27;10px&#x27;,&#x27;1000px&#x27;]

				arrWidth.sort( function(a,b){
				return parseInt(a) - parseInt(b);  //写了一个比较函数
				} )

				alert( arrWidth );  // -----&gt; 10px  23px  345px 1000px


				97.我有几个数组，当我想把这几个数组， 组合起来，形成一个数组的时候：
				var arr1 = [1,2,3];
				var arr2 = [4,5,6];
				var arr3 = [7,8,9 ];
				var arrNew = arr2.concat( arr1,arr3 );  //
				alert(arrNew)


				98.当我要删除数组里的最后一项的时候：
				var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]
				var lastOne =  arr.pop();  ---&gt;返回的是d
				alert( arr )  ---- d 被删了


				99.当我需要添加或删除数组里的第一个的时候
				arr = [1,2,3,4,5]
				//unshift   shift都是前头玩的哥们
				arr.unshift(10)    // 前头添加10 ，返回长度
				arr.shift()  //干掉前头的，10 又被干掉了   返回


				100.for in 遍历
				//用for-in 去遍历对象的属性：
				var str = &#x27;&#x27;;
				var num = 0;  // 我想想办法看到window属性的数量
				for( var attr in document ){
				str +=num + &#x27;.&#x27; + attr + &#x27;:&#x27; + document[attr] + &#x27;&lt;br /&gt;&#x27;; //我们来看看window对象里的属性
				num++;

				//注意attr是window的属性名；  window[attr]这个是属性名的对应的属性值。

				}
				document.body.innerHTML = str;



				数组的方法
				101.数组里强大的方法 splice  删除数组里的任何位置的内容， 替换任何位置的， 添加到任何位置的
				var arr = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;]
				//splice至少有三个功能： 删除、替换、添加

				/*arr.splice(0  ,1)
				alert( arr );   //====&gt; B C D
				arr.splice(0,2)   // ===&gt;干掉2个
				//删除的返回值，是删除的对象。
				*/


				////////////////替换
				/*arr.splice(0,1,&#x27;a&#x27;)  //用a替换掉第一个A
				alert( arr )
				*/


				//////////////添加：
				arr.splice(1,0,&#x27;e&#x27;)
				alert( arr );   // =====&gt; A e B C D


				102. 一组数组，当我喜欢里面的内容倒过来的时候：
				var arr1 = [1,2,3,4,5,6]



				var arrNew = arr1.reverse(); // -----&gt; [3,2,1]
				alert(arrNew)

				103. 一个字符串，我想把字符串里的内容，倒过来：
				var str = &#x27;abcdef&#x27;  //如果想字符串倒过来
				str.split(&#x27;&#x27;);  //变成数组
				str.split(&#x27;&#x27;).reverse();  // ---&gt; 反过来的数组
				str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);  //实现


				104.数组，倒着轮流换位置 或者顺着轮流换位置
				var arr = [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;]
				//如果我希望A往后走一格，B、C往后走一格，D走到前头来。
				//拿掉D
				arr.unshift( arr.pop() );  //把D放到第一位
				alert(arr)   // D A  B C
				arr.unshift( arr.pop() );  =====&gt;把最后一位放到第一位。
				alert(arr)   // C D  A B

				////////////////////////////////////
				arr.push( arr.shift() );  //=====&gt;  B C D A
				alert( arr )
				arr.push( arr.shift() ); // =====&gt; C D A B
				alert( arr )


				104.  for循环用于数组， 而对于json， for循环是用不上的，因为json没有length属性
				而json的数据，我们是通过for in 的方式去遍历的。   对于数组而言，for in 的方式，可以用在其身上吗，可以:

				var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];  //用for in 去访问数组，是可以的。

				for( var ele in arr ){
				这里i====&gt;0、1、2 索引编号
				arr[ele] ====&gt; a、b、c
				}


				读取json：
				var json4 = { &#x27;name&#x27;:&#x27;miaov&#x27;,&#x27;age&#x27;:3,&#x27;fun&#x27;:&#x27;前端开发&#x27;; }
				用for in语句去遍历json里面的内容：
				for(var attr in json4){   //从json里找到每一个属性attr；
				json4[attr]   ====&gt; miaov  3   前端开发
				}

				/////////////////////////////////////////

				var json5 = {
				&#x27;url&#x27;: [&#x27;img/1.png&#x27;,&#x27;img/2.png&#x27;,&#x27;img/3.png&#x27;,&#x27;img/4.png&#x27;]
				&#x27;text&#x27;: [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;]
				}
				for in 里面可以嵌套for循环：
				for(var att in json5) {
				for(var i=0; i&lt;json5[attr].length; i++){
				json5[attr][i];   //这里找到的就是上面的数组里的每一个
				}
				}


				105. 当我想获得x - y 之间的随机数的时候：
				x到y之间：公式：
				Math.round( Math.random()*( y-x ) +x )



				106.需要获取时间， 从未来的某个时间点到现在这个时间点，  这个时间段：

				//现在的时间点（在变） new date获取

				// 未来的时间点（不变）

				//未来 - 当前时间 = 中间时间段
				var iNow = new Date();  //现在的时间点
				//var iNew = new Date(2015,10,11,23,59,59);//注意我选的是11月！  //未来的时间点； 括号里可以设置参数。	至少有两种参数，
				//一种是数字形式：new Date(2013,4,26,21,54,0)    2013 5月；注意，它是从零开始算的。
				//一种是字符串形式：new Date(&#x27;june 10,2013 12: 12:12&#x27;);
				var iNew = new Date(&#x27;January 16,2016 23:59:59&#x27;)
				var t = Math.floor((iNew - iNow)/1000);
				//毫秒为单位。
				alert(t)

				var str = Math.floor(t/86400)+&#x27;天&#x27;+Math.floor(t%86400/3600)+&#x27;时&#x27;+Math.floor(t%86400%3600/60)+&#x27;分&#x27;+t%60+&#x27;秒&#x27;;

				alert(str);
				Math.floor(t/86400)
				// 天
				Math.floor(t%86400/3600)
				//   时
				Math.floor(t%86400%3600/60)
				//分
				t%60
				//  秒

				107. 倒计时 呈现在 页面

				aInp[2].onclick = function(){
				iNew = new Date(aInp[0].value);
				clearInterval(timer);  //清定时器

				timer = setInterval (function(){  //注意这个定时器包的内容、范围。
				  iNow = new Date();
				  t = Math.floor((iNew - iNow)/1000);

				  if(t&gt;=0){  //注意倒计时结束的这个判断 。

				  str =  Math.floor(t/86400)+&#x27;天&#x27;+Math.floor(t%86400/3600)+&#x27;时&#x27;+Math.floor(t%86400%3600/60)+&#x27;分&#x27;+t%60+&#x27;秒&#x27;;
				  aInp[1].value = str;
				  }else{
				  clearInterval(timer);
				  }
				},1000)
				};


				108. 在页面呈现 系统时间 ：

				setInterval( fnTime,1000 )
				fnTime();

				function fnTime()
				{
				var myTime = new Date();   // myTime 数据类型： object
				//下面是数据类型都是 number
				var iYear = myTime.getFullYear();
				var iMonth  = myTime.getMonth()+1;  // 月份比较特殊，它是从0开始算的。
				var iDate = myTime.getDate();
				var iWeek = myTime.getDay();
				if( iWeek ===0 ) iWeek = &#x27;星期天&#x27;;
				if( iWeek ===1 ) iWeek = &#x27;星期一&#x27;;
				if( iWeek ===2 ) iWeek = &#x27;星期二&#x27;;
				if( iWeek ===3 ) iWeek = &#x27;星期三&#x27;;
				if( iWeek ===4 ) iWeek = &#x27;星期四&#x27;;
				if( iWeek ===5 ) iWeek = &#x27;星期五&#x27;;
				if( iWeek ===6 ) iWeek = &#x27;星期六&#x27;;
				var iHours = myTime.getHours();
				var iMin = myTime.getMinutes();
				var iSec = myTime.getSeconds();



				str = iYear+ &#x27;年&#x27;+iMonth+ &#x27;月&#x27;+iDate+&#x27;日&#x27;+iWeek+toTwo(iHours)+ &#x27;:&#x27;+toTwo(iMin)+&#x27;:&#x27;+toTwo(iSec);
				//alert( str );
				oBody.innerHTML = str
				function toTwo ( n )
				{
				return n &lt; 10 ? &#x27;0&#x27; + n : &#x27;&#x27; + n;
				}
				}



				109.形参
				fn1(1,2,3); //我要传参； ===》这种，我们叫做实参--就是实际传递的参数；
				function fn1(a,b,c){  //这里设3个变量来接受它们，a,b,c代表着1，2，3;   它们叫做形参--形式上，形式主义，它们可以不要的
				}
				function fn1(){
				// 不要形参，照样传进来，在哪里？ 引入arguments————&gt;实参的集合，但它不是数组。
				alert(arguments);//这样弹出来的是arguments这个对象，并不是我们需要的。
				alert(arguments.length);//这个时候弹出来的是3,那怎么找到里面的每一个呢
				alert(argumentgs[0]);
				alert(argumentgs[arguments.length-1])

				}


				110.ruturn +  对象
				function getId(a){
				return document.getElementById(a);
				}
				getId(&#x27;btn1&#x27;).onclick = function()
				{
				getId(&#x27;div1&#x27;).innerHTML = 123;
				}
				//这样更加节省代码

				//如果return后面跟的是未定义呢
				//其实所有的函数，自己默认给你加了return
				function fn4(){
				return;	//加不加一样
				}
				alert(fn4());


				111.return+string
				function fn1()
				{
				return x;//x是数字类型，都可以填，外面你希望弹出它的话，就是alert(fn1()); 注意，这里是函数名称加括号。
				return &#x27;miaov&#x27;;  //函数名称加括号，就是这个字符串，字符串本身是有长度的，我们来访问它的长度alert(fn1().length)
				//我们可以用这个东西去测试一下，数据类型是属于哪一种，这样：alert(typeof fn1());
				//如果return后面跟的是函数呢？写法上会有点不同：看下面的例子：

				}


				112.return+function(){}
				function fn2(){
				return function(){
				}
				}
				alert(fn2()); //就是里面的匿名函数

				//如果说return里头的函数里头有个alert(1),我想把它弹出来，应该怎么写？
				//return里边的这个函数function(){alert(1)},就是代表fn2()，那我要把它里面的alert(1)弹出来，意味着让这个函数执行起来，所以我们写成这样：fn2()();


				//我们知道，函数它是可以用来传递参数的，那如果说fn2()(10);  意味着直接传参到里面的函数里去function(a){alert（a）}; 而且外面的函数也是可以传参的

				//总结： return:返回值。 1），return一定是放在函数里面的，而且函数里面，return下一行不管写什么代码都不会执行了。 2） 函数里面return，后面的值就等于fn1()，即函数+括号； 3），所有函数默认范围值是未定义。
				//应用：很常见，我希望函数+括号，等于某些东西，或者说用某些东西来代替，可以是函数，字符串，数

				113.
				function getStyle( obj,attr ){   //所以这里设置2个变量来接受它们俩，

				if( obj.currentStyle ){
				return obj.currentStyle[attr] ; //注意这里要用中括号，不能直接粘上去
				}else{
				return getComputedStyle(obj )[attr] ;
				}

				getComputedStyle获取到底是浏览器计算后（不管在行间还是css还是js里改变过属性值，都看计算后的）的样式。


				//注意，上面的if else我们可以更换成更加简单的三木运算方式替代：

				return obj.currentStyle ?  obj.currentStyle[attr] : getComputedStyle(obj)[attr];

				114.
				传参，可以传函数的：

				/*function fn1()
				{
				alert(1);
				}
				fn1();*/
				//函数传参，首先必须要有一个函数，然后本身是不会执行的，我们需要调用 一下它，fn1()接下来我们观察，fn1()；这里有一个括号()；这个括号的作用是，向函数里面塞点东西的。比方说我们在fn1(100);写了100，然后在函数需要这样写：function fn1(var a=100){alert(1);}  其实不用写的这么麻烦：function fn1(a){alert(a)};
				/*function  fn1(a)
				{
				alert(a);
				}
				fn1(100);*/
				//上面这样的一个过程，就完成函数传参的一个过程。准确的说就是函数传递参数。
				//如果说我再塞多个参数的话，中间用小括号隔开，里面用+号连在一起，然后给另外一个参数取一个名字b：
				/*function fn1(a,b)
				{
				alert(a+b);
				}
				fn1(100,&#x27;px&#x27;);*/
				//这个括号里面到底能放什么类型的？
				//其实就是JS类型的那些数据类型：数字，字符串，布尔值，函数，对象，未定义。这些东西构成了我们传递的参数。
				//如果我写成下面这样：它会先执行miaov，然后再执行妙维课堂。另外，括号里的参数属于字符串，我们说字符串里面的内容可以提取出来:a.charAt(2);
				/*fn2(&#x27;miaov&#x27;);
				fn2(&#x27;妙维课堂&#x27;);
				function fn2(a)
				{
				alert(a.charAt(2));
				}
				*/
				//所有的数据类型放进来都okay的，只是函数和对象的时候，我们需要理解好：如果放函数，分匿名的和有名的函数。若放匿名函数如下：也需要一个代号像上面的a一样，去代替加进来的函数，我们就取为fn把。那我要它执行起来，故里面自然应该是这样的：fn(); 倘若你要搞的麻烦一点，在fn();里再加一个值100;而fn()；代表的是什么，就是外面的函数function(){alert(1)},而100就是函数里头的那个括号，这个括号又需要去一个代号a，然后里面的事件alert(a)；这样玩的话，就弹出100；
				/*function fn3(fn)
				{
				fn(100);
				};
				fn3(function(a){alert(a)});*/

				//若，传递的是一个有名字的参数呢：这个就是名字为fn4的参数：function fn5(){alert(5);}   当我加进来的时候，在括号里填的函数的名，不要带有括号，不然会执行fn4(fn5); 如果要执行，同样，给它一个代号fn，然后执行fn();
				/*function fn4(fn)
				{
				fn();
				}
				function fn5(){alert(5)};
				fn4(fn5);*/

				//接下来是对象，很多东西都是对象，比如说是window，document还有各种div啊图片啊按钮啊等..还有像数组，空等等。。。  如果执行对象会如何？比方说传递window,document进来。然后各自取代号，然后再里头我们可以这样:w.onload=function(){xxx}; 代码如下：
				function fn6(w,d)
				{
				w.onload = function()
				{
				d.body.innerHTML = 123;
				}
				};
				fn6(window,document);


				115.isNaN
				//isNaN:  这个意思就是，不是数字。
				//这是一个方法，它用来判断某些值是不是数字的。但是这哥们有个脾气，它见到了数字，就烦，给数字一个false;比方说给它：alert(isNaN(250));=&gt;false;  如果你给它一个字符串或者函数神马的，它都爱。所以说我们需要判断某些值是不是数字的时候，我们可以派它上场，如果是数字，它就会给个false；  如果说给它一个字符串，里面包着数字，这货遇到这种情况下拿不准，不知道是数字还是不是数字，于是乎就叫它哥们Number帮忙，让Number来判断，如果Number判断出是数字，它就讨厌，如果不是数字它才喜欢。但是这货最终给这个带数字的字符串株连九族，也给了个false，打入东宫。所以说所有Number能转换为数字的值，它都不喜欢，比方说刚才的带数字的字符串，还有布尔值true为化为1，还有[]空的数组为转换为0,它都给false; 如果Number没办法转换的，就会给出一个NaN，这个时候，这货是给true的，所以说isNaN还是蛮喜欢NaN的。
				//alert( isNaN(str) );

				var str = &#x27;a&#x27;;
				alert( isNaN(str) )
				if( isNaN(str) ){
				//如果不是数字，干嘛
				}


				116.Number
				/*
				JS中的数据类型：数字，字符串，布尔，函数，对象（obj,[],{},null)，未定义；
				数据类型转换：转换的目的是什么？

				*/
				var a=&#x27;100&#x27;;  //带来引号的东西都是字符串,我希望100变成200，可不可以做下面的操作
				//alert(a+100)   ; //出来的结果是100100；因为它还是字符串，实质上这样的：&#x27;100100&#x27;。而这个并不是我们想得到的结果。所以说出于这样的需求，我们要把字符串变成数字。方法很多。

				//Number();这个Number是ECMAScript自带的东西，就像alert一样，原生带的。 放到里面： Number(a)+100;
				alert(Number(a)+100); //这样出来的就是200，已经从字符串转换为数字了。所以说，这哥们可以把看起来像数字一样的字符串转换为数字。


				var b=&#x27;&#x27;;
				alert(Number(b));//这样出来的是0，b里面加再多空格也是0.


				var a1=true;
				alert(Number(a1)); //对于布尔值呢？结果是： true是1  false是0；

				var a2=function(){alert(1)};
				alert(Number(a2)); //


				117.
				隐式类型转换：
				- * / %   这几个符号，可以让它变成数字，例如下面：
				alert(&#x27;200&#x27;-3); =&gt; 这个是187

				对于+号呢：alert(200+&#x27;3&#x27;); =》   这就把它变成字符串了。这不明显，悄悄的就已经转换了。 还有++--，  var a =&#x27;10&#x27;;
				a++;  alert(a); =&gt; 11; 转换为数字。  还有&gt;&lt;   例如：alert (&#x27;10&#x27;&gt;9); =&gt; true; 发生转换了。  如果是这样：alert(&#x27;10&#x27;&gt;&#x27;9&#x27;); =&gt;false; 字符串之间的比较，不一样，它认为10 中的1比9小，所以他认为这是false的。   还有一个：！取反；  alert(!true)； 这样是变成false； alert(!&#x27;ok&#x27;);!是这么干的，它不管右边的是啥玩意，统统认为是布尔值，然后再取反，就是false；所以=》false;    还有== ；我们看看，alert(&#x27;2&#x27;==2); =&gt;true；== 不管你什么，反正结果一样，都是2，就认为是true；两个等号==就是仅仅去判断它的值； 如果我们用三个===就是 ==的升级版，既判断它的值，又判断它们的类型。 所以我们建议用===；


				118.ajax:
				oBtn.onclick = function() {

				var xhr = null;
				if ( window.XMLHttpRequest ) {
				    xhr = new XMLHttpRequest();
				} else {
				    xhr = new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;)
				}

				xhr.open(&#x27;get&#x27;,&#x27;1.txt&#x27;,true);
				xhr.send();

				xhr.onreadystatechange = function() {

				        if ( xhr.readyState == 4 ) {
				            alert( xhr.responseText );
				        }
				}


				119.
				&lt;?php
				header(&#x27;content-type:text/html;charset=&quot;utf-8&quot;&#x27;);
				error_reporting(0);

				$username = $_GET[&#x27;username&#x27;];
				$age = $_GET[&#x27;age&#x27;];

				echo &quot;欢迎，你的名字:{$username},年龄:{$age}&quot;;


				js
				xhr.open(&#x27;get&#x27;,&#x27;2.get.php?username=&#x27;+ encodeURI(&#x27;刘伟&#x27;) +&#x27;&amp;age=32&amp;&#x27; + new Date().getTime(),true);



				/*
				    返回的往往比较复杂。比方说：更新网易新闻，后端会给新闻数据给你,我们前端要做的就是通过ajax独取出来，通过js动态显示出来 整个列表。
				php里面：
				$arr1 = array(&#x27;leo&#x27;,&#x27;momo&#x27;,&#x27;zhangsen&#x27;);
				$arr2 = array(&#x27;usename&#x27;=&gt;&#x27;leo&#x27;,&#x27;age&#x27;=&gt;&#x27;32&#x27;)

				echo json_encode( $arr1 ); //输出的格式：方法，自动输出成这样： [&quot;leo&quot;,&quot;momo&quot;,&quot;zhangsen&quot;]
				echo json_encode( $arr2 ); //输出成json这样的：[&quot;usename&quot;:&quot;leo&quot;,&quot;age&quot;:&quot;32&quot;]

				后端输出了， 前端接受到的在 xhr.responseText里面，我们说过，这哥们出来的都是string类型的。那怎么用？

				通过对象JSON来实现 转换成json对象，方便访问。
				这个对象不是所有浏览器都支持。
				IE7以下都会报错，怎么办？
				原生不支持，我们去Json官网找到 Javascript下面的语言包，下载，复制解决方案的代码。把它引进来。
				方法1，
				JSON.parse(x);  ---&gt;这个方法可以把string转换为对应的对象。
				如果说你用的本身就是json，然后进行用JSON.parse()方法转换，然后使用。 注意，这个时候，对被转换的json的要求比较高-----一定要用双引号


				方法2
				相反的方法
				JSON.stringify(x); 转换为字符串

				拿到内容后，我们根据拿到内容的类型不同，进行不同的处理。
				*/


				120.异步
				&lt;!--&lt;script src=&quot;jauery.js&quot;&gt;&lt;/script&gt;--&gt;
				&lt;script&gt;
				//$(funcion(){})  //阻塞----同步

				setTime(function(){
				alert(1);
				},2000);
				alert(2);  //它会先弹出，然后2s以后在弹出1，不会阻塞。
				//非阻塞 ---- 就是异



				121.
				/*
				        open方法：
				        参数：（跟form很相似  ）
				            1.打开方式
				            2，地址
				            3，是否异步
				                异步： 非阻塞  前面的代码不会影响后面代码的执行
				                同步： 阻塞  前面的代码会影响后面代码的执行
				                    填 true---&gt;ajax   异步非阻塞的方式
				                    填 false ---&gt; 同步阻塞

				    */
				    xhr.open(&#x27;get&#x27;,&#x27;1.txt&#x27;,true);


				122.post方式:
				xhr.open(&#x27;post&#x27;,&#x27;3.post.php&#x27;,true);
				/*
				    数据放在 send()里面作为参数传递

				*/
				xhr.setRequestHeader(&#x27;content-type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);
				xhr.send(&#x27;username=刘伟&amp;age=32&#x27;);
				// 直接这样写，是无法显示出leo 32的，原因是没有告诉后端以什么方式编码的？
				// 告诉后端当前数据的格式，让它解码。---设置请求头： xhr.setRequestHeader(&#x27;content-type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);
				//  设置请求头，告诉后端，发送的是什么类型的
				// post 没有缓存问题 因为他是从后端提交数据的，而不是从后端获取数据， 这个跟它的机制有关系。
				// 写中文，没有问题，不会乱码， 已经声明了url编码，不需要再....



				123
				1. get
				        把数据名称和数据值用 = 连接， 如果有多个的话， 那么它会把多个数据组合用&amp;进行连接，然后把数据放到url?后面传到指定页面。
				        url长度限制的原因，我们不要通过get方式传递过多的数据。
				        传递数据类型是string，其他不可以。
				        暴露在外，不太安全

				    2. post
				        理论上无限制
				        理论上比较安全
				        传递数据类型多样


				enctype : 提交的数据格式, 默认 application/x-www-form-urlencoded
				--&gt;



				124.
				/*
				返回来的数据会保存在一个属性里面---- responseText
				调用它
				得到的都是字符串
				不能直接调用，如果数据还没有请求回来，调用个屁啊。
				不要开定时器
				它还有一个属性： readyState---代表的是ajax的工作状态：
				        它一共有5个值：
				            0 初始化的时候
				            1 代表 已经调用那个send()，正在发送请求
				            2 send()方法完成  收到全部相应内容
				            3 正在解析相应内容
				            4 已经完成
				            5
				我们怎么知道readyState的值发生改变了,然后触发呢？----&gt;onreadystatechange

				当数据发生错误的时候得到的并不是我们需要的？怎么办？
				有一个属性： status:服务器的状态 http的状态码

				*/

				125.
				获取图片数据
				oBtn.onclick = function() {
				var xhr = null;
				if ( window.XMLHttpRequest ) {
				    xhr = new XMLHttpRequest();
				} else {
				    xhr = new ActiveXObject( &#x27;Microsoft.XMLHTTP&#x27; );
				}
				xhr.open(&#x27;get&#x27;,&#x27;getPic.php&#x27;,true);
				xhr.send();
				xhr.onreadystatechange = function() {
				    if ( xhr.readyState == 4 ) {

				        if ( xhr.status == 200 ) {
				                var data = JSON.parse( xhr.responseText ); //现在已经是数组啦
				                var str = &#x27;&#x27;;

				                oDiv.appendChild(oUl);

				                for( var i=0; i&lt;data.length; i++ ){
				                    str += &#x27;&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;&#x27;+ data[i].src +&#x27;&quot;/&gt;&lt;/a&gt;&lt;span&gt;&#x27;+ data[i].text +&#x27;&lt;/span&gt;&lt;/li&gt;&#x27;;

				                }
				                oUl.innerHTML = str;
				                alert(oUl.innerHTML)
				        } else {

				            alert( &#x27;出错了：&#x27; + xhr.status )
				        }
				    }
				}

				}
				var picTimer = null;
				if(picTimer){
				clearInterval(picTimer)
				}
				picTimer = setInterval(function(){
				var xhr = null;
				if ( window.XMLHttpRequest ) {
				    xhr = new XMLHttpRequest();
				} else {
				    xhr = new ActiveXObject( &#x27;Microsoft.XMLHTTP&#x27; );
				}
				xhr.open(&#x27;get&#x27;,&#x27;getPic.php&#x27;,true);
				xhr.send();
				xhr.onreadystatechange = function() {
				    if ( xhr.readyState == 4 ) {
				        if ( xhr.status == 200 ) {
				                var data = JSON.parse( xhr.responseText ); //现在已经是数组啦
				                data.sort(function(a,b){
				                return Math.random() - 0.2;
				                })
				                var str = &#x27;&#x27;;
				                for( var i=0; i&lt;data.length; i++ ){
				                    str += &#x27;&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;&#x27;+ data[i].src +&#x27;&quot;/&gt;&lt;/a&gt;&lt;span&gt;&#x27;+ data[i].text +&#x27;&lt;/span&gt;&lt;/li&gt;&#x27;;
				                }
				                oUl.innerHTML = str;
				        } else {
				            alert( &#x27;出错了：&#x27; + xhr.status )
				        }
				    }
				}
				},10000);
				}


				126
				封装后：

				oBtn.onclick = function() {

				ajax(&#x27;get&#x27;,&#x27;getPic.php&#x27;,&#x27;&#x27;,function( data ){

				    var data = JSON.parse( data );
				    var str = &#x27;&#x27;;

				    oDiv.appendChild(oUl);

				    for( var i=0; i&lt;data.length; i++ ){

				        str += &#x27;&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;&#x27;+ data[i].src +&#x27;&quot;/&gt;&lt;/a&gt;&lt;span&gt;&#x27;+ data[i].text +&#x27;&lt;/span&gt;&lt;/li&gt;&#x27;;
				    }
				    oUl.innerHTML = str;
				});
				}

				setInterval(function(){

				ajax(&#x27;get&#x27;,&#x27;getPic.php&#x27;,&#x27;&#x27;,function( data ){

				    var data = JSON.parse( data );
				    var str = &#x27;&#x27;;

				    data.sort(function(a,b){
				    return Math.random() - 0.2;

				    })

				    oDiv.appendChild(oUl);
				    for( var i=0; i&lt;data.length; i++ ){
				        str += &#x27;&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;img src=&quot;&#x27;+ data[i].src +&#x27;&quot;/&gt;&lt;/a&gt;&lt;span&gt;&#x27;+ data[i].text +&#x27;&lt;/span&gt;&lt;/li&gt;&#x27;;
				    }
				    oUl.innerHTML = str;
				});

				},10000);



				127.
				// 通过后端获得新闻数据，取到后扔到ul里
				// 啊捷克斯 做的事很简单  就是去拿数据  怎么处理数据 跟啊捷克斯无关 DOM的事。


				128.
				瀑布流的布局：
				两种形式
				    1，固定列

				        都是统一宽，不同高度。数据不是一次性加载进来的，而是分配，当满足某些条件的时候，第二批...
				        缩小浏览器，可以看到都是固定列数的。
				        这个是采用浮动结构的

				    2，动态列
				        列数会根据可视区的宽度，动态计算出来。
				        这个是采用定位结构的。



				    数据： 它的数据不是写死的加载到js里的。 而是放到后端,按需求进行加载。


				    一开始： 三个li 浮动
				    li的高度为0的， 利用ajax
				    请求数据，数据也不是一次性请求过来的。
				    比方说每一次取出10条数据
				    第一件事，填充li
				    它不是简单的for循环0 1 2对于给到数据的
				    因为这样会出现问题——————万一有一列的刚好都是高度值很大的， 那就不美观了。
				    怎么处理？
				    它会最大高度值的给到当前li当中，总高度最小的那一列，保证不会差太远。

				    结构写出来
				    注意，要用到ajax
				    文件应该新建到服务器环境下面


				    建立数据接口php
				    getPics.php
				    分析数据的格式
				    如果是字符串，直接用
				    如果是类数组、类json，通过JSON.parse()解析
				    然后访问数据


				    如果数据很复杂，看不清怎么办
				    火狐下——-查看元素--- 网络---点击相应的url-----点击响应----可以查看清楚是什么玩意。

				    初始化数据处理：
				        获取数据
				        找到最短的一列在哪里---- 封装一个函数
				                找出最小的数值在第几位
				                要循环
				                首先定义一个值 i = 0
				                定义一个v 初始化为 0对应的值
				                那它进行比较
				                它是第0个， 就从第1个开始比
				                如果第一个不小于初始化的v值，不关你的事，下一个 ++
				                如果是小于v值，嘿嘿~逮到一个，窗上它的圣衣， ++


				                function getShort(){

				                        var index = 0;
				                        var ih = aLi[index].offsetHeight;
				                        for( var i=1; i&lt; aLi.length; i++ ){
				                                if( ih &gt; aLi[i].offsetHeigh ){
				                                    index = i;
				                                    ih = aLi[i].offsetHeight;
				                                }
				                        }
				                        return index;
				                }
				                //后面使用的时候就声明一个、赋值 ： var _index = getShort();

				                ajax(&#x27;get&#x27;,&#x27;getPic.php&#x27;,&#x27;&#x27;,function( data ){

				                        for( var i=0; i&lt;data.length; i++ ){


				                        }
				                })


				        注意； 这里有一个这样的问题： 加载的速度跟不上for循环， for循环很happy快速的在循环，它才不管你图片数据有没有加载进来。 当还没有加载进来的时候，li高度为0，for循环这个瞎子就误以为那个坑还是最深的，因此一个劲的往里填啊填。

				        怎么办：
				        我们把img的宽度给死
				            oImg.style.width =  x + px;
				        高度呢？ 高度根据图片的比例设置
				            oImg.style.height = data[i].height*(x/data[i].width) + &#x27;px&#x27;;



				129. 瀑布流固定列：
				/*
				瀑布流：  往下拉的时候再加载后面的数据，如果一拉到底，完了，就没意义了。
				加载的条件是什么呢？
				条件是： 当最短的那一列的li，最低端出现在可视窗时。

				onscroll的时候
				通过最小列Li的索引位置，获得最下列li本身

				封装一个函数
				获得一个元素到页面顶部的绝对距离
				function getTop( obj ){
				    var iTop = 0;
				    while( obj ){
				         iTop += obj.offsetTop;
				         obj = obj.offsetParent;
				    }
				    return iTop;


				如果当前这个li，它到顶部的绝对距离，加上它本身的高度，小于可视的高度加上滚动的距离，那么这个li就已经在可视区了
				var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
				====&gt;
				    if( getTop( aLi[_index] ) + aLi[_index].offsetHeight &lt; document.documentElement.clientHeight + scrollTop )
				}

				注意，满足条件后，要一页一页的加载，而不是全部加载。   我们前面做的事是： 往下拉，一旦满足条件就加载一页，但是....加载是需要时间的，在加载的过程中，用户往下拉来拉去的，那就又触发几页几页的蹦出来。因此我们还有一个条件：
				满足条件下，一次性只加载一页
				怎么实现？
				建立一个开关： 下拉，满足条件，加载，关上开关，加载完，打开开关。
				 var b = true;
				 if( b ) {
				     b = false;
				     iPage++;
				     getList();
				 }
				 事情做完把门打开


				 如果数据都用完了，做什么？
				 进去以后：
				 var  data = JSON.parse( data );
				 if( !data.length ) {
				     return ;
				 }

				*/

				window.onload = function(){

				var oWarp = document.getElementById(&#x27;warp&#x27;);
				var oUl = document.getElementById(&#x27;ul1&#x27;);
				var aLi = oUl.getElementsByTagName(&#x27;li&#x27;);
				var b = true;

				getLi();
				function getLi() {
				ajax(&#x27;get&#x27;,&#x27;getPic.php&#x27;,&#x27;&#x27;,function(data){

				var data = JSON.parse( data );

				    data.sort(function(a,b){
				        return Math.random() - 0.2;
				    })
				for( var i=0; i &lt; data.length; i++ ){
				    var oDiv = document.createElement(&#x27;div&#x27;);
				    var oImg = document.createElement(&#x27;img&#x27;);
				    var oP = document.createElement(&#x27;p&#x27;);
				    var oB = document.createElement(&#x27;b&#x27;);

				    var _index = getShort();
				    alert(_index)

				    oDiv.appendChild(oImg);
				    oDiv.appendChild(oP);

				    oP.innerHTML = data[i].text;
				    oImg.src = data[i].src;
				    aLi[_index].appendChild(oDiv);
				}
				b = true;
				})
				}


				window.onscroll = function() {

				var _index = getShort();
				var sLi = aLi[_index];
				var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
				if( getTop( sLi ) + sLi.offsetHeight &lt; document.documentElement.clientHeight + scrollTop ) {
				    if( b ) {
				        b = false;
				        getLi();

				    }

				}

				}


				function getTop( obj ) {
				var iTop = 0;
				while( obj ){
				iTop += obj.offsetTop;
				obj = obj.offsetParent;
				}
				return iTop;
				}


				function getShort(){

				var index = 0;
				var ih = aLi[index].offsetHeight;
				for( var i=1; i&lt;aLi.length; i++ ) {

				        if( ih &gt; aLi[i].offsetHeight ) {
				                index = i;
				                ih = aLi[i].offsetHeight;
				        }
				}
				return index;
				}

				}


				130.
				guestbook
				存放的就是后端的相关文件，用的接口就从这里来。
				开启服务器
				打开phpMyAdmin
				进入 管理数据库
				创建数据库
				导入 文件---- miaov_guestbook_2014-01-08.sql
				执行
				会生成2个表
				一个是留言内容的表
				一个是用户的表
				准备工作完成

				打开index
				引入ajax
				创建guest_book.js
				引入


				一，关于注册的效果：
				     1，验证用户名是否可以注册；
				         需要找到调动后端的接口
				         怎么去访问？

				         当前是get方式的
				         对应文件地址

				          你要访问的文件：	http://localhost/2015-12-07/guestbook/index.php
				          访问了以后，要传什么参数过去。
				             m :  index
				             a : verifyUserName

				            输入： http://localhost/2015-12-07/guestbook/index.php?m=index&amp;a=verifyUserName
				            能访问进来，要知道需要上面2个参数。

				             还有一个参数：
				             username
				             就是要验证的用户名

				             输入		http://localhost/2015-12-07/guestbook/index.php?m=index&amp;a=verifyUserName&amp;username=leo
				             弹出 code 0
				             意味着这个用户名可以注册

				             就在地址栏进行配置，完了在看看页面返回的信息是什么，进行判断。


				             返回的数据类型：
				             一个是code : 返回的信息代码
				                0代表没有错误
				                1代表有错误

				             一个是massage： 返回的信息


				             反正就是要做不同的事，对应不同的接口

				             回到验证：
				            当用户光标离开输入框的时候，
				            通过ajax把用户名发送到后端。
				            后端验证完成以后，获取到结果。
				            显示在对应的地方

				            先获取元素
				            当它失去焦点的时候
				            接口就是： 上面的
				            加上验证名
				            接着是回调函数
				            做一步检测一步
				            学会检测：
				                浏览器里
				                检测元素
				                Network
				                XHR
				                ajax请求
				                查看，地址对不对？
				                    带的值对不对?
				                分析
				            解析：
				            注意，分析返回来的是什么？
				            如果是简单的字符串，就不用解析了，直接用
				            如果是Json那就解析成类数组，方便用



				            guestbook/index.php

				            oUsername1.onblur = function(){
				                ajax(&#x27;get&#x27;,&#x27;guestbook/index.php&#x27;,&#x27;m=index&amp;a=verifyUserName&amp;name=&#x27; + this.value,function( data ){
				                alert( data );

				                var d = JSON.parse( data );

				                overifyUserNameMsg.innerHTML = d.message;

				                if( d.code ){
				                    overifyUserNameMsg.style.color = &#x27;red&#x27;;
				                } else {
				                    overifyUserNameMsg.style.color = &#x27;green&#x27;;
				                }

				        });

				            }


				        ajax 不用看到太复杂
				        它的作用就是去某个文件当中去找某个数据，
				        然后拿到数据后，分析数据，去做希望实现的效果



				131.
				页面刷新，一进来，留言列表就应该进来：
				初始化留言列表：
				    get
				         guestbook/index.php
				            m : index
				            a : getList
				            page : 获取的留言的页码 不会一次性全部返回  要分批返回	怎么获取的 这是后端的事  我只需要知道我想获得第几页 默认1
				            n : 每页显示的条数 非必填 有默认值




				 ajax(&#x27;get&#x27;,&#x27;guestbook/index.php&#x27;,&#x27;m=index&amp;a=getList&#x27;,function( data ){

				        var d = JSON.parse( data );


				        返回来的数据：
				        data:
				                count 代表总数
				                n  每页显示多少条
				                page  当前页数
				                pages  一共多少页

				        list:
				                数组
				                用户留言的具体信息
				                    id、content、name、dateline、oppose、uid、support

				        根据需要，请求数据；
				        &#x27;m=index&amp;a=getList&amp;n=2&#x27;
				 })



				132.
				用户注册
				post
				guestbook/index.php
				m : index
				a : reg
				username : 要注册的用户名
				password : 要注册的密码

				返回
				 code  :  0  1
				 message :  具体

				先获取元素： 注册按钮 oX

				oX.onclick = function() {

				发送一个请求：
				ajax(&#x27;post&#x27;,&#x27;guestbook/index.php&#x27;,&#x27;m=index&amp;a=reg&amp;username=&#x27;+ encodeURI( oUsername1.value  )
				 +&#x27;&amp;password=&#x27; + oPassword1.value),function( data ){

				        var d = JSON.parse( data );
				        alert( d.message );
				 }
				}


				133.
				用户登陆：
				get/post
				guestbook/index.php
				    m : index
				    a :login
				    username : 要登陆的用户名
				    password :  登陆的密码

				返回值一样


				ox.onclick = function(){


				    ajax(&#x27;post&#x27;,&#x27;guestbook/index.php&#x27;,&#x27;m=index&amp;a=login&amp;username=&#x27; + encodeURI(oUsername2.value) + &#x27;&amp;password= &#x27; + oPassword2.value,function( data ){

				        var d = JSON.parse( data );
				        alert( d.message );

				        if( !d.code ){
				            如果登陆成功
				            updateUserStatus();
				        }

				    });

				}



				134.
				登陆成功以后，浏览器会保存数据：cookie
				我们可以通过JS获取cookie：
				function getCookie( key ) {

				    var arr1 = document.cookie.split(&#x27;;&#x27;)
				    for( var i=0; i&lt;arr1.length; i++ ){
				            var  arr2 = arr1[i].split(&#x27;=&#x27;);
				            if( arr2[0] == key ) {
				                return( arr2[1] );
				            }
				    }
				}

				135.
				用户退出：

				        guestbook/index.php

				            m : index
				            a : logout

				oLogout.onclick = function() {



				    ajax(&#x27;post&#x27;,&#x27;guestbook/index.php&#x27;,&#x27;m=index&amp;a=logout&#x27;,function(data){

				            var d = JSON.parse( data );
				            alert( d.message );

				            if( !d.code ){
				                退出成功：
				                 更新状态：
				                 updateUserStatus();

				            }

				    });

				}

				136.
				function updateUserStatus(){

				    var uid = getCookie(&#x27;uid&#x27;);
				    var username = getCookie(&#x27;username&#x27;);

				    if( uid ){

				        oUser.style.display = &#x27;block&#x27;;
				        oUserInfo.innerHTML = username;
				        oReg.style.display = &#x27;none&#x27;;
				        oLogin.style.display = &#x27;none&#x27;;

				    } else {

				        oUser.style.display = &#x27;none&#x27;;
				        oUserInfo.innerHTML = &#x27;&#x27;;
				        oReg.style.display = &#x27;block&#x27;;
				        OLogin.style.display = &#x27;block&#x27;;

				    }


				}

				137.
				留言：
				post
				    guestbook/index.php
				        m : index
				        a : login
				        content :  留言内容

				    返回的：
				        code:
				        data: 留言的详细信息：
				             1.cid 留言内容id；
				             2. content， 内容；
				             3.uid，  留言人的id;
				             4.username  留言人的姓名
				             5.dateline  留言的时间  秒计数
				             6.support  当前留言顶的数量
				        message:
				             7.oppose : 当前留言踩的数量


				留言提交成功，在左侧显示。
				ox.onclick = function(){

				    ajax(&#x27;post&#x27;,&#x27;guestbook/index.php&#x27;,&#x27;m=index&amp;a=send&amp;content=&#x27;+encoderURI(oCon.value),function( data ){

				            var d = JSON.parse(data);
				            alert(d.message);

				            添加当前留言到列表中
				            判断留言成功？

				            if( !d.code ){
				                一条留言就是一个dl
				                var oDl = document.createElement(&#x27;dl&#x27;);
				                var oDt = document.createElement(&#x27;dt&#x27;);
				                var oStrong = document.createElement(&#x27;strong&#x27;);

				                oStrong.innerHTML = d.data.username;  姓名

				                var oDd1 = document.createElement(&#x27;dd&#x27;);
				                oDd1.innerHTML = d.data.content;
				                var oD2 = document.createElement(&#x27;dd&#x27;);
				                var oA1 = document.createElement(&#x27;a&#x27;);

				                oA1.href = &#x27;javascript:;&#x27;;
				                oA1.innerHTML = &#x27;顶(&lt;span&gt;&#x27;+ d.data.support +&#x27;&lt;/span&gt;)&#x27;;
				                var oA2 = document.createElement(&#x27;a&#x27;);

				                oA2.href = &#x27;javascript:;&#x27;;
				                oA2.innerHTML = &#x27;踩&#x27;;

				                oDd2.appendChild( oA1 );

				                oDd2.appendChild( oA2 );


				                oDl.appendChild(oStrong)
				            }
				    });
				}


				138.
				显示更多：
				如果一开始没有数据
				我们不能显示  显示更多
				if( d.data ){
				for( var i=0; i&lt;d.data.list.length; i++ ){
				    createList(d.data.list[i]);
				}
				} else {
				if( iPage ==1 ){
				oList.innerHTML = &#x27;现在还没有留言，快来抢沙发&#x27;;
				}  这里做判断是因为，当数据全部显示完了，要隐藏  显示更多  同时不同显示沙发什么的

				oShowmore.style.display = &#x27;none&#x27;;
				}

				var iPage = 1; 新建变量iPage
				这里要更改： &#x27;m=index&amp;a=getList&amp;n=10&amp;page=&#x27; + iPage&#x27;


				oShowmore.onclick = function() {
				iPage++;
				showList();// 注意每次 显示更多的 不是同样的信息， 因此在这里，我们应该增加页数

				}

				139自由落体
				var timer = null;
				var iSpeed = 0;

				function startMove(){

				clearInterval( timer );
				timer = setInterval(function(){

				        iSpeed += 3;

				        var T = oDiv.offsetTop + iSpeed;
				        if( T &gt; document.documentElement.clientHeight - oDiv.offsetHeight ){
				                T = document.documentElement.clientHeight - oDiv.offsetHeight;
				                iSpeed *= -1;
				                iSpeed *= 0.7;
				        }

				        oDiv.style.top = T + &#x27;px&#x27;;

				},30);
				}


				140弹性窗口
				ul1----	li  li  li  li
				span ---ul2--li   li  li  li

				var timer = null;
				var timer2 = null;

				for( var i=0; i&lt; aLi.length; i++ ){

				    aLi[i].onmouseover = function(){
				        clearInterval( timer2 );
				        startMove( xxxx );

				    }

				    aLi[i].onmouseout = function(){
				        timer2 = setTimerout(function(){
				            startMove( xxxx );
				        },100)
				    }
				}

				oSpan.onmouseover = function() {

				    clearTimeout( timer );
				}

				oSpan.onmouseout = function() {

				    timer2 = setTimeout(function(){
				        startMove(xxx);
				    },100)
				}



				var iSpeed = 0;

				function startMove() {

				    clearInterval( timer );
				    timer = setInterval(function(){

				            iSpeed += ( iTarget - oSpan.offsetLeft )/6;
				            iSpeed *= 0.75;

				            if( Math.abs(iSpeed)&lt;=1 &amp;&amp; Maht.abs( iTarget - oSpan.offsetLeft )&lt;=1 ){
				                clearInterval( timer );
				                oSpan.style.left = iTarget + &#x27;px&#x27;;
				                iSpeed = 0;

				                oUl2.style.left = -iTarget + &#x27;px&#x27;;

				            } else{
				                oSpan.style.left = oSpan.offsetLeft + iSpeed + &#x27;px&#x27;;
				                oUl2.style.left = -oSpan.offsetLeft + &#x27;px&#x27;;
				            }

				    },30)
				}


				141	弹性运动
				var timer = null;
				var iSpeed = 0;
				function startMove(){
				clearInterval( timer );
				timer = setInterval(function(){

				iSpeed += (target - obj.offsetLeft)/7;
				iSpeed *= o.75;

				if( Math.abs( iSpeed ) &lt;= 1 &amp;&amp; Math( target - obj.offsetLeft )&lt;=1 ){
				        clearInterval( timer );
				        obj.style.left = target;
				        iSpeed = 0;
				} else {
				        obj.style.left = obj.offsetLeft + iSpeed + &#x27;px&#x27;;
				}

				},30)


				142，浮动广告
				var iSpeedX = 10;
				var iSpeedY = 10;
				startMove();

				function startMove(){

				setInterval( function(){

				        var L = oDiv.offsetLeft + iSpeedX;
				        var T = oDiv.offsetTop + iSpeedY;
				        if( T &gt; documentElement.clientHeight -oDiv.offsetHeight ){
				                T = documentElement.clientHeight - oDiv.offsetHeight;
				                iSpeedY *= -1;

				        } else if( T &lt; 0 ){
				                T = 0;
				                iSpeed*= -1;
				        }

				        if( L &gt; documentElement.clientWidth - oDiv.offsetWidth ){
				                L = documentElement.clientWidth - oDiv.offsetWidth;
				                iSpeedX*= -1;
				        } else if ( L &lt; 0 ){
				                L = 0;
				                iSpeedX*= -1;
				        }

				        oDiv.style.left = L + &#x27;px&#x27;;
				        oDiv.style.top = T + &#x27;px&#x27;;
				},30 )
				}



				143弹性碰撞
				var disX,disY,preX,preY;
				disY = disX = preX = preY = 0;
				var timer = null;

				oDiv.onmousedown = function( ev ){

				    var ev = ev || window.event;
				    disX = ev.clinetX - offsetLeft;
				    disY = ev.clientY - offsettop；

				    preX = ev.clientX;
				    preY = ev.clientY;

				    document.onmousemove = function( ev ){
				            var ev || window.event;
				            oDiv.style.left = ev.clientX - disX + &#x27;px&#x27;;
				            oDiv.style.top = ev.clientY - disY + &#x27;px&#x27;;

				            iSpeedX = ev.clientX - prevX;
				            iSpeedY = ev.clientY - prevY;
				            prevX = ev.clientX;
				            prevY = ev.clientY;

				    }
				    document.onmouseup = function(){
				        document.onmousemove = null;
				        document.onmouseup = null;
				        startMove();
				    }
				    return false;
				}


				function startMove(){
				    clearInterval( timer );
				    timer = setInterval(function(){

				            iSpeedY += 3;
				            var L = oDiv.offsetLeft + iSpeedX;
				            var T = oDiv.offsetTop + iSpeedY;

				            if( T &gt; document.documentElement.clientHeight - oDiv.offsetHeight ){
				                T = document.documentElement.clientHeight - oDiv.offsetHeight;
				                iSpeedY *= -1;
				                iSpeedY *= 0.75;
				                iSpeedX *= 0.75;

				            } else if(T&lt;0){
				                T = 0;
				                iSpeedY *= -1;
				                iSpeedY *= 0.75;
				            }


				            if( L &gt; document.documentElement.clientHeight - oDiv.offsetHeight ){
				                    L = document.documentElement.clientHeight - oDiv.offsetHeight;
				                    iSpeedX *= -1;
				                    iSpeedx *= 0.75;
				            } else if( L &lt; 0 ){
				                    L = 0;
				                    iSpeedX *=-1;
				                    iSpeedX *=0.75;
				            }

				            oDiv.style.left = L + &#x27;px&#x27;;
				            oDiv.style.top = T + &#x27;px&#x27;;

				    },30)
				}



				144
				图片的预加载：
				如果有大量图片
				要做幻灯片的效果
				都写在html里的话
				意味着全部加载
				影响网页打开速度

				这样：
				页面打开
				马上先加载一张图片
				用户看的时间
				去加载后面的内容

				利用Image对象


				var oImage = new Image();

				    属性：  src  ---
				        oImage.src = &#x27;xxx&#x27;;
				        这意味着 这个xxx的图片就被加载进来了
				        保存在浏览器的缓存文件里
				        意味着 直接可以看到

				    事件： onload  ： 加载完成触发
				        onerror  ： 加载失败触发

				        oImage.onload = function(){
				            alert(&#x27;加载完成&#x27;);

				            oImg.onclick = function(){
				                oImg.src = &#x27;&#x27;;
				                //这个时候，直接用。不耗费时间。
				            }
				        }


				145篮球在页面运动
				oDiv1.style.top = document.documentElement.clientHeight - oDiv1.offsetHeight + &#x27;px&#x27;;
				oDiv1.style.left = document.documentElement.clientWidth- ( Math.round( Math.random()*1000 ) ) - oDiv1.offsetWidth + &#x27;px&#x27;;

				var disX, disY, preX, preY;
				divY = disX = preX = preY = 0;
				var timer = null;

				oDiv1.onmousedown = function( ev ){
				    var ev = ev || window.event;
				    disX = ev.clientX - oDiv1.offsetLeft;
				    disY = ev.clientY - oDiv1.offsetTop;
				    prevX = ev.clientX;
				    prevY = ev.clientY;

				    document.onmousemove = function( ev ){
				            var ev = ev || window.event;
				            oDiv1.style.left = ev.clientX - disX + &#x27;px&#x27;;
				            oDiv1.style.top = ev.clientY - disY + &#x27;px&#x27;;
				            iSpeedX = ev.clientX - prevX;
				            iSpeedY = ev.clientY - prevY;
				            prevX = ev.clientX;
				            prevY = ev.clientY;
				    }
				    document.onmouseup = function() {
				            document.onmousemove = null;
				            document.onmouseup = null;
				            startMove();
				    }
				    return false;

				}


				function startMove(){

				    clearInterval( timer );
				    timer = setInterval(function(){
				            iSpeedY += 3;
				            var L = oDiv1.offsetLeft + iSpeedX;
				            var T = oDiv1.offsetTop + iSpeedY;

				            if( T &gt; document.documentElement.clientHeight - oDiv1.offsetHeight ) {
				                    T = document.documentElement.clientHeight - oDiv1.offsetHeight;
				                    iSpeedY *= -1;
				                    iSpeedY *= 0.95;
				                    iSpeedX *=0.95;

				            } else if( T &lt; 0 ) {
				                    T = 0;
				                    iSpeedY *= -1;
				                    iSpeedY *= 0.95;
				            }


				            if( L &gt; document.documentElement.clientWidth - oDiv1.offsetWidth ) {
				                    L = document.documentElement.clientWidth - oDiv1.offsetWidth;
				                    iSpeedX *= -1;
				                    iSpeedX *= 0.95;

				            } else if( L &lt; 0 ) {
				                    L = 0;
				                    iSpeedX *= -1;
				                    iSpeedX *= 0.95;
				            }

				            oDiv1.style.left = L + &#x27;px&#x27;;
				            oDiv1.style.top = T + &#x27;px&#x27;;
				        },30)
				}

				146.回到顶部
				setTop();
				function setTop() {

				var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;

				oDiv.style.top = scrollTop + document.documentElement.clientHeight - oDiv.offsetHeight + &#x27;px&#x27;;

				}
				window.onscroll = function(){

				setTop();
				if( b != 2 ){
				clearInterval(timer)
				}
				b = 3;
				}

				oDiv.onclick = function() {

				clearInterval(timer);
				var iCur = iSpeed = 0;
				timer = setInterval(function(){
				b = 2;
				iCur = document.documentElement.scrollTop || document.body.scrollTop;
				iSpeed = Math.floor((0 - iCur)/8);
				if( iCur == 0 ){
				    clearInterval( timer );
				}else{
				    document.documentElement.scrollTop = document.body.scrollTop = iCur + iSpeed;
				}

				},30);

				}


				147.弹性下拉窗口
				var timer =null;
				for( var i=0; i&lt;aDiv.length; i++ ){
				aDiv[i].onmouseover = function(){

				    startMove(this,{
				        height : 500
				    })
				}
				aDiv[i].onmouseout = function(){

				    startMove(this,{
				        height : 100
				    })
				}
				}

				function css(obj,attr){
				if( obj.currentStyle ){
				    return obj.currentStyle[attr];
				} else {
				    return getComputedStyle(obj,false)[attr];
				}
				}

				function startMove(obj,json,fn ){

				    clearInterval( obj.timer );
				    var iCur = 0;
				    var iSpeed = 0;
				    obj.timer = setInterval(function(){
				             var ionOff = true;
				             for( var attr in json ){
				                    var iTarget = json[attr];

				                    iCur = parseInt(css(obj,attr))
				                    iSpeed += (iTarget - iCur)/10;
				                    iSpeed *= 0.65;
				                    iSpeed = iSpeed&gt;0? Math.ceil(iSpeed) : Math.floor(iSpeed);

				                    if( iCur != iTarget ){
				                        ionOff = false;
				                        if( Math.abs(iSpeed) &lt;= 2 &amp;&amp; Math.abs( iTarget - parseInt(css(obj,attr))) &lt;= 2 ){
				                            obj.style[attr] = iTarget + &#x27;px&#x27;;
				                            iSpeed = 0;


				                        } else {
				                            obj.style[attr] = iCur + iSpeed + &#x27;px&#x27;;
				                        }
				                    }


				                    document.title = obj.style[attr] + &#x27;/&#x27; + iSpeed
				             }

				             if( ionOff ){
				                 clearInterval(obj.timer)
				             }

				        },30)
				}


				148，弹性窗口
				var oUl1 = document.getElementById(&#x27;ul1&#x27;);
				var oUl2 = document.getElementById(&#x27;ul2&#x27;);
				var aLi = oUl1.getElementsByTagName(&#x27;li&#x27;);
				var oSpan = document.getElementById(&#x27;span&#x27;);

				var timer = null;
				var timer2 = null;
				var iSpeed = 0;

				for( var i=0; i&lt; aLi.length; i++ ){
				aLi[i].onmouseover = function() {

				        clearTimeout( timer2 );
				        startMove( this.offsetLeft );
				}

				aLi[i].onmouseout = function() {

				        timer2 = setTimeout(function(){
				                startMove( 0 );
				            },100)
				}
				}

				oSpan.onmouseover = function(){
				clearTimeout( timer2 );
				}

				oSpan.onmouseout = function() {
				timer2 = setTimeout(function(){
				        startMove( 0 );
				},100)
				}


				function startMove( iTarget ){

				clearInterval( timer );
				timer = setInterval(function(){

				        iSpeed += ( iTarget - oSpan.offsetLeft )/8;
				        iSpeed *= 0.65;

				        if( Math.abs(iSpeed) &lt;= 1 &amp;&amp; Math.abs( iTarget - oSpan.offsetLeft )&lt;=1 ){
				                clearInterval( timer );
				                oSpan.style.left = iTarget + &#x27;px&#x27;;
				                iSpeed = 0;
				                oUl2.style.left = -iTarget + &#x27;px&#x27;;

				        } else {
				                oSpan.style.left = oSpan.offsetLeft + iSpeed + &#x27;px&#x27;;
				                oUl2.style.left = -oSpan.offsetLeft + &#x27;px&#x27;;
				        }

				},30)
				}


				149图片按需加载
				var oUl = document.getElementById(&#x27;ul1&#x27;);
				var aImg = oUl.getElementsByTagName(&#x27;img&#x27;);

				showImage();
				window.onscroll = function(){

				showImage();
				}

				function showImage(){
				var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
				for( var i=0; i&lt;aImg.length; i++ ){
				if(!aImg[i].isload &amp;&amp; getTop(aImg[i]) &lt; scrollTop + document.documentElement.clientHeight ){
				    aImg[i].src = aImg[i].getAttribute(&#x27;abc&#x27;);
				    aImg[i].isload = true;
				}
				}
				}

				function getTop (obj){ //获得绝对top
				var iTop = 0;
				if(obj){
				iTop += obj.offsetTop;
				obj = obj.offsetParent;
				}
				return iTop;
				}


				150. canvas 时钟
				toDraw();
				function toDraw(){
				var x = 200;
				var y = 200;
				var r = 150;

				oGC.clearRect(0,0,oC.width, oC.height);
				var oDate = new Date();
				var oHours = oDate.getHours();
				var oMin = oDate.getMinutes();
				var oSec = oDate.getSeconds();

				var oHoursValue = (-90 + oHours*30 + oMin/2)*Math.PI/180;
				var oMinValue = (-90 + oMin*6)*Math.PI/180;
				var oSecValue = (-90 + oSec*6)*Math.PI/180;
				oGC.beginPath();
				for(var i=0; i&lt;60; i++){
				oGC.moveTo(x,y);
				oGC.arc(x,y,r,6*i*Math.PI/180,6*(i+1)*Math.PI/180,false); //顺时针
				}
				oGC.closePath();
				oGC.stroke();

				oGC.fillStyle = &#x27;white&#x27;;
				oGC.beginPath();
				oGC.moveTo(x,y);
				oGC.arc(x,y,r*19/20,0,360*Math.PI/180,false);
				oGC.closePath();
				oGC.fill();


				oGC.lineWidth = 3;
				oGC.beginPath();
				for(var i=0; i&lt;12; i++){
				oGC.moveTo(x,y);
				oGC.arc(x,y,r,30*i*Math.PI/180,30*(i+1)*Math.PI/180,false);
				}
				oGC.closePath();
				oGC.stroke();

				oGC.fillStyle = &#x27;#fff&#x27;;
				oGC.beginPath();
				oGC.moveTo(x,y);
				oGC.arc(x,y,r*18/20,0,360*Math.PI/180,false);
				oGC.closePath();
				oGC.fill();

				oGC.lineWidth = 5;
				oGC.beginPath();
				oGC.moveTo(x,y);
				oGC.arc(x,y,r*10/20,oHoursValue,oHoursValue,false);
				oGC.closePath();
				oGC.stroke();

				oGC.lineWidth = 3;
				oGC.beginPath();
				oGC.moveTo(x,y);
				oGC.arc(x,y,r*14/20,oMinValue,oMinValue,false);
				oGC.closePath();
				oGC.stroke();


				oGC.lineWidth = 1;
				oGC.beginPath();
				oGC.moveTo(x,y);
				oGC.arc(x,y,r*18/20,oSecValue,oSecValue,false);
				oGC.closePath();
				oGC.stroke();
				};
				setInterval(toDraw,1000);

				151.
				oGC.moveTo(100,200);
				oGC.arcTo(100,100,200,100,50);
				arcTo:  5个参数；前两个是第一组坐标；  后两个是第二组坐标；最后是半径； x1,y1,x2,y2,r;   到两条线的切点为r，画圆，这段弧度，加上前面的线构成
				oGC.stroke();


				152
				贝塞尔曲线：
				oGC.moveTo(100,200);
				oGC.quadraticCurveTo(100,100,200,100);
				第一组控制点，第二组结束坐标。  控制点拉着这个弓一样。形成弧形。
				oGC.stroke();


				153.
				2个控制点的贝塞尔曲线：
				oGC.moveTo(100,200);
				oGC.bezierCurveTo(100,100,200,200,200,100);
				dx1,dy1,dx2,dy2,x1,y1
				先找到开始点，和结束点， 开始点是moveTO
				结束点是x1,y1
				2个控制点，分别是相对角的，因此会出现效果是....
				oGC.stroke();


				154.旋转的 缩放的 方块
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);

				var num = 0;
				var num2 = 0;
				var value = 1;
				setInterval(function(){
				oGC.save();
				oGC.clearRect(0,0,oC.width,oC.height);
				oGC.translate(200,200);
				num++;
				if(num2 == 100){
				value  = -1;
				}else if(num2 == 0){
				value = 1;
				}
				num2 += value;
				oGC.scale(num2*1/50,num2*1/50);
				oGC.rotate(num*Math.PI/180);
				oGC.translate(-50,-50);	// 为什么放在这里就okay
				oGC.fillRect(0,0,100,100);
				oGC.restore();
				},30);

				155.canvas插入图片：
				必须等待图片加载完，才能去操作canvas
				用图片预加载  onload 当中调：
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);
				var yImg = new Image();
				yImg.src = &quot;img/a.jpg&quot;;
				yImg.onload = function(){
				alert(&#x27;ok&#x27;);
				toDraw(this);
				}

				function toDraw(obj){
				oGC.drawImage(obj,0,0);
				};


				156.小米logo旋转
				var yImg = new Image();
				yImg.src = &#x27;img/mi.png&#x27;;
				yImg.onload = function(){
				toDraw(this);
				};
				var iNow = 0;
				function toDraw(obj){
				var oC = document.createElement(&#x27;canvas&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);
				oC.width = obj.width;
				oC.height = obj.height;
				document.body.replaceChild(oC,oImg);
				oGC.drawImage(obj,0,0);
				aInput[1].onclick = function(){

				    if(iNow == 0){
				        iNow = 3;
				    }else{
				        iNow--;
				    }
				    toChange();
				};
				aInput[0].onclick = function(){

				    if(iNow == 3){
				        iNow = 0;
				    }else{
				        iNow++;
				    }
				    toChange();
				};


				function toChange(){
				switch(iNow){
				    case 1 :
				        oC.width = obj.height;
				        oC.height = obj.width;
				        oGC.rotate(90*Math.PI/180);
				        oGC.drawImage(obj,0,-obj.height);
				    break;

				    case 2 :
				        oC.width = obj.width;
				        oC.height = obj.height;
				        oGC.rotate(180*Math.PI/180);
				        oGC.drawImage(obj,-obj.width,-obj.height);
				    break;

				    case 3 :
				        oC.width = obj.height;
				        oC.height = obj.width;
				        oGC.rotate(270*Math.PI/180);
				        oGC.drawImage(obj,-obj.width,0);
				    break;

				    case 0 :
				        oC.width = obj.width;
				        oC.height = obj.height;
				        oGC.rotate(0);
				        oGC.drawImage(obj,0,0);
				    break;
				}
				}

				}

				157.oGC.createPattern(obj,&#x27;no-repeat&#x27;);
				背景图片
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);
				var yImg = new Image();
				yImg.onload = function(){
				draw(this);
				};
				yImg.src = &#x27;img/mi.png&#x27;;
				function draw(obj){
				var oBg = oGC.createPattern(obj,&#x27;repeat&#x27;);
				oGC.fillStyle = oBg;
				oGC.fillRect(0,0,800,500);
				}
				}

				158.oGC.createLinearGradient(100,100,200,200); 100,100 -&gt; 200,200的位置有线性渐变
				window.onload = function(){
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);
				var obj = oGC.createLinearGradient(100,100,200,200);
				obj.addColorStop(0,&#x27;red&#x27;);
				obj.addColorStop(0.5,&#x27;green&#x27;);
				obj.addColorStop(1,&#x27;yellow&#x27;);
				oGC.fillStyle = obj;
				oGC.fillRect(100,100,100,100);
				}


				159.
				放射性渐变：
				createRadialGradient(x1,y1,r1,x2,y2,r2);
				从中间到四周扩散
				参数： 第一个圆的坐标和半径； 第二个圆的坐标和半径

				var oGC = oC.getContext(&#x27;2d&#x27;);
				var obj = oGC.createRadialGradient(200,200,100,200,200,150);
				//
				obj.addColorStop(0,&#x27;red&#x27;); //起始位置红色
				obj.addColorStop(0.5,&#x27;green&#x27;);//中间的地方也变色
				obj.addColorStop(1,&#x27;blue&#x27;); //终点为蓝色
				oGC.fillStyle = obj; //把线性渐变 填充到画布对象中
				oGC.fillRect(0,0,oC.width,oC.height); //画一个方块


				160.canvas  文字
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);
				oGC.font = &#x27;40px impact&#x27;;
				oGC.textBaseline = &#x27;top&#x27;;
				oGC.fillText(&#x27;Hello&#x27;,0,0);
				oGC.strokeText(&#x27;Hello&#x27;,150,150);
				}

				161.canvas  文字居中
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);
				oGC.font = &#x27;40px impact&#x27;;
				oGC.textBaseline = &#x27;top&#x27;;
				//获取文字的宽度
				var w = oGC.measureText(&#x27;Hello&#x27;).width;
				var x = (oC.width - w)/2;
				var y = (oC.height - 40)/2
				oGC.fillText(&#x27;Hello&#x27;,x,y);
				}


				162. canvas  文字阴影
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);
				oGC.font = &#x27;100px impact&#x27;;
				oGC.textBaseline = &#x27;top&#x27;;
				oGC.fillStyle = &#x27;#f60&#x27;;
				oGC.shadowOffsetX = &#x27;5&#x27;;
				oGC.shadowOffsetY = &#x27;5&#x27;;
				oGC.shadowBlur = &#x27;5&#x27;;
				oGC.shadowColor = &#x27;#333&#x27;;
				var w = oGC.measureText(&#x27;Hello world&#x27;).width;
				var x = (oC.width - w)/2;
				var y = (oC.height - 120)/2;
				oGC.fillText(&#x27;Hello World&#x27;,x,y);


				163.创建像素 添加到画布中
				window.onload = function(){
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);
				var oImg = oGC.createImageData(100,100);// w h
				for(var i=0; i&lt;oImg.width*oImg.height; i++){
				oImg.data[4*i] = -150;
				oImg.data[4*i+1] = 0;
				oImg.data[4*i+2] = 0;
				oImg.data[4*i+3] = 100; ///注意这个100
				};
				oGC.putImageData(oImg,100,100);
				}



				164、 有一组数组，我现在要从这一组数组里面，随机的获取出，另外一组10%的数组： randomArr(100,10)
				function randomArr(iAll,iNow){
				var arr = [];
				var newArr = [];
				for(var i=0;i&lt;iAll;i++){
				arr.push(i);
				}

				for(var i=0;i&lt;iNow;i++){
				newArr.push( arr.splice( Math.floor(Math.random()*arr.length) ,1) );
				}
				return newArr;
				}


				165.获取  一个对象  x y位置上的颜色值：
				function getXY(obj,x,y){ //针对一行一列进行操作
				var w = obj.width;
				var h = obj.height;
				var d = obj.data;
				var color = [];
				color[0] = d[4*(y*w+x)];
				color[1] = d[4*(y*w+x)+1];
				color[2] = d[4*(y*w+x)+2];
				color[3] = d[4*(y*w+x)+3];
				return color;
				}


				166.耗性能  点击li  分十步  像素加载进来  呈现出100%的文字效果
				for(var i=0;i&lt;aLi.length;i++){
				aLi[i].onclick = function(){
				var str = this.innerHTML;

				var h = 180;
				var timer = null;
				clearInterval(timer);
				var iNow = 0;

				oGC.clearRect(0,0,oC.width,oC.height);

				oGC.font = h + &#x27;px impact&#x27;;

				oGC.textBaseline = &#x27;top&#x27;;

				oGC.fillStyle = &#x27;red&#x27;;

				var w = oGC.measureText(str).width;

				oGC.fillText(str,(oC.width - w)/2,(oC.height - h)/2);

				var oImg = oGC.getImageData((oC.width - w)/2,(oC.height - h)/2,w,h);
				oGC.clearRect(0,0,oC.width,oC.height);

				var arr = randomArr(w*h,w*h/10);

				var newImg = oGC.createImageData(w,h);

				timer = setInterval(function(){

				    for(var i=0;i&lt;arr[iNow].length;i++){
				        newImg.data[4*arr[iNow][i]] = oImg.data[4*arr[iNow][i]];
				        newImg.data[4*arr[iNow][i]+1] = oImg.data[4*arr[iNow][i]+1];
				        newImg.data[4*arr[iNow][i]+2] = oImg.data[4*arr[iNow][i]+2];
				        newImg.data[4*arr[iNow][i]+3] = oImg.data[4*arr[iNow][i]+3];
				    }
				    oGC.putImageData(newImg,(oC.width - w)/2,(oC.height - h)/2);
				    if(iNow == 9){
				        iNow = 0;
				        clearInterval(timer);
				    }
				    else{
				        iNow++;
				    }
				},200);
				};
				}

				function randomArr(iAll,iNow){
				var arr = [];
				var allArr = [];
				for(var i=0;i&lt;iAll;i++){
				arr.push(i);
				}

				for(var j=0;j&lt;iAll/iNow;j++){

				var newArr = [];

				for(var i=0;i&lt;iNow;i++){
				    newArr.push( arr.splice( Math.floor(Math.random()*arr.length) ,1) );
				}

				allArr.push(newArr);

				}


				return allArr;
				}


				167，一个对象，x,y上，设置一个颜色值
				function setXY(obj,x,y,color){
				var w = obj.width;
				var h = obj.height;
				var d = obj.data;


				d[4*(y*w+x)] = color[0];
				d[4*(y*w+x)+1] = color[1];
				d[4*(y*w+x)+2] = color[2];
				d[4*(y*w+x)+3] = color[3];

				}


				168,改变像素值 获取像素值
				oGC.fillRect(100,100,100,100);
				var oImg = oGC.getImageData(100,100,100,100);
				for(var i=0;i&lt;oImg.width;i++){
				setXY( oImg,i,5,[0,0,0,100] );
				}

				oGC.putImageData(oImg,100,100);  //别忘了这个
				function getXY(obj,x,y){ //针对一行一列进行操作
				var w = obj.width;
				var h = obj.height;
				var d = obj.data;
				var color = [];
				color[0] = d[4*(y*w+x)];
				color[1] = d[4*(y*w+x)+1];
				color[2] = d[4*(y*w+x)+2];
				color[3] = d[4*(y*w+x)+3];
				return color;
				}

				function setXY(obj,x,y,color){
				var w = obj.width;
				var h = obj.height;
				var d = obj.data;


				d[4*(y*w+x)] = color[0];
				d[4*(y*w+x)+1] = color[1];
				d[4*(y*w+x)+2] = color[2];
				d[4*(y*w+x)+3] = color[3];

				}


				169，图片的像素，获取，设置
				var yImg = new Image();
				yImg.onload = function(){
				draw(this);
				};
				yImg.src = &#x27;2.png&#x27;;
				function draw(obj){
				oC.width = obj.width;
				oGC.drawImage(obj,0,0);
				var oImg = oGC.getImageData(0,0,obj.width,obj.height);
				var w = oImg.width;
				var h = oImg.height;
				for(var i=0;i&lt;h;i++){
				for(var j=0;j&lt;w;j++){
				    var result = [];
				    var color = getXY(oImg,j,i);
				    result[0] = 255 - color[0];
				    result[1] = 255 - color[1];
				    result[2] = 255 - color[2];
				    result[3] = 255;
				    setXY(oImg,j,i,result);
				}
				}
				oGC.putImageData(oImg,0,obj.height);
				}




				170 合成 叠加 覆盖
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);

				oGC.fillRect(0,0,100,100);
				oGC.fillStyle = &#x27;red&#x27;;
				oGC.globalAlpha = 0.5;把红色透明度设为0.5，黑色的就出来了，这样合成。
				oGC.fillRect(50,50,100,100);


				171 重合部分 露出画布底色
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);

				oGC.fillRect(0,0,100,100);
				oGC.fillStyle = &#x27;red&#x27;;
				oGC.globalCompositeOperation = &#x27;xor&#x27;;
				oGC.fillRect(50,50,100,100);

				172。
				将画布导出为图像
				toDataURL
				直接导出成图片
				alert( oC.toDataURL() )//64位的图片信息
				oImg.src = oC.toDataURL();

				火狐里直接鼠标右键就可以保存出来

				173.canvas点击事件
				var oC = document.getElementById(&#x27;c1&#x27;);
				var oGC = oC.getContext(&#x27;2d&#x27;);
				oGC.beginPath();
				oGC.arc(100,100,60,0, 360*Math.PI/180,false);
				oGC.closePath();
				oGC.fill();
				oC.onmousedown = function(ev){
				var ev = ev || window.event;
				var x = ev.clientX - oC.offsetLeft;
				var y = ev.clientY - oC.offsetTop;
				if( oGC.isPointInPath(x,y) ){
				alert(&#x27;踩中&#x27;)
				}
				}


				174.canvas点击事件  为了方便， 写出一个构造函数，  以后可以直接用：
				function Shape(x,y,r){
				this.x = x;
				this.y = y;
				this.r = r;

				oGC.beginPath();
				oGC.arc(this.x,this.y,this.r,0,360*Math.PI/180,false);
				oGC.closePath();
				oGC.fill();
				}
				Shape.prototype.reDraw = function(point){

				oGC.beginPath();
				oGC.arc(this.x,this.y,this.r,0,360*Math.PI/180,false);
				oGC.closePath();
				oGC.fill();

				if( oGC.isPointInPath(point.x,point.y) ){
				this.click();
				}
				};
				上面的就是公式一样的
				下面就直接套用它：
				var c1 = new Shape(100,100,50);
				var c2 = new Shape(200,200,50);

				oC.onmousedown = function(ev){
				var ev = ev || window.event;
				var point = {
				x : ev.clientX - oC.offsetLeft,
				y : ev.clientY - oC.offsetTop
				};

				c1.reDraw(point);
				c2.reDraw(point);
				};

				c1.click = function(){
				alert(123);
				};

				c2.click = function(){
				alert(456);
				};

				175.有一个库:js/jCanvaScript.1.5.18.min.js:

				jc.start(&#x27;c1&#x27;,true);
				jc.circle(100,100,50,&#x27;#f60&#x27;,0).click(function(){
				alert(&#x27;ok&#x27;);
				});
				jc.start(&#x27;c1&#x27;);

				176. jc 拖拽
				jc.start(&#x27;c1&#x27;,true);  //第二个参数：代表重绘的意思

				//jc.rect(100,100,50,50,&#x27;#ff0000&#x27;,1);
				jc.circle(100,100,50,&#x27;#ff0000&#x27;,1).draggable();

				jc.start(&#x27;c1&#x27;);


				177.jc  点击事件
				jc.start(&#x27;c1&#x27;,true);  //第二个参数：代表重绘的意思

				//jc.rect(100,100,50,50,&#x27;#ff0000&#x27;,1);
				jc.circle(100,100,50,&#x27;#ff0000&#x27;,1).id(&#x27;c1&#x27;);

				jc.start(&#x27;c1&#x27;);

				oInput.onclick = function(){

				jc(&#x27;#c1&#x27;).color(&#x27;#ffff00&#x27;);

				};

				178. jc  animate
				jc.start(&#x27;c1&#x27;,true);  //第二个参数：代表重绘的意思

				//jc.rect(100,100,50,50,&#x27;#ff0000&#x27;,1);
				jc.circle(100,100,50,&#x27;#ff0000&#x27;,1).id(&#x27;c1&#x27;);

				jc.start(&#x27;c1&#x27;);

				oInput.onclick = function(){

				jc(&#x27;#c1&#x27;).color(&#x27;#ffff00&#x27;).animate({x:200,y:200,radius:5},2000);

				};


				179 html5播放器 编解码器
				网站的视频加载那么快是怎么做到的
				浏览器有一个:编解码器
				原始的视频容器非常大，添加需编码，播放需解码
				音频编解码器
				AAC、MPEG-3、Ogg Vorbis
				视频编解码器
				H.264、VP8、Ogg Theora

				试想一下，一个视频，如果直接放引到网页上，不加入任何处理的话，
				意味着要花费很长很长的时间才能打开它。
				这肯定是不靠谱的。

				我们在浏览器嵌套了一个编解码器，
				大的文件内容，传过来的时候，通过编解码器，压缩，文件变小，加载完毕，播放的时候，解码。
				编解码器有很多，不同类型，有些收费有些免费的开源的
				各个公司用的不一样
				导致编解码器对应的音频视频文件不一样，因此同的文件格式，在不同的浏览器下，可能就播放不出来。


				怎么做到兼容呢？source
				&lt;video controls&gt;
				&lt;source src=&quot;a&quot;&gt;&lt;/source&gt;
				&lt;source src=&quot;b&quot;&gt;&lt;/source&gt;
				&lt;/video&gt;
				先用a的，如果浏览器能解码它这种，就解码
				不能的话，会自动用b

				180.音频：
				&lt;audio controls src=&quot;前端搜索/张学友 - 淹没.mp3&quot;&gt;
				&lt;/audio&gt;


				181.属性：
				1.controls 显示或者隐藏用户控制界面，默认是隐藏的
				autoplay  :  媒体是否自动播放
				loop  : 媒体是否循环播放
				currentTime  :  开始到播放现在所用的时间
				duration  :  媒体总时间(只读)
				volume  :   0.0-1.0的音量相对值
				muted  :   是否静音

				paused  :   媒体是否暂停(只读)
				ended   :   媒体是否播放完毕(只读)
				error   :  媒体发生错误的时候，返回错误代码 (只读)
				currentSrc  :   以字符串的形式返回媒体地址(只读)

				play()  :  媒体播放
				pause()  :  媒体暂停
				load()  :  重新加载媒体

				loadstart progress suspend emptied stalled play pause loadedmetadata loadeddata waiting playing canplay canplaythrough seeking seeked timeupdate ended ratechange durationchange volumechange

				182
				&lt;video id=&quot;v1&quot;&gt;
				&lt;source src=&quot;Intermission-Walk-in.ogv&quot;&gt;&lt;/source&gt;
				&lt;source src=&quot;Intermission-Walk-in_512kb.mp4&quot;&gt;&lt;/source&gt;
				&lt;/video&gt;
				oV.onmouseover = function(){
				this.play();
				};
				oV.onmouseout = function(){
				this.pause();
				};
				oInput.onclick = function(){
				aS[0].src = &#x27;xxxx.mp4&#x27;;
				aS[1].src = &#x27;yyyy.mp4&#x27;;
				oV.load();
				};

				183
				Video额外特性
				poster  :   视频播放前的预览图片
				width、height  :   设置视频的尺寸
				videoWidth、 videoHeight  :   视频的实际尺寸(只读)

				184.播放器与canvas结合
				oC.width = oV.videoWidth;
				oC.height = oV.videoHeight;

				setInterval(function(){

				oGC.drawImage( oV , 0 , 0 );

				},30);


				185.日期直接转换为数值
				alert( +new Date() )


				186.
				Array.prototype.slice.call(arguments);
				把类数组转为数组

				187.
				计算结果为真，取一个值，不是真，取另一个值：
				var a = 0 || 3;
				alert(a) --- 3   0 是假

				188.跳转到新页面，并且保证浏览器不会再回退
				location.replace(&quot;http://www.mi.com&quot;);


				189.用javascript打印页面
				window.print();

				190.alert()中文本换行：
				alert(&quot;x\nx&quot;);

				191.按着对应的键，返回的是true
				oList.onclick = function(ev){
				alert( event.shiftKey )
				event.altKey
				event.ctrlKey
				}

				192。获取屏幕分辨率的宽高
				window.screen.height
				window.screen.width

				193.脚本永不出错的方式： 放在前头
				window.onerror = function(m,f,l){
				return true;
				}


				194.
				字符转编码
				&quot;x&quot;.charCodeAt(0);

				编码转字符串：
				String.fromCharCode(34);


				195.把一个值转换成布尔型
				使用 ！两次：
				!!&quot;x&quot;
				!!&#x27;&#x27;
				!!&#x27;0&#x27;
				!!&#x27;1&#x27;
				!!{}

				196.判断浏览器是否支持HTML5
				!!navigator.geolocation --- true/false


				197.判断浏览器是否支持canvas
				alert( isCanvas() );
				function isCanvas(){
				return !!document.createElement(&#x27;canvas&#x27;).getContext;
				}


				198.判断IE版本：
				alert( window.navigator.appVersion )


				199.采用惰性载入的方案提高函数代码的性能
				var addEvents = (function(){
				if(document.addEventListener){
				return function(type,element,fun){
				element.addEventListener(type,fun,false);
				}
				}
				else if(document.addachEvent){
				return function(type,element,fun){
				element,addachEvent(&#x27;on&#x27;+type,fun);
				}
				}
				else{
				return function(type,element,fun){
				element[&#x27;on&#x27;+type] = fun;
				}
				}
				})();


				200.捕捉ctrl + enter键
				if(event.ctrlkey &amp;&amp; event.keyCode == 13){
				console.log(&quot;you pressed the Ctrl + Enter&quot;);
				}


				201.获取浏览器插件的数目
				navigator.plugins.length;


				202.判断操作系统 ....


				203.原生javascript判断是否移动设备浏览器
				var movileReg = /iphone|ipod|android.*movile|windows.*phone|blackberry.*mobile/i;
				if( (mobileReg.test(window.navigator.userAgent.toLowerCase()))){
				alert(&quot;移动设备&quot;)
				}else{
				alert(&quot;非移动设备&quot;);
				}


				204.当浏览器不支持或者禁用客户端脚本的时候，
				&lt;noscript&gt;
				&lt;p&gt;此页面不支持JavaScript, 请更换浏览器或者启用对脚本的支持。&lt;/p&gt;
				&lt;/noscript&gt;


				205.Dreamweaver：
				优点：智能提示
				开发效率快
				缺点：代码把控难，效果不容易统一

				SublimeText
				神器
				界面简洁，布局多样
				代码提醒，折叠，补全功能
				可以跨平台工作
				性能好，速度快

				中文支持不好，
				成本高

				WebStorm
				Web前端开发神器
				智慧型编辑
				代码补全，检测，批量代码分析，代码重构，都很好。
				最新版加入了 HTML5支持。
				为代码提供质量检验，高亮提醒
				跨平台

				体系庞大，复杂



				206.调试JavaScript代码
				过时的alert();
				webInspector  chrome safari的调试工具
				firebug调试工具   ff


				207.ie下调试：
				直接引用一段代码：
				&lt;script type=&quot;text/javascript&quot; src=&quot;https://getfirebug.com/firebug-lite.JavaScript&quot;&gt;&lt;/script&gt;


				208.控制台，可以查看变量的值。
				console.log();
				ie的低版本不支持


				209.http分析
				想知道web在执行什么网络请求，通过调试工具来看，
				网络请求的时间，请求的方式，地址等。

				210.性能检测
				大型的项目，对性能要求高，尤其对移动终端设备
				在调试工具中的Profile可以看
				写法：
				console.profile();
				//要统计的代码....
				console.profileEnd();


				还可以这样实现：
				console.time(&quot;times&quot;);
				//代码段落
				console.timeEnd(&quot;timesEnd&quot;);

				211.web应用中大部分数据都是通过表单的方式来进行收集
				表单的处理非常重要。

				212.用户有时会误输入一些多余的空格，取出左右两边的空格
				oBtn.onclick = function(){
				oText.value = oText.value.replace( /^(\s|\u00A0)+|(\s|\u00A0)+$/g,&quot;&quot; );
				}


				213,验证一下输入是否为空：
				oBtn.onclick = function(){
				var _textFilter = oText.value.replace( /^(\s|\u00A0)+|(\s|\u00A0)+$/g,&quot;&quot; )
				oText.value = _textFilter;
				if(!_textFilter){
				alert(&#x27;输入空&#x27;)
				}else{
				alert(&#x27;不空&#x27;)
				}
				}


				214,html5 input  设置不可输入：
				1.直接在HTML 加入disabled
				或者加入readonly;  只读，不能修改，可以选中，复制其文本。

				2.js方式
				oText.onfocus = function(){
				oText.blur();
				}

				215,禁止复制粘贴
				oH.oncopy = function(){
				return false;
				};
				oText.oncopy = function(){
				return false;
				};
				oText.onpaste = function(){
				return false;
				}


				216,只能输入数字：
				用html5的
				&lt;input type=&quot;number&quot; name=&quot;html5&quot; /&gt;

				js方法：
				clearNonumber = function(obj){
				var _T = obj.value;
				obj.value = _T.replace(/\D/g,&quot;&quot;);
				};
				oText.onkeyup = function(){
				clearNonumber(this);
				};
				oText.onfocus = function(){
				clearNonumber(this);
				};
				oText.onblur = function(){
				clearNonumber(this);
				}



				217.只能输入中文
				chineseWord = function(obj){
				var _T = obj.value;
				obj.value = _T.replace(/[^\u4e00-\u9fa5]/g,&quot;&quot;);
				};
				oText.onblur = function(){
				chineseWord(this);
				};
				oText.onfocus = function(){
				chineseWord(this);
				};

				218.输入的内容，长度不超过多少
				限制字符串长度
				1. 有个maxlength =&quot;num&quot;属性，直接加进去，
				没有的就不支持。

				2.js实现：
				limitLength = function(obj){
				var _T = obj.value,
				_len = _T.length,
				_dataLength = obj.getAttribute(&quot;data-length&quot;),
				_dataModel = obj.getAttribute(&quot;data-model&quot;);

				console.log(_T +&#x27;:&#x27;+ _len +&#x27;:&#x27;+ _dataLength +&#x27;:&#x27;+ _dataModel);
				if(_len &gt; _dataLength) obj.value = _T.substr(0,_dataLength);

				}

				oText.onblur = function(){
				limitLength(this);
				}
				oText.onkeyup = function(){
				limitLength(this);
				}



				219.输入框里显示 input text 提醒 提示信息：
				html5里 有placeholder属性
				&lt;input type=&quot;text&quot; name=&quot;info&quot; placeholder=&quot;提示信息&quot;/&gt;

				js写法里，有一个问题，IE里不能操作value，修改不了。
				怎么办，我们用span来覆盖文本框


				220. 用setTimeout定时器，形成一个动画效果：
				xx = function(){
				xxxxx;
				setTimeout(xx,200);
				};
				xx();

				221.
				要求用户输入具有一定安全级别的密码，验证一下密码强度。


				222.检测密码强度
				function trim(str){  //去掉字符串左右两边的空格
				return ( str || &quot;&quot; ).replace(/^(s|\u00A0)+|(s|\u00A0)+$/g,&quot;&quot;);
				}

				function setCss(obj,oAttr){
				var sName=&quot;&quot;;
				var aName=[&quot;Webkit&quot;,&quot;Moz&quot;,&quot;O&quot;];
				for(sName in oAttr){
				if(sName.charAt(0)===&quot;$&quot;)
				{
				    for(var i=0;i&lt;aName.length;i++)
				    {
				        obj.style[aName[i]+sName.substring(1)]=oAttr[sName];
				    }
				    obj.style[sName.substring(1)]=oAttr[sName];
				}
				else
				{
				    obj.style[sName]=oAttr[sName];
				}
				}
				};

				function passwordStrength(obj_text,obj_span){
				obj_text.onblur= function(){
				var arrColor = [&quot;red&quot;,&quot;yellow&quot;,&quot;orange&quot;,&quot;green&quot;],
				    arrText = [&quot;密码太短&quot;,&quot;弱&quot;,&quot;中&quot;,&quot;强&quot;],
				    _v = trim( obj_text.value ),
				    _len = _v.length,
				    _strengthAll = 0;

				var oneStrength = function(oneStr){
				        if( oneStr &gt;= 48 &amp;&amp; oneStr &lt;= 57 ){
				            return 1;
				        };
				        if( oneStr &gt;= 97 &amp;&amp; oneStr &lt;= 122 ){
				            return 2;
				        }else{
				            return 3;
				        }
				    }

				    if( _len &lt; 6 &amp;&amp; _len &gt; 0 ){
				        obj_span.innerHTML = arrText[0];
				        setCss(obj_span,{
				            &quot;color&quot; : arrColor[0]
				        });
				    }else{
				        for(var i=0; i&lt;_len; i++){
				            var _ele_str = _v.toLowerCase().charCodeAt(i);
				            _strengthAll += oneStrength( _ele_str );
				        };
				        alert( _strengthAll );
				        if( _strengthAll &lt; 10 &amp;&amp; _len &gt; 0){
				            obj_span.innerHTML = arrText[1];
				            setCss(obj_span,{
				                &quot;color&quot; : arrColor[1]
				            });
				        }
				        if( _strengthAll &gt;= 10 &amp;&amp; _strengthAll &lt; 15 ){
				            obj_span.innerHTML = arrText[2];
				            setCss(obj_span,{
				                &quot;color&quot; : arrColor[2]
				            });
				        }
				        if( _strengthAll &gt;= 15 ){
				            obj_span.innerHTML = arrText[3];
				            setCss(obj_span,{
				                &quot;color&quot; : arrColor[3]
				            });
				        }
				    }
				}
				};

				223.回车提交表单：
				_oText.onkeyup = function(ev){
				var ev = ev || window.event;
				var keycode = ev.keyCode || ev.which || ev.charCode; //不同的浏览器对键码的处理方式不同
				if( keycode === 13 ){
				alert(&quot;提交成功&quot;)
				};
				};


				224.禁止文本框的记忆功能，一些主流的浏览器，会自动记忆输入过的文本，再次输入，会自动完成输入。 但是在
				输入银行帐号，游戏账号等敏感性高的，不需要这个：
				HTML设置这个：
				&lt;input type=&quot;text&quot; id=&quot;text&quot; autocomplete=&quot;off&quot; /&gt;

				js:
				oText.setAttribute(&quot;autocomplete&quot;,&quot;off&quot;);


				225.对文本内容，关键字，过滤
				_oText.onclick = function(){
				var keyWord = [&quot;影响&quot;,&quot;效果&quot;,&quot;is&quot;],
				_len = keyWord.length;
				for( var i=0; i&lt;keyWord.length; i++ ){
				    _oText.value = _oText.value.replace( keyWord[i],&quot;***&quot; );
				}
				}

				226.检测是不是数字类型：
				var isNumber = function( num ){
				return typeof num ==&quot;number&quot;;
				};
				alert( isNumber(&#x27;1&#x27;) ); //  --- false
				alert( isNumber(1) ); // ----true

				227.判断单选框，是否选中
				&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sexMan&quot; checked /&gt;男 &lt;br/&gt;
				&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sexWoman&quot;&gt;女

				if( sexMan.checked ){
				console.log( &quot;sexMan被选中&quot; );
				}else{
				console.log( &quot;sexMan未被选中&quot; );
				}


				228，刚刚打开app 的时候，会出来多选项，供我们选择，当提交表单数据的时候，系统获取被选中的值
				html:
				&lt;ul&gt;
				&lt;li&gt;
				&lt;input type=&quot;checkbox&quot; name=&quot;one&quot;&gt;&lt;div class=&quot;content&quot;&gt;1&lt;/div&gt;
				&lt;/li&gt;
				&lt;li&gt;
				&lt;input type=&quot;checkbox&quot; name=&quot;one&quot;&gt;&lt;div class=&quot;content&quot;&gt;2&lt;/div&gt;
				&lt;/li&gt;
				&lt;li&gt;
				&lt;input type=&quot;checkbox&quot; name=&quot;one&quot;&gt;&lt;div class=&quot;content&quot;&gt;3&lt;/div&gt;
				&lt;/li&gt;
				&lt;/ul&gt;
				&lt;p id=&quot;p&quot;&gt;&lt;/p&gt;

				js:
				var _Text = &quot;&quot;,
				_sel = document.getElementsByName(&#x27;one&#x27;),
				_oP = document.getElementById(&#x27;p&#x27;),
				_selLen = _sel.length;

				for( var i=0; i&lt;_selLen; i++ ){
				_sel[i].onclick = function(){
				    var _T = this.nextSibling.innerText;
				    if( this.checked ){
				        _Text += _T;
				    }else{
				        _Text = _Text.replace(_T,&quot;&quot;);
				    }
				_oP.innerHTML = _Text;
				}

				229.动态添加下拉选项：
				html:&lt;input type=&quot;button&quot; value=&quot;添加&quot; id=&quot;btn&quot;/&gt;
				&lt;select id=&quot;sel&quot;&gt;
				&lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt;
				&lt;option value=&quot;1&quot;&gt;广州&lt;/option&gt;
				&lt;/select&gt;

				js:
				var _oSel = document.getElementById(&#x27;sel&#x27;);
				var _oBtn = document.getElementById(&#x27;btn&#x27;);
				addOptions = function(obj,arr){
				var _v = &quot;&quot;,
				_t = &quot;&quot;;
				for(var i=0; i&lt;arr.length; i++){
				_v = arr[i].value;
				_t = arr[i].text;
				_oPtion = document.createElement(&#x27;option&#x27;);
				_oPtion.value = _v;
				_oPtion.text = _t;
				obj.appendChild(_oPtion);
				}
				};
				_oBtn.onclick = function(){

				addOptions(_oSel,[
				{
				&quot;value&quot; : &quot;深圳&quot;,
				&quot;text&quot; : &quot;深圳&quot;
				},
				{
				&quot;value&quot; : &quot;珠海&quot;,
				&quot;text&quot; : &quot;珠海&quot;
				},
				{
				&quot;value&quot; : &quot;惠州&quot;,
				&quot;text&quot; : &quot;惠州&quot;
				},
				{
				&quot;value&quot; : &quot;佛山&quot;,
				&quot;text&quot; : &quot;佛山&quot;
				}
				]);
				}


				230.动态删除下拉选项：
				removeOptions = function(obj,arr){
				for(var i=0; i&lt;arr.length; i++){
				obj.options[i] &amp;&amp; obj.options.remove(obj.options[i]);
				}
				}

				_oBtn.onclick = function(){
				removeOptions(_oSel,[
				1,2
				]);
				}


				231.联动下拉选项
				html:
				&lt;p id=&quot;p1&quot;&gt;
				省级：
				&lt;select id=&quot;provinces&quot;&gt;
				&lt;/select&gt;
				&lt;/p&gt;


				&lt;p id=&quot;p2&quot;&gt;
				市级：
				&lt;select id=&quot;citys&quot;&gt;
				&lt;/select&gt;
				&lt;/p&gt;

				js:
				var _oPro = document.getElementById(&#x27;provinces&#x27;);
				var _oCity = document.getElementById(&#x27;citys&#x27;);

				var linkDatas = {
				provinces:[
				{
				    &quot;code&quot; : &quot;0&quot;,
				    &quot;name&quot; : &quot;请选择&quot;
				},
				{
				    &quot;code&quot; : &quot;1&quot;,
				    &quot;name&quot; : &quot;广东&quot;
				},
				{
				    &quot;code&quot; : &quot;2&quot;,
				    &quot;name&quot; : &quot;北京&quot;
				},
				{
				    &quot;code&quot; : &quot;3&quot;,
				    &quot;name&quot; : &quot;上海&quot;
				}
				],
				citys:{
				0 : [
				    &quot;请选择&quot;
				],
				1 : [
				    &quot;广州&quot;,
				    &quot;惠州&quot;,
				    &quot;深圳&quot;,
				    &quot;珠海&quot;
				],
				2 : [
				    &quot;朝阳区&quot;,
				    &quot;海淀区&quot;,
				    &quot;东城区&quot;,
				    &quot;西城区&quot;
				],
				3 : [
				    &quot;浦东区&quot;,
				    &quot;虹口区&quot;,
				    &quot;杨浦区&quot;,
				    &quot;徐汇区&quot;
				]
				}
				};

				linkage(_oPro, _oCity,linkDatas);

				function linkage(obj1,obj2,data){
				var _P = data.provinces, // array
				_C = data.citys, // json
				_C0 = _C[0],
				arrOptions = [];

				for(var i=0; i&lt;_P.length; i++){
				arrOptions.push({
				    &quot;text&quot; : _P[i].name,
				    &quot;value&quot; : _P[i].code
				});
				};
				addOptions = function(obj,arr){
				var _v = &quot;&quot;,
				    _t = &quot;&quot;;
				for(var i=0; i&lt;arr.length; i++){
				    _v = arr[i].value;
				    _t = arr[i].text;
				    _oPtion = document.createElement(&#x27;option&#x27;);
				    _oPtion.value = _v;
				    _oPtion.text = _t;
				    obj.appendChild(_oPtion);
				}
				};

				addOptions(obj1,arrOptions);  //初始化
				addOptions(obj2,[{   // 初始化
				&quot;value&quot;:_C0,
				&quot;text&quot; : _C0
				}]);
				//变动时：
				obj1.onchange = function(){
				var _which = this.value;
				var _CThis =  _C[_which];
				obj2.innerHTML = &quot;&quot;;
				var arrOptions = [];
				for( var i=0; i&lt;_CThis.length; i++ ){
				    arrOptions.push({
				        &quot;value&quot;: _CThis[i],
				        &quot;text&quot;: _CThis[i]
				    });
				};

				addOptions(obj2,arrOptions);
				}
				};


				232.
				有些网站提供的下拉选项，不存在想要的数据，用户自己可以填写一个下拉选项。
				可输入的下拉框。
				html:
				&lt;select id=&quot;sel&quot; /&gt;
				&lt;option value=&quot;可输入1&quot;&gt;可以输入1&lt;/option&gt;
				&lt;option value=&quot;可输入2&quot;&gt;可以输入2&lt;/option&gt;
				&lt;/select&gt;
				&lt;input type=&quot;text&quot; id=&quot;text&quot;/&gt;

				js:
				var _oText = document.getElementById(&#x27;text&#x27;);
				var _oSel = document.getElementById(&#x27;sel&#x27;);

				addOptions = function(obj,arr){
				var _v = &quot;&quot;,
				_t = &quot;&quot;;
				for(var i=0; i&lt;arr.length; i++){
				_v = arr[i].value;
				_t = arr[i].text;
				_oPtion = document.createElement(&#x27;option&#x27;);
				_oPtion.value = _v;
				_oPtion.text = _t;
				obj.appendChild(_oPtion);
				}
				};
				_oText.onkeyup = function(){
				var key = event.keyCode,
				_v = _oText.value;
				if( key == 13 ){
				addOptions(_oSel,[
				{
				    &quot;value&quot; : _v,
				    &quot;text&quot; : _v
				}
				]);
				}
				};


				233.小写转换为大写：
				字符型转换为数值型
				数值型转换为字符型
				getLowerCase = function(str,type){
				type = type || &quot;locale&quot;;
				return type === &quot;locale&quot; &amp;&amp; str.toLocaleUpperCase() || str.toUpperCase();
				}

				getNumbers = function(s){  //字符串转为数值
				var n = parseInt(s,10);
				alert(typeof n);
				if( isNaN(n) ) return 0;
				return n;
				};

				getString = function(n){
				return n.toString();
				}

				alert(typeof getString(435) );
				console.log( getNumbers(&quot;244&quot;) );

				console.log( getLowerCase(&quot;ksjgj4KJKposlkskII33&quot;) );


				234.html5语义化标签
				表单等等....

				1.html5
				一个是新增的语义化的标签
				一个是js的接口

				语义化标签：
				页面结构简化成如下：
				&lt;!DOCTYPE html&gt;
				&lt;html&gt;
				&lt;head&gt;
				&lt;meta charset=&quot;utf-8&quot; /&gt;
				&lt;title&gt;无标题文档&lt;/title&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;/body&gt;
				&lt;/html&gt;

				方便开发人员


				统计出来的用的最多的id
				干脆就把它们添加为：语义化的标签


				&lt;header&gt;&lt;/header&gt;
				用在页面的头部或者板块的头部

				&lt;footer&gt;&lt;/footer&gt;
				用在页面的头部或者版块的底部

				&lt;nav&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;xxxxx&lt;/a&gt;&lt;/p&gt;&lt;/nav&gt;
				导航


				/////////////////
				&lt;hgroup&gt;
				    &lt;h1&gt;妙味课堂&lt;/h1&gt;
				    &lt;h2&gt;带您进入富有人情味的IT培训&lt;/h2&gt;
				&lt;/hgroup&gt;
				页面上的一个标题组合
				一个标题和一个子标题，或者标语的组合。

				/////////////////
				&lt;section&gt;&lt;section&gt;
				页面的板块
				用户划分页面上的不同区域或者划分文章里的不同的节
				/////////////////
				&lt;article&gt;&lt;/article&gt;
				用来在页面中标示一套结构完整且独立的内容部分。
				 独立的帖子，杂志，文章，博客，回帖，主体
				/////////////////
				 &lt;aside&gt;&lt;/aside&gt;
				 和主体相关的附属信息
				 相关的引用，侧边栏，广告等等
				 aside的内容应该与article内容相关

				 还可以在&lt;article&gt;之外使用，作为页面或者站点全局的附属内容，可以是友情链接，附属导航，广告单元，侧边栏。

				/////////////////
				 &lt;figure&gt;
				    &lt;img /&gt;
				    &lt;figcaption&gt;描述的文字&lt;/figcaption&gt;
				 &lt;/figure&gt;
				  包含图片或者视频等媒体元素


				&lt;time&gt;2015.12&lt;/time&gt;

				&lt;time datetime=&quot;2008-02-14&quot;&gt;情人节&lt;/time&gt;




				 不同于前面的单纯语义化的标签
				 下面这个是有功能的：
				 input里面多了一个 list=&quot;valList&quot;
				 当input获取光标，下面会弹出
				 属于一个下面有的  会弹出来
				 可能会出现的值


				 &lt;datalist&gt; &lt;/datalist&gt;
				 选项列表
				 与input元素配合使用，来 定义input可能的值

				 &lt;input type=&quot;text&quot; list=&quot;valList&quot;/&gt;
				 &lt;datalist id=&quot;valList&quot;&gt;
				    &lt;option value=&quot;javascript&quot;&gt;&lt;/option&gt;
				    &lt;option value=&quot;html&quot;&gt;html&lt;/option&gt;
				    &lt;option value=&quot;css&quot;&gt;css&lt;/option&gt;
				 &lt;/datalist&gt;


				/////////////////

				&lt;details&gt;&lt;/details&gt;
				用于描述文档或者文档某个部分的细节
				点击“妙味课堂”， p里面的内容出来了。

				&lt;details&gt;
				    &lt;summary&gt;妙味课堂&lt;/summary&gt;
				    &lt;p&gt;国内知名的IT培训机构&lt;/p&gt;
				&lt;/details&gt;

				/////////////////

				有个属性open 添加进去 信息都出来了
				这个open也能用在上面的&lt;detail open&gt;上

				&lt;dialog open&gt;
				&lt;dt&gt;老师&lt;/dt&gt;
				&lt;dd&gt;2+2 等于？&lt;/dd&gt;
				&lt;dt&gt;学生&lt;/dt&gt;
				&lt;dd&gt;4&lt;/dd&gt;
				&lt;dt&gt;老师&lt;/dt&gt;
				&lt;dd&gt;答对了&lt;/dd&gt;
				&lt;/dialog&gt;

				/////////////////

				&lt;address&gt;&lt;/address&gt;
				定义文章或者页面作者的详细联系信息



				里面的text内容会加上背景颜色
				黄色是默认的颜色
				&lt;mark&gt;标记&lt;/mark&gt;


				进度条： 有功能
				&lt;progress max=&quot;100&quot; value=&quot;50&quot;&gt;
				&lt;span&gt;70&lt;/span&gt;%
				&lt;/progress&gt;


				/////////////////
				兼容：
				&lt;header&gt;页面头部&lt;/header&gt;
				&lt;article&gt;
				    &lt;aside&gt;侧边栏&lt;/aside&gt;
				    &lt;section&gt;内容区域&lt;/section&gt;
				&lt;/article&gt;
				&lt;footer&gt;页面底部&lt;/footer&gt;


				ie下，给它们添加样式的效果没有出来
				我们说，标准下，是支持自定义标签的&lt;leo&gt;&lt;/leo&gt;
				 那在ie下怎么弄，
				 我们这样： 给上面这些语义化的标签js做这一步：
				 document.createElement(&quot;header&quot;);
				document.createElement(&quot;article&quot;);
				document.createElement(&quot;aside&quot;);
				document.createElement(&quot;section&quot;);
				document.createElement(&quot;footer&quot;);

				  但是还要在样式里面加样式
				  因为这些新加的样式，在ie6下是没有的
				  因此不知道是块还是内嵌
				  需要我们加上去

				  这样解决不方便
				  现在有这么一个插件，来解决兼容问题


				/////////////////

				  ie下这些功能没有效果：
				  没办法智能通过js写出来：

				  &lt;details&gt;
				    &lt;summary&gt;妙味课堂&lt;/summary&gt;
				    &lt;p&gt;国内知名的IT培训机构&lt;/p&gt;
				  &lt;/details&gt;

				  &lt;progress max=&quot;100&quot; value=&quot;50&quot;&gt;
				  &lt;span&gt;70&lt;/span&gt;%
				  &lt;/progress&gt;



				/////////////////

				  新增表单控件和表单属性

				        表单控件：
				        &lt;form&gt;
				             &lt;input type=&quot;email&quot;/&gt;
				             &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				  email: 当输入的不是邮箱格式，它会弹出“请输入邮箱地址”
				  在移动端，切换到英文状态。

				/////////////////


				        &lt;form&gt;
				             &lt;input type=&quot;tel&quot;/&gt;
				             &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        在pc端没有什么特别的变化
				        在移动端有一个键盘的切换，切换成数字
				/////////////////

				        &lt;form&gt;
				             &lt;input type=&quot;url&quot;/&gt;
				             &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        提示用户输入正确的网址进去

				/////////////////

				        &lt;form&gt;
				             &lt;input type=&quot;search&quot;/&gt;
				             &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;

				        后边有一个x，点击后清除内容

				/////////////////


				        &lt;form&gt;
				             &lt;input type=&quot;range&quot; step=&quot;2&quot; min=&quot;0&quot; max=&quot;10&quot; value=&quot;2&quot;/&gt;
				             &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        一次2步，最小0，最大10
				        value是当前值


				/////////////////


				        &lt;form&gt;
				             &lt;input type=&quot;number&quot;/&gt;
				             &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        向上加  向上减
				        用在购买数量的增减
				        opear浏览器做得好


				/////////////////
				        &lt;form&gt;
				             &lt;input type=&quot;color&quot;/&gt;
				             &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        可以选择颜色，进行提交

				/////////////////

				        &lt;form&gt;
				             &lt;input type=&quot;datetime&quot;/&gt;
				              &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        世界标准时间



				/////////////////

				        &lt;form&gt;
				             &lt;input type=&quot;datetime-local&quot;/&gt;
				              &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        没有utc
				        不含有时区

				/////////////////

				         &lt;form&gt;
				             &lt;input type=&quot;time&quot;/&gt;
				              &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        小时  分钟数

				/////////////////

				        &lt;form&gt;
				             &lt;input type=&quot;date&quot;/&gt;
				              &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        年月日

				/////////////////

				        &lt;form&gt;
				             &lt;input type=&quot;week&quot;/&gt;
				              &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        详细到第几周

				/////////////////

				        &lt;form&gt;
				             &lt;input type=&quot;month&quot;/&gt;
				              &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        显示月


				/////////////////

				        表单相关的属性：


				        &lt;form&gt;
				             &lt;input type=&quot;text&quot; placeholder = &quot;请输入4-16个字符&quot;/&gt;
				              &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;

				        1.提示信息：
				            placeholder = &quot;请输入4-16个字符&quot;


				        2.是否自动保存用户输入值：
				            autocomplete = &quot;on/off&quot;
				/////////////////

				        3.指定表单光标: autofocus
				        &lt;form&gt;
				        &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt;
				        &lt;input type=&quot;password&quot; name=&quot;paddword&quot; autofocus/&gt;
				        &lt;input type=&quot;sumit&quot;&gt;
				        &lt;/form&gt;

				        打开页面，光标指定在密码框
				/////////////////

				        4.为输入框构造一个选择列表
				        list/ datalist
				        list值是datalist标签的id

				/////////////////
				        5.保证不能输入为空： required
				        &lt;form&gt;
				             &lt;input type=&quot;text&quot;/ required&gt;
				              &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;
				        没有输入内容，提交的话，会提示。
				/////////////////

				        6. 正则 Pattern
				        1-5位的内容，超过会提示
				        required 和 pattern检验 在pc里有安全隐患

				        &lt;form&gt;
				             &lt;input type=&quot;text&quot; pattern=&quot;\d{1,5}&quot;/&gt;
				              &lt;input type=&quot;submit&quot;/&gt;
				        &lt;/form&gt;

				/////////////////

				        7.formaction=&quot;&quot;

				        &lt;form&gt;
				             &lt;input type=&quot;datetime&quot;/&gt;
				              &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;
				              &lt;input type=&quot;submit&quot; value=&quot;保存至草稿箱&quot; formaction=&quot;http://www.miaov.com/2013&quot;/&gt;
				        &lt;/form&gt;


				/////////////////

				        表单的验证反馈：

				            &lt;form&gt;
				                 &lt;input type=&quot;text&quot; required id=&quot;text&quot;/&gt;
				                 &lt;input type=&quot;submit&quot;/&gt;
				            &lt;/form&gt;

				        JS:
				            oText
				            js如何知道内容通过了验证反馈了呢？
				            需要验证反馈来操作
				            oText.addEventListener(&quot;invalid&quot;,fn1,false);

				             反馈回来的信息存在 validity对象的valid属性里面
				            function fn1(){
				                alert(this.validity.valid) //  false/true
				                ev.preventDefault();
				            }


				            当为true的时候，验证通过了，看不到true

				/////////////////

				            valueMissing
				            function fn1(){
				                alert(this.validity.valueMissing) //  false/true
				                ev.preventDefault();
				            }
				            valueMissing
				            只有当required使用是
				            才判断 是否为空
				            js里才有对应的反馈值


				            当内容为空的时候
				            this.validity.valueMissing----&gt;true--&gt;valid--&gt;false
				            当输入值不为空时	this.validity.valueMissing----&gt;false--&gt;valid--&gt;true


				/////////////////

				            typeMismatch:
				            控件值与预期类型不匹配

				            function fn1(){
				                alert(this.validity.typeMismatch) //  false/true
				                ev.preventDefault();
				            }

				            email url
				            判断是否是相应的格式
				            当输入类型不满足要求的类型的时候，返回true；


				/////////////////

				            patternMismatch
				            输入值不满足pattern正则

				            给input加正则：
				                pattern=&quot;\d{1, 5}&quot;

				            function fn1(){
				                alert(this.validity.patternMismatch) //  false/true
				                ev.preventDefault();
				            }

				            当输入内容不匹配正则
				            返回true


				/////////////////

				            tooLong：超过maxlength最大限制

				            input里面有一个maxlength属性  超过  输入不进去
				            当超过的时候，
				            返回ture


				/////////////////
				            rangeUnderflow:
				            验证range最小值是否满足
				            rangeOverflow:
				            验证range最大值是否超出最大值
				            stepMismatch:
				            验证range的当前值是否符合min/max/以及step的规则
				            min是2
				            step是2
				            那下一步就2+2==4
				            而value=3
				            不满足

				            &lt;form&gt;
				                 &lt;input type=&quot;range&quot; value=&quot;3&quot; min=&quot;0&quot; max=&quot;10&quot; step=&quot;2&quot;/&gt;
				                 &lt;input type=&quot;submit&quot;/&gt;
				            &lt;/form&gt;


				            function fn1(){
				                alert(this.validity.rangeUnderflow) //  false/true
				                ev.preventDefault();
				            }


				/////////////////

				            setCustomValidity:
				            customError：

				            自定义验证怎么添加：
				                oText.oninput = function(){
				                    if(this.value==&quot;敏感词&quot;){
				                            this.setCustomValidity(&quot;请不要输入敏感词&quot;);
				                    }else{
				                            this.setCustomValidity(&#x27;&#x27;)
				                    }

				                }

				                当输入:&quot;敏感词&quot;，会弹出&quot;请不要输入敏感词&quot;，会弹出true

				                function fn1(){
				                alert(this.validity.customError) //  false/true
				                ev.preventDefault();
				            }



				/////////////////

				            valid有八种验证
				            如果全部都通过返回false
				            那valid返回true，意味着全部验证通过
				            如果八种当中有一个
				            返回的是true
				            意味着valid返回肯定是false
				            不通过


				235. http协议：
				一、概述
				1.1 五层模型
				互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。
				用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。
				如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。

				如上图所示，最底下的一层叫做&quot;实体层&quot;（Physical Layer），最上面的一层叫做&quot;应用层&quot;（Application Layer），中间的三层（自下而上）分别是&quot;链接层&quot;（Link Layer）、&quot;网络层&quot;（Network Layer）和&quot;传输层&quot;（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。
				它们叫什么名字，其实并不重要。只需要知道，互联网分成若干层就可以了。
				1.2 层与协议
				每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。
				大家都遵守的规则，就叫做&quot;协议&quot;（protocol）。
				互联网的每一层，都定义了很多协议。这些协议的总称，就叫做&quot;互联网协议&quot;（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。
				二、实体层
				我们从最底下的一层开始。
				电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。

				这就叫做&quot;实体层&quot;，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。
				三、链接层
				3.1 定义
				单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？
				这就是&quot;链接层&quot;的功能，它在&quot;实体层&quot;的上方，确定了0和1的分组方式。
				3.2 以太网协议
				早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做&quot;以太网&quot;（Ethernet）的协议，占据了主导地位。
				以太网规定，一组电信号构成一个数据包，叫做&quot;帧&quot;（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。

				&quot;标头&quot;包含数据包的一些说明项，比如发送者、接受者、数据类型等等；&quot;数据&quot;则是数据包的具体内容。
				&quot;标头&quot;的长度，固定为18字节。&quot;数据&quot;的长度，最短为46字节，最长为1500字节。因此，整个&quot;帧&quot;最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。
				3.3 MAC地址
				上面提到，以太网数据包的&quot;标头&quot;，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？
				以太网规定，连入网络的所有设备，都必须具有&quot;网卡&quot;接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。

				每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。

				前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。
				3.4 广播
				定义地址只是第一步，后面还有更多的步骤。
				首先，一块网卡怎么会知道另一块网卡的MAC地址？
				回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。
				其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？
				回答是以太网采用了一种很&quot;原始&quot;的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。

				上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的&quot;标头&quot;，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做&quot;广播&quot;（broadcasting）。
				有了数据包的定义、网卡的MAC地址、广播的发送方式，&quot;链接层&quot;就可以在多台计算机之间传送数据了。
				四、网络层
				4.1 网络层的由来
				以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。
				但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一&quot;包&quot;，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。
				互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。

				因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用&quot;路由&quot;方式发送。（&quot;路由&quot;的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。
				这就导致了&quot;网络层&quot;的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做&quot;网络地址&quot;，简称&quot;网址&quot;。
				于是，&quot;网络层&quot;出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。
				网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。
				4.2 IP协议
				规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。
				目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。

				习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。
				互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。
				但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。
				那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数&quot;子网掩码&quot;（subnet mask）。
				所谓&quot;子网掩码&quot;，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。
				知道&quot;子网掩码&quot;，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。
				比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。
				总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。
				4.3 IP数据包
				根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。
				但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？
				回答是不需要，我们可以把IP数据包直接放进以太网数据包的&quot;数据&quot;部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。
				具体来说，IP数据包也分为&quot;标头&quot;和&quot;数据&quot;两个部分。

				&quot;标头&quot;部分主要包括版本、长度、IP地址等信息，&quot;数据&quot;部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。

				IP数据包的&quot;标头&quot;部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的&quot;数据&quot;部分，最长为65,515字节。前面说过，以太网数据包的&quot;数据&quot;部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。
				4.4 ARP协议
				关于&quot;网络层&quot;，还有最后一点需要说明。
				因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。
				所以，我们需要一种机制，能够从IP地址得到MAC地址。
				这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的&quot;网关&quot;（gateway），让网关去处理。
				第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个&quot;广播&quot;地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。
				总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。
				五、传输层
				5.1 传输层的由来
				有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。
				接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？
				也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做&quot;端口&quot;（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。
				&quot;端口&quot;是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。
				&quot;传输层&quot;的功能，就是建立&quot;端口到端口&quot;的通信。相比之下，&quot;网络层&quot;的功能是建立&quot;主机到主机&quot;的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做&quot;套接字&quot;（socket）。有了它，就可以进行网络应用程序开发了。
				5.2 UDP协议
				现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。
				UDP数据包，也是由&quot;标头&quot;和&quot;数据&quot;两部分组成。

				&quot;标头&quot;部分主要定义了发出端口和接收端口，&quot;数据&quot;部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的&quot;数据&quot;部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：

				UDP数据包非常简单，&quot;标头&quot;部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。
				5.3 TCP协议
				UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。
				为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。
				因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。
				TCP数据包和UDP数据包一样，都是内嵌在IP数据包的&quot;数据&quot;部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。
				六、应用层
				应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。
				&quot;应用层&quot;的作用，就是规定应用程序的数据格式。
				举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了&quot;应用层&quot;。
				这是最高的一层，直接面对用户。它的数据就放在TCP数据包的&quot;数据&quot;部分。因此，现在的以太网的数据包就变成下面这样。

				至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。下一篇，我反过来，从用户的角度，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。
				（完）





				先对前面的内容，做一个小结。
				我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：

				发送这个包，需要知道两个地址：
				　　* 对方的MAC地址
				　　* 对方的IP地址
				有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。

				上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。
				1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：
				场景	数据包地址
				同一个子网络	对方的MAC地址，对方的IP地址
				非同一个子网络	网关的MAC地址，对方的IP地址
				发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。
				八、用户的上网设置
				8.1 静态IP地址
				你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？

				通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：
				　　* 本机的IP地址
				　　* 子网掩码
				　　* 网关的IP地址
				　　* DNS的IP地址
				下图是Windows系统的设置窗口。

				这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作&quot;静态IP地址上网&quot;。
				但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用&quot;动态IP地址上网&quot;。
				8.2 动态IP地址
				所谓&quot;动态IP地址&quot;，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。
				这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做&quot;DHCP服务器&quot;。新的计算机加入网络，必须向&quot;DHCP服务器&quot;发送一个&quot;DHCP请求&quot;数据包，申请IP地址和相关的网络参数。
				前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？
				DHCP协议做了一些巧妙的规定。
				8.3 DHCP协议
				首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：

				　　（1）最前面的&quot;以太网标头&quot;，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。
				　　（2）后面的&quot;IP标头&quot;，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。
				　　（3）最后的&quot;UDP标头&quot;，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。
				这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道&quot;这个包是发给我的&quot;，而其他计算机就可以丢弃这个包。
				接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个&quot;DHCP响应&quot;数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。
				新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。
				8.4 上网设置：小结
				这个部分，需要记住的就是一点：不管是&quot;静态IP地址&quot;还是&quot;动态IP地址&quot;，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：
				　　* 本机的IP地址
				　　* 子网掩码
				　　* 网关的IP地址
				　　* DNS的IP地址
				有了这几个数值，电脑就可以上网&quot;冲浪&quot;了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。
				九、一个实例：访问网页
				9.1 本机参数
				我们假定，经过上一节的步骤，用户设置好了自己的网络参数：
				　　* 本机的IP地址：192.168.1.100
				　　* 子网掩码：255.255.255.0
				　　* 网关的IP地址：192.168.1.1
				　　* DNS的IP地址：8.8.8.8
				然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。

				这意味着，浏览器要向Google发送一个网页请求的数据包。
				9.2 DNS协议
				我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。
				DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。

				然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。
				9.3 子网掩码
				接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。
				已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。
				因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。
				9.4 应用层协议
				浏览网页用的是HTTP协议，它的整个数据包构造是这样的：

				HTTP部分的内容，类似于下面这样：
				　　GET / HTTP/1.1
				　　Host: www.google.com
				　　Connection: keep-alive
				　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ......
				　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
				　　Accept-Encoding: gzip,deflate,sdch
				　　Accept-Language: zh-CN,zh;q=0.8
				　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
				　　Cookie: ... ...
				我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。
				9.5 TCP协议
				TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。
				TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。
				9.6 IP协议
				然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。
				IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。
				9.7 以太网协议
				最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。
				以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。

				9.8 服务器端响应
				经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。
				根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的&quot;HTTP请求&quot;，接着做出&quot;HTTP响应&quot;，再用TCP协议发回来。
				本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。


				236.阿帕奇服务器


				237.
				无刷新ajax上传
				var _oBtn = document.getElementById(&#x27;btn&#x27;);
				var _myFile = document.getElementById(&#x27;file&#x27;);
				var _oDiv2 = document.getElementById(&#x27;div2&#x27;);
				var _oDiv3 = document.getElementById(&#x27;div3&#x27;);

				_oBtn.onclick = function(){
				/*for(var attr in _myFile.files[0]){
				console.log( attr + &quot;:&quot; + _myFile.files[0][attr] );
				}*/
				var xhr = new XMLHttpRequest();
				xhr.onload = function(){
				var d = JSON.parse(this.responseText);
				alert(d.msg + &#x27;:&#x27; + d.url)
				};

				var _upLoad = xhr.upload;
				_upLoad.onprogress = function(ev){
				console.log(ev.total + &quot;/&quot; + ev.loaded);
				var _scale =parseInt( ev.loaded/ev.total );
				_oDiv2.style.width = _scale*300 + &#x27;px&#x27;;
				_oDiv3.innerHTML = _scale*100 + &#x27;%&#x27;;
				};

				xhr.open(&#x27;post&#x27;,&#x27;post_file.php&#x27;,true); // 异步
				xhr.setRequestHeader(&#x27;X-Request-With&#x27;,&#x27;XMLHttpRequest&#x27;);
				var oFormData = new FormData();
				oFormData.append(&#x27;file&#x27;,_myFile.files[0]); //--&gt;二进制
				xhr.send(oFormData); //我们要知道后端那边接受数据的名称是什么
				}


				238.
				同域下，跨域下，两窗口之间通讯
				准备工作：
				服务器的搭建。

				在本机绑定2个虚拟的域名。

				虚拟主机搭建 相关配置
				自己配置
				虚拟主机的配置文件
				httpd-vhosts.conf
				打开它
				设置一下域名
				把路径改一下
				把a文件夹的路径复制一下，粘贴到下面：
				DocumentRoot &quot;E:\html5\a&quot;;
				&lt;Directory &quot;E:\html5\a&quot;&gt;

				DocumentRoot &quot;E:\html5\b&quot;;
				&lt;Directory &quot;E:\html5\b&quot;&gt;;

				现在访问a.com b.com就是访问这里

				修改一下hosts文件：

				127.0.0.1  www.a.com
				127.0.0.1  www.b.com

				检测一下：
				运行----&gt;cmd---&gt; ping www.a.com

				在a文件里面新建一个测试文件
				text文件

				把服务器进行重启

				浏览器里输入：
				www.a.com
				里面应该有个text文件
				能否访问
				能的话说明配置成功。

				在本机绑定好2个本地能访问的网站：
				www.a.com/text.txt
				www.b.com/text.txt


				postMessage对象
				先了解一下接受消息的窗口对象
				不同的浏览器窗口，对页面访问方式有什么方式

				1.iframe.html:
				&lt;body&gt;
				&lt;input type=&quot;buttom&quot; value =&quot;点击我，改变2.iframe.html的背景颜色&quot; id=&quot;btn&quot;/&gt;
				&lt;iframe id=&quot;myframe&quot; src=&quot;2.iframe.html&quot;&gt;&lt;/iframe&gt;
				&lt;/body&gt;

				&lt;script&gt;
				有一个叫做iframe框架
				框架可以引入一个新的窗口;
				window.open的方法打开;
				&lt;/script&gt;


				2.iframe.html:

				这里是a.com下的2.iframe.html;


				这个时候打开1.iframe.html
				就会有一个2.iframe的页面窗口
				我们所说的窗口之间的操作：
				我们可以通过js去访问被包含页面的DOM元素:
				1.iframe.html:
				js:
				window.onload = function(){
				var oBtn = document.getElementById(&#x27;btn&#x27;);
				var oMyIframe = document.getElementById(&#x27;myframe&#x27;);

				oBtn.onclick = function(){
				//如果我们要操作一个iframe里面的DOM元素，首先要获取到iframe引入的页面的window对象
				 oMyIframe.contentWindow ---&gt;就是被iframe包含的页面的window对象
				 oMyIframe.contentWindow.document.body.style.background = &#x27;red&#x27;;
				}
				}


				如果，反过来，我想通过被包含的页面去操作包含它的页面的DOM,也就是子集页面操作父级页面窗口，怎么做到：
				这个时候用到就是 parent
				它是window对象
				// 注意，如果没有父级页面了，那就是当前页面的window对象。
				怎么用：
				我们在2.iframe.html：
				oBtn.onclick = function(){
				parent.document.body.style.background = &#x27;green&#x27;;

				top.document.body.style.background = &#x27;red&#x27;; //top指的是最顶上的window对象
				}


				/////////////////////////////////

				window.open也可以做到：
				这个方法， window.open();返回的值就是被打开窗口的window对象
				新建： 3.window.open.html

				&lt;input type = &quot;button&quot; value=&quot;点击我，开启一个新的窗口打开4.window.open.html&quot; id = &quot;btn&quot; /&gt;
				&lt;input type = &quot;button&quot; value=&quot;点击我,新窗口颜色变红&quot; id = &quot;btn&quot; /&gt;

				js:
				var newWindow = null;
				oBtn.onclick = function(){
				newWindow =  window.open(&#x27;4.window.open.html&#x27;,&#x27;_blank&#x27;);
				}
				oBtn2.onclick = function(){
				newWindow.document.body.sytle.background = &#x27;red&#x27;;
				}



				新建4.window.open.html:
				&lt;body&gt;
				这是a.com下的4.window.open.html页面
				&lt;/body&gt;

				如果我在这里，去操作父级的ＤＯＭ怎样做：
				oBtn.onclick = function(){
				//window.opener ---&gt;找到的，就是上面那个通过window.open打开我的那个页面。
				window.opener.document.body.style.background = &#x27;orange&#x27;;
				}



				上面就是经常用到的 窗口之间通讯的两种方式，而且是同域下的；
				/////////////////////////////////////////

				跨域的怎么玩？
				新建5.iframe.html
				js:
				window.onload = function(){
				var oBtn = document.getElementById(&#x27;btn&#x27;);
				var oMyIframe = document.getElementById(&#x27;myframe&#x27;);

				oBtn.onclick = function(){
				//a域名地下去访问b域名底下的html窗口页面：2.iframe.html;
				//当本页面和包含页面不在同一域名下的时候，这样操作会产生跨域操作安全限制问题
				//跨域级别的操作
				//用postMssage; 利用这个方法，给另外的窗口发送信息。 全局的。
				//怎么使用：  接受消息窗口window对象.postMessage(); 2个参数： 1：发送的数据； 2：接受数据的域名：带上协议： http://www.b.com
				oMyIframe.contentWindow.postMessage(&#x27;123&#x27;,&#x27;http://www.b.com&#x27;);
				}
				}


				&lt;body&gt;
				&lt;input type=&quot;buttom&quot; value =&quot;点击我，改变2.iframe.html的背景颜色&quot; id=&quot;btn&quot;/&gt;
				&lt;iframe id=&quot;myframe&quot; src=&quot;http://www.b.com/2.iframe.html&quot;&gt;&lt;/iframe&gt; //注意这个时候2.iframe.html是在b域名底下的。
				&lt;/body&gt;


				怎么样检测上面的成功：
				在2.iframe.html：
				js:
				message: 当窗口接受到通过postMessage发送过来的数据的时候触发。
				window.addEventListener(&#x27;message&#x27;,function(ev){
				    alert(&#x27;接收到了 &#x27;);
				    发送过来的&#x27;123&#x27;的数据在哪呢？
				    ev.data --- &gt;在这里
				    alert(ev.data)
				},false );


				注意，这个跨域的postMessage()怎么操作接受窗口的DOM
				上面只是展现了它能发送数据过去。
				是这样的：
				通过发送过来数据，对方接受到数据，进行判断，这边准备好了很多达成共识的标识，比方说1就干嘛，2就干嘛
				window.addEventListener(&#x27;message&#x27;,function(ev){
				if(ev.data == &#x27;1&#x27;){
				document.body.style.background = &#x27;red&#x27;;
				}

				ev.origin---&gt; 这个就是对方的域名
				判断一下：
				if(ev.origin == 我的){
				xxxx
				}
				},false);


				如何分别消息来源：
				如果是我发送的，那就更改，如果是别人，不管它。
				怎么做到：
				用到ev下的另一个属性
				origin


				239.http协议  浏览器和万维网服务器之间互相通信的规则
				经常打交道的，服务器之间如何进行通讯的。

				240.cmd命令目录：
				c:
				d:
				f:

				cd 文件名
				cd..



				241.
				websocket
				TCP/IP协议
				定义了电子设备如何连入因特网，以及数据在它们之间传输的标准
				传输数据类型： Emael www FTP等

				HTTP协议
				浏览器和万维网服务器之间互相通信的规则
				HTTP协议的特点：
				.功能很强大
				.采用请求、响应模式、单项通信
				.短连接，响应完成连接就断开
				比方说有一个客户端，一个服务端，用http协议进行通讯的话，
				客户端发送一个Http请求之后呢，服务端进行响应，响应完成以后， 那这一次它们之间的连接就会断掉，单次连接。
				这种模式，在做一些效果的时候，会有问题，需要进行数据实时交互的时候，可能会有问题
				而且它只能以客户端身份 发送请求到服务端，服务端响应请求。
				而不是服务端会主动推送信息到客户端。
				如果服务端有更新的话，那它是不会把更新的数据推送到客户端的。
				它是可以通过手段实现类实时链接的：
				1 服务器推送
				2 ajax轮循； 通过ajax向服务端发送一个请求，请求数据回来后，隔一段时间，发一次请求，跟服务器进行一个交互，尽可能的保证数据的实时性。服务器的压力，开销上很大。
				这种形式有问题


				提出web socket概念：
				html5的web socket ，能实现
				双向的：客户端、服务器端
				全双工： 数据的发送和接受，两者同步进行
				要去搭建web socket
				方式很多：
				服务器必须支持web socket;搭建。

				很多方式，其中前端，nodejs
				这里说前端很有名的: Nodejs
				它开发出一套 应用与服务端的语言出来
				去写服务端的东西
				Ryan Dahl基于GoogleV8引擎创建的一套过来编写高性能网络服务器的工具包
				针对服务端的编程，


				怎么去搭建一个服务器：
				不需要在阿帕奇了。
				新建文件夹—webSocket
				先去nodejs.org官网下载安装包Windows Installer (.msi)
				安装完后 开启命令行工具 运行：cmd
				输入：node 回车

				环境变量：
				%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;C:\Program Files\nodejs\

				node 的服务器，要自己写：
				server.js服务器：
				var http = require(&#x27;http&#x27;);

				var serv = http.createServer(function(req,res){

				console.log(&#x27;有人进来了&#x27;);

				}).listen(8888); //创建服务器出 //监听端口888 ：

				console.log(&#x27;服务器开启成功&#x27;);


				开启wampServer
				网页上输入： localhost:8888
				回车


				命令行工具：
				E:\wamp\www\html5\webSocket&gt;node server.js
				服务器开启成功
				有人进来了
				有人进来了



				有人进来了，干嘛呢
				服务器往客户端输出点东东：
				首先要写输出头信息：
				res.writeHeader(200,{
				&#x27;content-type&#x27; : &#x27;text/html;charset=&quot;utf-8&quot;&#x27;
				});
				res.write(&#x27;这是正文部分&#x27;);
				res.end();
				第一个参数：状态码200发送成功；
				第二个：头信息json  发送的类型，编码方式，
				写入正文
				也可以写成访问失败这样：
				res.writeHeader(404,{
				&#x27;content-type&#x27; : &#x27;text/html;charset=&quot;utf-8&quot;&#x27;
				})
				res.write(&#x27;你要访问的页面资源不存在！&#x27;);


				上面就是简单的页面输出处理，
				当然，我们不可能把要输出的内容直接写成上面这样。
				一般情况下，我们需要其他模块，比方说文件操作模块，
				去读取内容。要读取的话，我们要去分析用户请求的资源的类型。
				用户请求的东西，是在对象req这里得到的，req里面还有一个叫Url的属性；
				console.log(req.url);
				用户请求的就是我设定好的这个：
				url:&#x27;/index.html&#x27;;

				创建一个server2.js：

				//加载http模块：
				var http = require(&#x27;http&#x27;);
				var fs = require(&#x27;fs&#x27;);
				//建立目录
				var documentRoot = &#x27;E:/wamp/www/html5/webSocket/www&#x27;;

				//创建服务器：
				var httpServer = http.createSever(function(req,res){
				//设置好根目录

				var url = req.url;
				console.log(url); //得到/index.html之后怎么办呢？
				要用到files模块去读取文件：
				var file = documentRoot + url;
				console.log(file);// 输出来看看是这样的：E:/wamp/www/html5/webSocket/www/index.html

				读取文件：
				fs.readFile(file,function(err,data){

				    if(err){
				        res.writeHeader(404,{
				            &#x27;content-type&#x27; : &#x27;text/html;charset=&quot;uft-8&quot;&#x27;
				        });//输出头部信息
				        输出内容：
				        res.write(&#x27;&lt;h1&gt;404&lt;/h1&gt;&lt;p&gt;你要找的页面不存在 &lt;/p&gt;&#x27;);
				        res.end();
				    }else{
				        成功的：
				        res.writeHeader(200,{
				            &#x27;content-type&#x27; : &#x27;text/html;charset=&quot;uft-8&quot;&#x27;
				        });
				        res.write(data); //注意这里
				        res.end();
				    }
				});  //读取的文件，回调(err失败，内容)
				}).listen(8888);


				注意：这个时候在网页上输入的是： localhost:8888/index.html


				上面的是简单的http服务器的实现；


				下面说的是：
				websocket服务器创建

				如果想当前这个模块只放在当前这个应用中，写这个就可以：
				对应目录下必须要安装一个模块npm install socket.io
				它会创建一个文件夹
				命令语言下：
				E:\wamp\www\html5\webSocket npm install socket.io

				它就会安装一个模块

				我们来创建server3.js：
				var io = require(&#x27;socket.io&#x27;);
				监听：
				var socket = io.listen(httpServer);

				可以去socket.io去了解：
				socket对象下有一个sockets，监听一件事
				socket.sockets.on(&#x27;connect&#x27;,function(socket){

				console.log(&#x27;有人通过socket连接进来&#x27;);
				}); //当有A客户端通过socket请求链接进来以后，那A与服务端有一个属于自己的socket对象，就会执行这里的回调函数。把socket对象传进去；  每一个socket连接，都会有自己各自的特定的socket对象。

				输入：
				网址： localhost:8888/index.html
				----&gt;
				但是没有出现“有人通过socket连接进来”；
				这是因为，通过http服务器进来的，并不是通过socket进来的
				需要怎么做:
				我们需要在服务端链入这个js:  client.socket.js
				并写js:
				&lt;script src=&quot;client.socket.js&quot;&gt;&lt;/script&gt;
				&lt;script&gt;
				window.onload = function(){
				var oBtn = document.getElementById(&#x27;btn&#x27;);
				var socket = null;
				oBtn.onclick = function(){
				socket = io.connect(&#x27;http://localhost:8888&#x27;);
				}
				}
				&lt;/script&gt;
				点击按钮应该就有出现：“有人通过socket连接进来&quot;

				有人发送socket进来了，现在我在服务端，反应一下：

				回到服务端：
				socket.sockets.on(&#x27;connect&#x27;,function(socket){

				//console.log(&#x27;有人通过socket连接进来&#x27;);
				socket.emit(&#x27;hello&#x27;,&#x27;欢迎&#x27;); //第一个函数是事件，第二个参数是数据

				服务端这里也需要监听来自客户端的事件：
				socket.on(&#x27;hellotoo&#x27;,function(data){
				console.log(data);
				});
				});

				这个时候，客户端只需要监听一下,就能收到来自服务端的问候：
				oBtn.onclick = function(){
				socket = io.connect(&#x27;http://localhost:8888&#x27;);
				socket.on(&#x27;hello&#x27;,function(data){
				alert(data);
				客户端也可以回应服务端：
				this.emit(&#x27;hellotoo&#x27;,&#x27;欢迎欢迎&#x27;);
				})
				}



				socket.emit()----这个，是服务端往当前这个用户的socket推送事件
				比方说，如果此时正在进行的是x用户的socket，发出一条广播：
				socket.broadcast.emit(&#x27;a&#x27;);
				那就意味着，这个条广播会推送到除了当前x以外的所有用户。
				注意：在客户端也要去监听这个a，才能实现。

				可以利用这样的机制，做很多很好玩的:
				把拖拽效果在客户端做好。
				当客户端发生拖拽
				也就是在onmousemove的时候
				把left top数据发送到 服务器
				socket.emit(&#x27;move&#x27;,{
				left : oDiv.offsetLeft,
				top : oDiv.offsetTop
				})

				而服务端接监听move事件,接受到事件以后广播给其他客户端：
				socket.on(&#x27;move&#x27;,function(data){
				socekt.broadcast.emit(&#x27;move2&#x27;,data);
				})


				客户端接收到事件：
				socket.on(&#x27;move2&#x27;,function(data){
				oDiv.style.left : data.left + &#x27;px&#x27;,
				oDiv.style.top : data.top + &#x27;px&#x27;
				});


				cmd下安装这个：
				npm install socket.io
				可以设置区部用，也可以是全局的。




				242.worker  单线程问题
				什么是worker
				什么叫基于单线程？
				js就是属于单线程的
				写的很多js内容都是要在一条线上执行下去的
				单线程的特点是，一旦程序多，有可能会出现卡死的现象。
				怎么解决单线程的问题，在worker出现之前，有的用定时器解决，
				但是效果不算好。
				web workers 产生多线程
				可以同时进行多个操作
				节省时间 效率高
				使用：
				&lt;script&gt;
				var w1 = new workers(text.js);// 意味着在后台另开一条线，可以把一些程序放到这条线来
				这条线也是一个js， 新建一个js，取名text(随便)。 写进括号里去，就不是普通的js了。而是在线程里的js

				怎么样把数据，从原来的Js里拿到text.js里去：
				利用postMessage传输
				w1.postMessage(&#x27;hi&#x27;);

				接受text.js传过来的数据:
				w1.onmessage = function(ev){
				alert(ev.data)
				}

				&lt;/script&gt;


				text.js:
				接受数据：
				self.onmessage = function(ev){//监听
				alert( ev.data ); //弹不出来的
				这是因为，这个特殊的线程js，不是什么方法都认的
				下面的是它认的：
				navgator  :  appName、appVersion、userAgent、platform
				location  :   所有属性都是只读的
				self  :  指向全局 worker 对象
				所有的ECMA对象，Object、Array、Date等
				XMLHttpRequest构造器
				setTimeout和setInterval方法
				close()方法，立刻停止worker运行  -- w1.close() 计算完了关掉
				importScripts方法

				很有限，只是数据的操作，像dom操作什么的，是不允许的

				那怎么看，这货获取到数据了：
				我们再把计算后的数据再传回去：
				self.passMessage(ev.data + &#x27;妙味课堂&#x27;);
				}



				例子：
				像素显示文字，计算量

				var w1 = new Worker(&#x27;canvas.js&#x27;);

				w1.postMessage(oImg.width*oImg.height);

				w1.onmessage = function(ev){

				    var arr = ev.data;

				    for(var i=0;i&lt;arr.length;i++){

				    var color = getXY(oImg, arr[i]%w ,Math.ceil(arr[i]/w));

				        setXY( newImg , arr[i]%w ,Math.ceil(arr[i]/w), color );

				    }

				    oGC.putImageData( newImg , (oC.width - w)/2 , (oC.height - h)/2 );

				    w1.close();

				};



				canvas.js:
				importScripts(&#x27;randomArr.js&#x27;);
				self.onmessage = function(ev){

				var arr = randomArr(ev.data , ev.data/10);

				self.postMessage(arr);

				};


				randomArr.js:

				function randomArr(iAll,iNow){

				var arr = [];
				var result = [];

				for(var i=0;i&lt;iAll;i++){
				arr.push( i );
				}

				for(var i=0;i&lt;iNow;i++){
				result = result.concat( arr.splice( Math.floor(Math.random()*arr.length) ,1) );
				}

				return result;

				}


				243.离线储存
				u离线存储：
				就是在没有网时候，也可以正常去访问页面。
				只是对静态的资源存储。比如说图片，文字。
				如果你想离线的时候，进行网页的交互，肯定是做不了的。
				实现的原理：
				客户端向服务端发送请求
				服务端发送数据给客户端，同时也发送给离线应用
				当客户端第二次请求数据的时候，不走服务端，去离线应用找文件。
				不通过网络。

				乘飞机，手机信号弱，去演讲的时候，可能没有网络，这个时候，
				可以采用离线应用。

				离线存储有什么好处：
				没网的时候可以访问
				快速相应页面，不必用多个http占用资源宽带
				缓存的可以是任何文件

				现在应用的并不是特别的广，大部分网站都会有交互的功能，如果失去交互功能，就
				仅仅是展示信息了，意义就不大。

				三个步骤：
				1.到服务器端是设置头信息
				AddType text/cache-menifest .manifest
				头信息加在服务器哪里呢？
				Apche阿帕奇----&gt;httpd.conf里任意位置
				重启一下


				把服务器环境打开；
				新建：cache.html
				&lt;img src=&quot;&quot;/&gt;
				服务器开始，意味着有网，
				现在把服务器关一下：stop All servies
				刷新一次，就“无法连接”

				2.html标签加
				manifest = &quot;xxxx.manifest&quot;  //跟清单列表取得连接
				&lt;html manifest=&quot;cache.manifest&quot;&gt; //html文件的名字要中文的！
				&lt;/html&gt;

				新建文件： cache.manifest
				写好信息

				关掉服务器，刷新页面，可以找到这个图片


				FALLBACk
				style.css  style2.css
				第一个网络地址没有获取到 就走第二个缓存的
				用的少


				244.本地存储
				storage:
				本地存储：
				类似于Cookie：
				数据存到计算机中，通过浏览器控制添加与删除数据
				Cookie特点：
				存储限制：
				一个域名100个cookie，值4KB
				客户端，服务器端，都会请求服务器（头信息），就算静态页面，也会请求服务器。
				页面间的cookie是共享的


				html5提供的存储：
				storage:
				sessionStorage
				session临时回话，从页面打开到页面关闭的时间段
				窗口的临时存储，页面关闭，本地存储消失;
				localStorage
				永久存储（可以手动删除数据）

				Storage的特点
				存储量限制 ( 5M )
				客户端完成，不会请求服务器处理（性能好，只在前端完成就好了）；
				sessionStorage数据是不共享、 localStorage共享 （这个窗口的数据可以选择不影响其他页面）



				Storage API
				setItem():
				设置数据，key\value类型，类型都是字符串
				可以用获取属性的形式操作
				getItem():
				获取数据，通过key来获取到相应的value
				removeItem():
				删除数据，通过key来删除相应的value
				clear():
				删除全部存储的值


				&lt;input type=&quot;button&quot; value=&quot;设置&quot; /&gt;
				&lt;input type=&quot;button&quot; value=&quot;获取&quot; /&gt;
				&lt;input type=&quot;button&quot; value=&quot;删除&quot; /&gt;
				&lt;input type=&quot;text&quot; /&gt;

				js:
				window.onload = function(){
				var aInput = document.getElementsByTagName(&#x27;input&#x27;);
				aInput[0].onclick = function(){
				//sessionStorage : 临时性存储
				//localStorage : 永久性存储
				window.sessionStorage.setItem(&#x27;name&#x27;,aInput[3].value); //name--作为键值
				window.localStorage.setItem(&#x27;name&#x27;,aInput[3].value);
				};

				aInput[1].onclick = function(){
				//alert(window.sessionStorage.getItem(&#x27;name&#x27;));
				alert(window.localStorage.getItem(&#x27;name&#x27;));
				};
				aInput[2].onclick = function(){
				window.localStorage.removeItem(&#x27;name&#x27;);
				//window.localStorage.clear();  //删除全部数据
				};
				};



				例子 :  保存注册信息：
				上次填过的注册信息，本地保存起来：

				&lt;p&gt;
				用户名:&lt;input type=&quot;text&quot; /&gt;
				&lt;/p&gt;
				&lt;p&gt;
				性别 : &lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot; /&gt;男
				&lt;input type=&quot;radio&quot; value=&quot;女&quot; name=&quot;sex&quot; /&gt;女
				&lt;/p&gt;
				内容 :
				&lt;textarea id=&quot;t1&quot;&gt;
				&lt;/textarea&gt;

				js:
				var aInput = document.getElementsByTagName(&#x27;input&#x27;);
				var oT = document.getElementById(&#x27;t1&#x27;);

				取值：
				if(window.localStorage.getItem(&#x27;name&#x27;)){
				aInput[0].value = window.localStorage.getItem(&#x27;name&#x27;);
				}


				if(window.localStorage.getItem(&#x27;sex&#x27;)){
				for(var i=1; i&lt;aInput.length; i++){
				if(aInput[i].value == window.localStorage.getItem(&#x27;sex&#x27;)){
				        aInput[i].checked = true;
				}
				}
				}

				if( window.localStorage.getItem(&#x27;ta&#x27;)	){
				oT.value = window.localStorage.getItem(&#x27;ta&#x27;);
				}



				关闭页面是时候触发：onunload
				window.onunload = function(){
				if(aInput[0].value){
				window.localStorage.setItem(&#x27;name&#x27;,aInput[0].value);
				};

				for(var i=1; i&lt;aInput.length; i++){
				    if(aInput[i].checked == true){
				        window.localStorage.setItem(&#x27;sex&#x27;,aInput[i].value);
				    }
				}

				if(oT.value){
				window.localStorage.setItem(&#x27;ta&#x27;,aInput[0].value);
				}
				}



				本地存储还有事件：
				storage API
				存储事件:  在服务器下：localhost
				当数据有修改或删除的情况下，就会触发storage事件
				在对数据进行改变的窗口对象上是不会触发的,当前页面的事件是不会触发的。跟它共享的页面会触发。
				Key : 修改或删除的key值，如果调用clear(),key为null
				newValue  :  新设置的值，如果调用removeStorage(),key为null
				oldValue :  调用改变前的value值
				storageArea : 当前的storage对象
				url :  触发该脚本变化的文档的url
				注：session同窗口才可以,例子：iframe操作  //嵌套页面形式
				例子 :   同步购物车



				window.addEventListener(&#x27;storage&#x27;,function(ev){  //当前页面的事件不会触发
				//alert(123);

				console.log( ev.key );// name
				console.log( ev.newValue ); //hello
				console.log( ev.oldValue );// nihao
				console.log( ev.storageArea ); //对象
				console.log( ev.url ); //触发这个事件的页面

				},false);


				这个事件有什么用
				有点时候用cookie，存储数据
				但是有个弊端，页面不能同步更新;
				利用storage  实现页面的同步更新

				购物例子：
				第一个页面选择好了香蕉苹果，打开第二个页面的时候，希望那个，香蕉苹果，同样是被选中的。

				&lt;input type=&quot;checkbox&quot; value=&quot;香蕉&quot; /&gt;香蕉&lt;br /&gt;
				&lt;input type=&quot;checkbox&quot; value=&quot;苹果&quot; /&gt;苹果&lt;br /&gt;
				&lt;input type=&quot;checkbox&quot; value=&quot;西瓜&quot; /&gt;西瓜&lt;br /&gt;
				&lt;input type=&quot;checkbox&quot; value=&quot;哈密瓜&quot; /&gt;哈密瓜&lt;br /&gt;


				js:

				aInput
				for(var i=0; i&lt;aInput.length; i++){
				aInput[i].onclick = function(){
				判断选中否
				if(this.checked){
				    window.localStorage.setItem(&#x27;sel&#x27;,this.value);
				}else{
				    window.localStorage.setItem(&#x27;onSel&#x27;,this.value);
				}
				}
				}

				window.addEventListener(&#x27;storage&#x27;,function(ev){  //当前页面的事件不会触发

				if(ev.key == &#x27;sel&#x27;){
				    for(var i=0; i&lt;aInput.length; i++){
				        if( ev.newValue == aInput[i].value ){
				            aInput[i].chekced = true;
				        }
				    }
				}else if(ev.key == &#x27;onSel&#x27;){
				        for(var i=0; i&lt;aInput.length; i++){
				        if( ev.newValue == aInput[i].value ){
				            aInput[i].chekced = false;
				        }
				    }
				}
				}.false);


				245.可以在页面直接修改div里的文字
				&lt;div contenteditable= &quot;true&quot;&gt;
				abckkkk
				&lt;/div&gt;


				246.选择器
				html5网站：
				详细介绍：
				http://www.caniuse.com/#index


				选择器：

				var oDiv = document.querySelector(&#x27;#div1&#x27;);
				oDiv.style.background = &#x27;red&#x27;;
				去网址看兼容性

				var oDiv = document.querySelector(&#x27;[title=hello]&#x27;);

				var oDiv = document.querySelector(&#x27;.box&#x27;);
				如果oDiv是个集合
				获取到的是什么？
				oDiv不是一个集合
				这个方法只能选择一个元素
				只是第一个


				选择一组元素的方法：
				var aDiv = document.querySelectorAll(&#x27;.box&#x27;);


				下面这个是专门用在class的  而且不用加.

				var aDiv = document.getElements lassName(&#x27;box&#x27;)



				获取class列表属性：
				&lt;div id=&quot;div1&quot; class=&quot;box1 box2 box3&quot;&gt;div&lt;/div&gt;

				var oDiv = document.getElementById(&#x27;div1&#x27;);

				alert( oDiv.classList )
				---&gt; box1 box2 box3  属于类数组对象
				alert( oDiv.classList.length )
				----&gt; 3

				oDiv.classList.add(&#x27;box4&#x27;);

				oDiv.classList.remove(&#x27;box2&#x27;);

				oDiv.classList.toggle(&#x27;x&#x27;)
				如果x在元素class属性里本身是有的
				执行删除
				如果没有的
				进行添加

				247.随机彩票 hash
				oInput.onclick = function(){

				var num = Math.round(Math.random()*10);

				var arr = randomNum(35,7);

				json[num] = arr;

				oDiv.innerHTML = arr;

				window.location.hash = num;

				};

				window.onhashchange = function(){

				oDiv.innerHTML = json[window.location.hash.substring(1)];

				};

				function randomNum(iAll,iNow){

				var arr = [];
				var newArr = [];
				for(var i=1;i&lt;=iAll;i++){
				arr.push(i);
				}

				for(var i=0;i&lt;iNow;i++){
				newArr.push( arr.splice( Math.floor(Math.random()*arr.length) ,1) );
				}

				return newArr;

				}



				248.历史管理 pushState
				oInput.onclick = function(){

				var arr = randomNum(35,7);

				history.pushState(arr,&#x27;&#x27;,arr);

				oDiv.innerHTML = arr;

				};

				window.onpopstate = function(ev){

				oDiv.innerHTML = ev.state;

				};


				function randomNum(iAll,iNow){

				var arr = [];
				var newArr = [];
				for(var i=1;i&lt;=iAll;i++){
				arr.push(i);
				}

				for(var i=0;i&lt;iNow;i++){
				newArr.push( arr.splice( Math.floor(Math.random()*arr.length) ,1) );
				}

				return newArr;

				}

				249.拖放drag
				&lt;ul&gt;
				&lt;li draggable=&quot;true&quot;&gt;&lt;/li&gt;
				&lt;li draggable=&quot;true&quot;&gt;&lt;/li&gt;
				&lt;li draggable=&quot;true&quot;&gt;&lt;/li&gt;
				&lt;/ul&gt;
				&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;


				拖放事件：
				拖拽元素事件：
				事件对象为被拖拽的元素
				dragstart 拖拽前触发
				拖拽的一瞬间就触发了：

				dragend  拖拽结束 鼠标抬起时

				drag 有点相似于 mousemove 是连续触发的
				发生在拖拽开始与拖拽结束之间
				var n = 0;
				for(var i=0; i&lt;aLi.length; i++){
				aLi[i].ondragstart = function(){
				    this.style.background = &#x27;red&#x27;;
				}
				aLi[i].ondragend = function(){
				    this.style.background = &#x27;green&#x27;;
				}
				aLi[i].ondrag = function(){
				    document.title = n++;
				}
				}



				目标元素事件：
				事件对象为目标元素

				dragenter 进入目标元素触发 相当于mouseover

				dragover 进入目标，离开目标之间，连续触发

				dragleave离开目标元素触发，相当于mouseout

				drop 在目标元素上释放鼠标触发


				oDiv.ondragenter = function(){
				this.style.background = &#x27;red&#x27;;
				}

				oDiv.ondragleave = function(){
				this.style.background = &#x27;green&#x27;;
				}

				oDiv.ondragover = function(ev){
				document.title = n++;
				ev.preventDefault(); //阻止默认事件
				}


				鼠标抬起来的时候不会触发，怎么解决？
				要触发drag事件，必须在dragover中阻止默认事件。
				oDiv.ondrop = function(){
				alert(0);
				}



				总结：
				当drap不触发的时候：
				dragstart -&gt;drag--&gt;dragenter-&gt;dragover - &gt; dragleave-&gt; dragend;

				当drap触发的时候
				dragstart-&gt; drag-&gt;dragenter-&gt;dragover-&gt;drap-&gt;dragend

				不能释放的光标和能释放的光标不一样。





				解决火狐下的问题：
				必须设置dataTransfer对象的setData方法，才能拖拽除图片以外的其他元素。
				setData() 设置数据的，设置key和value，必须是字符串
				getData()来获取到数据，根据key值来获取到相应的value值。



				for( var i=0; i&lt;aLi.length; i++ ){
				    aLi[i].ondragstart = function(ev){
				        var ev = ev || window.event;
				        ev.dataTransfer.setData(&#x27;name&#x27;,&#x27;hello&#x27;);  // -- 现在就可以拖拽了
				        this.style.background = &#x27;red&#x27;;
				    }
				}


				dataTransfer下的其他属性：
				effectAllowed
				设置光标的样式： copy/copylink/link	/move....

				ev.dataTransfer.effectAllowed = &#x27;copy&#x27;;


				setDragImage
				这个是设置，拖动的时候，显示哪一个图片，哪一个元素
				比方说，我拖拽oLi,但是我也可以设置为div是拖拽过程中的显示图片
				而且还可以设置它的x y 轴  也就是鼠标在哪
				ev.dataTransfer.setDragImage(oDiv,0,0);

				利用这个方法我们可以做一个，百度音乐上的，拖拽音乐，鼠标右下角会


				250.拖放删除li
				for(var i=0;i&lt;aLi.length;i++){

				aLi[i].index = i;

				aLi[i].ondragstart = function(ev){

				var ev = ev || window.event;

				//ev.dataTransfer.setData(&#x27;name&#x27;,&#x27;hello&#x27;);

				ev.dataTransfer.setData(&#x27;name&#x27;,this.index);

				this.style.background = &#x27;green&#x27;;
				};

				/*aLi[i].ondrag = function(){  //开始与结束连续触发
				document.title = i++;
				};*/

				aLi[i].ondragend = function(){
				this.style.background = &#x27;yellow&#x27;;
				};
				}

				oDiv.ondragenter = function(){
				this.style.background = &#x27;blue&#x27;;
				};

				oDiv.ondragover = function(ev){
				//enter和leave之间连续触发
				//要想触发drop事件，就 必须在dragover当中阻止默认事件
				//document.title = i++;

				ev.preventDefault();

				};

				oDiv.ondragleave = function(){
				this.style.background = &#x27;red&#x27;;
				};

				oDiv.ondrop = function(ev){
				//alert(123);

				alert( ev.dataTransfer.getData(&#x27;name&#x27;) );

				oUl.removeChild( aLi[ev.dataTransfer.getData(&#x27;name&#x27;)] );

				for(var i=0;i&lt;aLi.length;i++){

				aLi[i].index = i;

				}

				};


				251.拖放，右下角 图片
				for(var i=0;i&lt;aLi.length;i++){
				aLi[i].ondragstart = function(ev){
				var ev = ev || window.event;
				ev.dataTransfer.setData(&#x27;name&#x27;,&#x27;hello&#x27;);
				ev.dataTransfer.effectAllowed = &#x27;link&#x27;;
				ev.dataTransfer.setDragImage(oImg,0,0);
				};
				aLi[i].ondragend = function(){
				this.style.background = &#x27;yellow&#x27;;
				};
				}

				oDiv.ondragenter = function(){
				this.style.background = &#x27;blue&#x27;;
				};

				oDiv.ondragover = function(ev){
				ev.preventDefault();
				};

				oDiv.ondragleave = function(){
				this.style.background = &#x27;red&#x27;;
				};

				oDiv.ondrop = function(ev){
				};


				252. 拖拽到此区域
				var oDiv = document.getElementById(&#x27;div1&#x27;);


				oDiv.ondragenter = function(){
				this.innerHTML = &#x27;可以释放啦&#x27;;
				};

				oDiv.ondragover = function(ev){
				ev.preventDefault();
				};

				oDiv.ondragleave = function(){
				this.innerHTML = &#x27;将文件拖拽到此区域&#x27;;
				};

				oDiv.ondrop = function(ev){
				ev.preventDefault();
				var fs = ev.dataTransfer.files;
				//alert(fs.length);
				//alert( fs[0].type );
				var fd = new FileReader();
				fd.readAsDataURL( fs[0] );
				fd.onload = function(){
				alert( this.result );
				};
				};
				将外部的图片拖拽进来。释放。图片打开，这个浏览器默认的行为，我们已经阻止了它的默认事件，现在不会。
				files 获取歪脖拖拽文件
				返回一个filesList列表
				filesList下有一个type属性，
				返回文件的类型。
				读取文件信息：
				FileReader是一个对象


				253.拖拽上传多张图片，显示在页面
				var oDiv = document.getElementById(&#x27;div1&#x27;);
				var oUl = document.getElementById(&#x27;ul1&#x27;);


				oDiv.ondragenter = function(){
				this.innerHTML = &#x27;可以释放啦&#x27;;
				};

				oDiv.ondragover = function(ev){
				ev.preventDefault();
				};

				oDiv.ondragleave = function(){
				this.innerHTML = &#x27;将文件拖拽到此区域&#x27;;
				};

				oDiv.ondrop = function(ev){
				ev.preventDefault();
				var fs = ev.dataTransfer.files;
				for(var i=0;i&lt;fs.length;i++){
				if(fs[i].type.indexOf(&#x27;image&#x27;)!=-1){
				    console.log(fs[0]);
				    var fd = new FileReader();
				    fd.readAsDataURL( fs[i] );
				    fd.onload = function(){
				        console.log(this.result);
				        var oLi = document.createElement(&#x27;li&#x27;);
				        var oImg = document.createElement(&#x27;img&#x27;);
				        oImg.src = this.result;
				        oLi.appendChild(oImg);
				        oUl.appendChild(oLi);
				    };
				}
				else{
				    alert(&#x27;亲，请上传图片类型&#x27;);
				}
				}
				};


				254.拖拽购物车
				html:
				&lt;li draggable=&quot;true&quot;&gt;
				&lt;img src=&quot;img1.jpg&quot; /&gt;
				&lt;p&gt;javascript语言精粹&lt;/p&gt;
				&lt;p&gt;40￥&lt;/p&gt;
				&lt;/li&gt;

				js:
				var json = {};
				var iNum = 0;
				var allMoney = null;

				for(var i=0;i&lt;aLi.length;i++){
				aLi[i].ondragstart = function(ev){

				var aP = this.getElementsByTagName(&#x27;p&#x27;);
				ev.dataTransfer.setData(&#x27;title&#x27;,aP[0].innerHTML);
				ev.dataTransfer.setData(&#x27;money&#x27;,aP[1].innerHTML);
				ev.dataTransfer.setDragImage(this,0,0);
				};
				}

				oDiv.ondragover = function(ev){
				ev.preventDefault();
				};

				oDiv.ondrop = function(ev){
				ev.preventDefault();
				var sTitle = ev.dataTransfer.getData(&#x27;title&#x27;);
				var sMoney = ev.dataTransfer.getData(&#x27;money&#x27;);
				alert(json[sTitle])
				if( !json[sTitle] ){
				var oP = document.createElement(&#x27;p&#x27;);
				var oSpan = document.createElement(&#x27;span&#x27;);
				oSpan.className = &#x27;box1&#x27;;
				oSpan.innerHTML = 1;
				oP.appendChild( oSpan );
				var oSpan = document.createElement(&#x27;span&#x27;);
				oSpan.className = &#x27;box2&#x27;;
				oSpan.innerHTML = sTitle;
				oP.appendChild( oSpan );

				var oSpan = document.createElement(&#x27;span&#x27;);
				oSpan.className = &#x27;box3&#x27;;
				oSpan.innerHTML = sMoney;
				oP.appendChild( oSpan );

				oDiv.appendChild( oP );

				json[sTitle] = 1;

				}
				else{
				var box1 = document.getElementsByClassName(&#x27;box1&#x27;);
				var box2 = document.getElementsByClassName(&#x27;box2&#x27;);
				for(var i=0;i&lt;box2.length;i++){
				    if(box2[i].innerHTML == sTitle){
				        box1[i].innerHTML = parseInt(box1[i].innerHTML) + 1;
				    }
				}
				}

				if(!allMoney){
				allMoney = document.createElement(&#x27;div&#x27;);
				allMoney.id = &#x27;allMoney&#x27;;
				}
				iNum += parseInt(sMoney);
				allMoney.innerHTML = iNum + &#x27;￥&#x27;;
				oDiv.appendChild( allMoney );
				};



				255.模块化开发：
				当网站开发越来越多，参与的人越来越多，变得越来越复杂的时候，会出现冲突和依赖，怎么解决。
				依赖是什么意思？
				开发一个公共的js，都可以用common.js
				一些方法，如果多人开发，我写了一个，人家也写了一个拖拽的方法，就会冲突。变量也是。
				怎么解决：
				1.让前缀名字变长
				例如：
				var miaov ={};
				miaov.a = 10;
				miaov.tab = function(){};
				miaov.drag = function(){};
				miaov.dialog = function(){};
				上面这样，就不会冲突了
				但是也有弊端：
				名字比较长，用起来不方便。
				只能降低冲突，不能完全避免。（别人也这样去写）

				依赖：开发内容不能全放在一个文件，应该一层层的分开。
				那一个页面中可能会出现这样情况：
				&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;
				&lt;script src=&quot;../../b.js&quot;&gt;&lt;/script&gt;
				&lt;script src=&quot;../../c.js&quot;&gt;&lt;/script&gt;
				&lt;script src=&quot;../../d.js&quot;&gt;&lt;/script&gt;
				&lt;script src=&quot;../../e.js&quot;&gt;&lt;/script&gt;
				&lt;script src=&quot;../../f.js&quot;&gt;&lt;/script&gt;
				.....

				这些的顺序，有可能会出现有依赖关系，
				就是比方说b.js必须放在c.js上面才有效。
				这样肯定出问题。特别是在多人开发的情况下。

				通过例子来说明一下：
				show.js

				同事拿去用：
				&lt;script src=&quot;../../show.js&quot;&gt;&lt;/script&gt;
				show();
				用到时候可能会发现，不执行，而且报错了。
				找到的原因是，这个js还需要依赖一个公共的js。

				这加上就好了。
				但这不是最让人抓狂的，最崩溃的是：
				比方说，后期维护的时候，需要重新开发这个show.js，开发新功能。
				开发过程中，那你又去依赖另一个js文件，这样子升级。
				这样的话，你告诉你同事，现在升级了，依赖神马的。那他需要把它很多页面都要重新加上js文件，这是很不好的。

				过了一段时间，又有需要，去更改这个show.js，比方说砍掉一些功能。
				这样有可能会出现，不再依赖其他js了。
				这个时候，又告诉同事，让它去掉依赖的js。
				去掉的时候，发现出问题了，show是不依赖了，但是还有一个文件依赖它，这样就又不能删。
				程序员为什么加班，很多时候就是遇到这些bug

				怎么解决？
				js模块化


				&lt;script a&gt;&lt;/script&gt;
				&lt;script b&gt;&lt;/script&gt;
				&lt;script c&gt;&lt;/script&gt;
				&lt;script d&gt;&lt;/script&gt;
				这些是普通模块

				我们应该加上一个库，让这个库来解决
				这个库叫做seajs库
				提升代码的可维护性
				改良的过程
				seajs.org官网

				seajs  与 jQuery
				它们之间没有关系的，针对的功能不一样
				jQuery是做实际的逻辑处理，开发  士兵
				seajs主要是进行维护的，解决冲突依赖，提高效率 后勤
				可以同时使用，不冲突


				256.seajs使用：
				&lt;script src=&quot;sea/sea.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
				&lt;script&gt;
				/*
				引入后如何使用？
				写一个独立的js文件，作为模块
				第一步：通过用define()方法，在module里执行；
				第二步：到处可以调用模块： exports（对外提供接口的对象）
				*/
				//这个页面与module没有引入的关系，怎么能用到它。
				//seajs.use  两个参数： 1，模块的地址；以sea.js这个文件的地址作为默认的根目录。 可以写成相对地址 ./  2. 加载好的回调函数
				seajs.use(&#x27;./js/module_01.js&#x27;,function(ex){
				ex.show(); // ex参数随便写的。 这里就找到了show这个方法了。
				function show(){ //同事在这里写一个函数名相同的show，并不冲突我前面的show，这里的执行就直接show();
				alert(2)
				};
				alert(&#x27;ok&#x27;);
				});

				seajs.use(&#x27;./js/module_02.js&#x27;,function(ex){
				ex.show(); //这个就是另外一个模块的，show()
				show();
				function show(){
				alert(4)
				};
				});
				&lt;/script&gt;


				257.建立依赖
				seajs.use(&#x27;./js/module_01.js&#x27;,function(ex){
				ex.show();	//不能弹出100，没有建立与module_03依赖。
				//怎么建立？
				//看Module文件

				//我这里只需要用到module_01;就可以实现，对module_03的读取，这就是靠里面的module_01去与module_03建立依赖。 因此我不用把module_03也写在这里。
				});

				module_01:

				define(function(require,exports,module){  //传递三个参数，可写可不写,最好带上。 不要修改它。
				function show(){ //把show放在define下的时候，这个函数就成为了sea下面的模块，这个模块就会防止冲突，防止依赖。 这个show跟外面的show，就没有冲突了。
				alert(3);
				require(&#x27;./module_03.js&#x27;); // 如果说引入的module_03也是一个sea下面的模块，那这里返回来的结果是什么？ 就是exports, 因此我要获得变量a的值，就可以这样：
				var a = require(&#x27;./module_03.js&#x27;).a;
				alert(a);//如果这里，我去弹出，module_03里的变量a，能弹出来吗？	不能，我在这里要建立与module_03的依赖。require(&#x27;./module_03.js&#x27;);  有了这个依赖，就可以降低开发的成本。 我写了
				};

				exports.show = show;  // 找到接口，就可以出去耍了。
				});

				function show(){
				alert(4);
				}


				module_02:

				define(function(require,exports,module){  //传递三个参数，可写可不写,最好带上。 不要修改它。
				function show(){ //把show放在define下的时候，这个函数就成为了sea下面的模块，这个模块就会防止冲突，防止依赖。 这个show跟外面的show，就没有冲突了。
				alert(1);
				};

				exports.show = show;  // 找到接口，就可以出去耍了。
				});

				function show(){
				alert(2);
				}

				module_03:
				//var a = 100;

				define(function(require,exports,module){
				var a = 100;
				exports.a = a;
				})


				258.构建工具
				构建工具：
				开发一个网站
				像百度
				右键可以看到源代码
				看到的代码
				它是本来就这样去写的呢？
				还是写完以后，经过一些处理。
				线下开发，和线上看到的是不一样的。

				公司是这样干的：
				一个是线下的区域，只能自己内部看，用户是看不见的。
				线上的区域，任何人都能看到，可能进行压缩了。

				线上 线下 各是一套流程
				如何能够线下完成很快的到线上完成呢？
				构建工具出来了：
				是个软件
				自动化操作
				线下写的东西
				通过它构建
				传到线上

				写了很多文件，合到一起，成为一个

				比较流行的：
				gruntjs
				安装流程：
				1.先安装nodeJS 和npm(包管理工具)
				2.npm install -g grunt-cli
				3.npm install grunt --save-dev
				4.grunt –version


				怎么使用：
				1.插件， 有很多， 功能很强大
				下载插件
				现在我想把webQQ的文件进行合并
				http://gruntjs.com/plugins
				在这里搜索，下载

				搜contrib  合并

				怎么引进来呢？
				我们先在webQQ里建立配置
				去这个名字：
				package.json

				写好内容

				cmd:
				进入webQQ_2
				输入npm install

				webQQ_2就有
				node_modules文件了

				怎么样实现合并呢？
				新建一个：
				Gruntfile.js

				写合并的语法

				dist/main.js
				意思是合并到这个dist文件夹里
				里面的叫main的js文件


				写好之后

				在cmd输入
				grunt

				出来的是Done,without errors.

				就生成了。



				总结一下：
				再做一个压缩的：
				搜索： contrib-uglify
				复制grunt-contrib-uglify
				粘贴到 package.json里下面任务里去，按照格式写好

				然后在cmd输入
				npm install
				然后就会生成grunt-contrib-uglify文件夹

				然后再在 Gruntfile.js里写好压缩操作：
				uglify : {
				 webqq : {
				     files : {
				         &#x27;dist/main.min.js&#x27; : [&#x27;dist/main.js&#x27;]
				     }
				 }
				}

				下面的也按照格式补上内容。


				补好以后，cmd：
				grunt
				就跑了一个压缩的任务
				生成一个min




				///////////////////////////////////////////////
				我们来看看，
				复制一个webQQ_3
				webQQ_2里面已经合并了一个，main.js
				我们把它拷到webQQ_3里面，然后用一下，看有什么问题没有
				但是发现，页面效果出不来啊
				为什么？
				因为require(&#x27;.xxx&#x27;);
				这个依赖，已经找不到了啊 合并了嘛
				怎么办？
				解决方式：
				合并操作的时候，
				define多出2个参数来，针对合并操作找地址
				第一个参数就是： 当前模块的ID
				第二个参数是： 依赖模块的数组

				回到WebQQ_3， main.js里面看怎么样写进去


				总结一下：
				开发的时候，我们还是以一个一个js模块，分开去写。
				然后通过构建工具 把它合并成一个


				259.Seajs + gruntjs开发：

				grunt 提供了很多插件
				很多就是用来 特殊的处理：
				比方说我们普通的合并或者压缩的方法
				没办法提取ID或者依赖的接口
				因此我们要借助其他的插件来开发

				我们知道seajs是采用cmd规范开发的
				我们在grunt搜索cmd
				其中有一个：
				cmd-concat
				就是cmd的合并

				我们要下载2个插件：
				cmd-concat
				cmd-transport


				我们在webQQ_04里
				都是分开的，
				然后我们希望把它们合并起来，请求一次
				1.提起ID和依赖
				2.合并
				3.做压缩处理

				package
				{
				  &quot;name&quot;: &quot;grunt_test&quot;,
				  &quot;version&quot;: &quot;1.0.0&quot;,
				  &quot;devDependencies&quot;: {
				    &quot;grunt&quot;: &quot;^0.4.5&quot;,
				    &quot;grunt-cmd-concat&quot;: &quot;^0.2.8&quot;,
				    &quot;grunt-cmd-transport&quot;: &quot;^0.5.1&quot;,
				    &quot;grunt-contrib-concat&quot;: &quot;^0.5.1&quot;,
				    &quot;grunt-contrib-cssmin&quot;: &quot;^1.0.1&quot;,
				    &quot;grunt-contrib-jshint&quot;: &quot;^1.0.0&quot;,
				    &quot;grunt-contrib-uglify&quot;: &quot;^0.11.1&quot;,
				    &quot;grunt-contrib-watch&quot;: &quot;^0.6.1&quot;
				  }
				}



				先把Gruntfile 、package.json准备好

				package.json
				{
				&quot;name&quot;: &quot;webqq&quot;,
				&quot;version&quot;: &quot;0.1.0&quot;,
				&quot;devDependencies&quot;: {
				&quot;grunt&quot; : &quot;~0.4.2&quot;,
				&quot;grunt-cmd-transport&quot; : &quot;~0.3.0&quot;,
				&quot;grunt-cmd-concat&quot; : &quot;~0.2.7&quot;,
				&quot;grunt-contrib-uglify&quot; : &quot;~0.3.2&quot;
				}
				}


				命令工具：
				进入webQQ_04下
				npm install

				然后就可以得到插件了

				然后Gruntfile写好任务
				这里改写为cmd
				grunt.loadNpmTasks(&#x27;grunt-cmd-concat&#x27;);


				写好提取依赖的任务：
				transport : {
				 webqq :{
				    files :{
				        &#x27;.build&#x27; : [&#x27;main.js&#x27;,&#x27;drag.js&#x27;,&#x27;scale.js&#x27;,&#x27;range.js&#x27;]
				    }
				 }
				}

				先屏蔽掉其他，先执行提取依赖和ID：

				然后在命令工具：
				grunt

				会生成：build文件夹
				里面的都是有依赖和ID的了。

				然后打开合并 压缩
				合并任务改一下：
				concat : {
				 webqq : {
				     files : {
				         &#x27;dist/main.js&#x27; : [&#x27;.build/main.js&#x27;,&#x27;.build/drag.js&#x27;,&#x27;.build/scale.js&#x27;,&#x27;.build/range.js&#x27;]
				     }
				 }
				},


				然后grunt 执行
				就有了main.js  main.min.js
				而且是有依赖的 有ID的


				我们来测一下，
				在webQQ_04下的index.html:
				改一下这个，用到dist里的合并后的：
				seajs.use(&#x27;./dist/main.js&#x27;);

				可以出效果了。

				而.build临时文件 已经没什么用了
				可以删掉
				可以下载插件：
				contrib-clean
				来删除



				260.模块化开发的历史：
				模块化开发能流行起来，
				是因为nodeJS的出现
				nodeJS就是用JavaScript来代替后端php传统的后端语言
				服务端，不管你用什么语言，都必须有模块化的规范
				就是commonJS规范


				做浏览器Js的模块化的有2个阵营：

				1.AMD规范
				它是全新的，跟commonJS没关系
				它有一个库
				requireJS库

				另一个阵营
				2.CMD规范
				它是commonJS升级的
				Seajs采用的就是这个规范


				261.seajs深入：
				seajs.use(&#x27;xxxx&#x27;);
				xxxxx这里可能会是很长的名字，怎么简化：

				seajs.config({

				alias : {
				m3 : &#x27;./js/module3.js&#x27;
				}

				});

				seajs.use(&#x27;m3&#x27;);


				这就是配置信息
				还有很多
				path
				config
				map
				上官网看
				有参照学习文档


				require是依赖的接口
				exports是对外提供可以访问的接口
				关于：module这个参数

				可以通过：  module.id
				是一个路径
				找到这个模块的唯一的标识

				module.uri
				模块的绝对路径

				module.dependencies
				依赖的数组


				require(&#x27;.js/module2.js&#x27;); //这是默认为同步
				require.async(&#x27;.js/module2.js&#x27;,function(){
				alert(&#x27;模块加载完的回调&#x27;)
				}); //异步的加载  意味着：当它还没有加载完的时候，它下面的是可以进行执行的。

				///////////////
				seajs的插件
				text  //当我需要 引用一个前端模版
				style //对css进行操作
				combo  //对多个文件合并
				flush
				debug
				log
				health

				怎么用?
				官网有


				相关技巧：
				怎么样用use
				引入多个模块呢
				平时是这样的：
				seajs.use(&#x27;./js/module_01.js&#x27;,function(ex){
				ex.show();
				});

				seajs.use(&#x27;./js/module_02.js&#x27;,function(ex){
				ex.show();
				});


				写成一起：
				seajs.use([&#x27;./js/module_01.js&#x27;,&#x27;./js/module_02.js&#x27;],function(ex,ex2){
				ex.show();
				ex2.show();
				});


				引入时最好加入id,性能好
				&lt;script src = &quot;sea/sea.js&quot; id =&quot;seajsnode&quot;&gt;&lt;/script&gt;


				变量
				jQuery
				什么的，加上define();
				就变成了cmd模块了
				套进去，提供接口就好了。


				线上调试：
				cache


				262.面向对象编程： 概念
				什么是面向对象编程？
				用对象的思想去写代码，就是面向对象编程。
				不是什么高深的东西
				而是一种思想
				一种写代码的方式
				一种写法
				之前的写法，叫做过程式写法。
				这个就叫做面向对象写法。

				过程式：
				function text(){}
				for(){}
				if(){}
				.....

				为什么js里有很多不同的写法？
				我们一直都在使用对象
				像数组啊
				Date();
				...
				var arr = new Array();
				arr.push();
				这就是面向对象的写法出来的。
				这里只是在使用它
				这些是系统自带的对象，叫做系统对象。
				这些对象无法满足我们。
				/////////////////////////////////////
				面向对象编程(OOP)的特点:
				也是优点：
				1.抽象，意思是抓住核心问题，就是抽取类似的对象。
				2.封装，意思就是要访问里面的方法，一定要通过对象来访问。
				3.继承，意思就是，比方说，创建2个类似对象，但是第二个有一些特别的要求要满足，而我又要建立在这个对象下来实现，而不是写一个。继承的好处，就是想办法重复利用。
				4.多态， 多对象的不同形态。也是重复利用代码

				面向对象 非常灵活 比起封装函数来，面向对象的写法更灵活，想要什么方法的时候，可以针对哪个添加方法。而且这些方法可以组合使用。 其实就是在模拟系统对象的一些行为。

				///////////////////////////////////////
				面向对象的基本写法
				有哪些组成的？
				2部分，
				1，方法 函数 过程 动态的
				2.属性  变量  状态 静态的


				263.工厂方式：
				var obj = {};
				var obj = new Object(); //创建一个空的对象 没有属性 方法
				obj.name = &#x27;小明&#x27;;
				obj.showName = function(){
				alert(this.name);// 这个this是谁？  看这个函数哪里调用？
				};

				obj.showName();  //这里调用，是obj调用的，那this就是obj
				//面向对象的难点在于 this  很重要


				var obj2 = new Object();
				obj2.name = &#x27;小强&#x27;;
				obj2.showName = function(){
				alert(this.name);
				};
				obj2.showName();

				//上面2个对象，类似的
				//我们可以进行封装
				//也就是面向对象中的封装函数
				//也叫做工厂方式

				264.面向对象 this指向
				oDiv.onclick = function(){
				this; //oDiv
				}
				oDiv.onclick = show;
				function show(){
				this; //oDiv
				}

				oDiv.onclick = function(){
				show();
				}
				function show(){
				this; //window
				}

				265.对象引用：
				&lt;script&gt;
				//对象引用
				var a = [1,2,3];
				var b = [1,2,3 ];
				alert(a == b) //false

				var a = 5;
				var b = a;
				b +=3;
				alert(b); //8
				alert(a); //5     基本类型：赋值的时候只是值的复制，b的修改没有影响到a

				var a = [1,2,3];
				var b = a;
				b.push(4);
				alert(b);// 1 2 3 4
				alert(a); // 1 2 3 4  对象类型： 赋值不仅是值的复制，而且也是引用的传递，意思就是，把a地址也给b了，那a也变成b的了   对象的话  就住在一起了

				var a = [1,2,3];
				var b = a;
				b = [1,2,3,4];
				alert(b); // 1 2 3 4
				alert(a); // 1 2 3
				//为什么这个时候a 又是1 2 3 了   因为b这里赋值了， 然后重新搬出去住了，跟a 分手了， 那跟a 没什么关系了

				//比较：
				var a = 5;
				var b = 5;
				alert(a == b ); //true  基本类型： 值相同就可以了

				var a = [1,2,3];
				var b = [1,2,3];
				alert(a == b); //false  对象类型： 值和引用相同才行； 意思是要住在一起才行，地址一样才行。

				//原型实现 true
				var a = [1,2,3];
				var b = a;
				alert(a == b); //true

				266.new拿出来、隐式返回、
				//工厂方式：就是封装函数
				function createPerson(name){
				var obj = new Object();
				obj.name = name;
				obj.showName = function(){
				alert(this.name);
				};
				return obj;
				};
				var p1 = createPerson(&#x27;小明&#x27;);
				p1.showName();
				var p2 = createPerson(&#x27;小强&#x27;);
				p2.showName();

				//为什么叫做工厂方式
				//工厂就是流水线
				// var obj  就好像原料
				// 属性 方法  就是加工的过程
				//return obj  出厂


				//我们来比较一下，写的这个跟系统对象的有什么不一样？
				var arr = new Array();
				var date = new Date();
				//2点不同
				//1.系统的 new写在外面，我的写在里面去了
				//2. 系统的 开头要大写的   我们改一下就好了 CreatePerson

				//试着把new拿出来， 但是我们面临一个问题： 不拿的时候，面向对象函数里面的this指的是谁， 我们来找到源头，是谁把createPerson函数调用的，var p1 = createPerson(&#x27;小明&#x27;);发现是window.   好的，如果我们把new拿出来，那这个时候，函数面前有一个new，那这个时候this指向的是谁？ 是创建出来的对象，而且函数的返回值就是this(隐式返回),意味着不写return obj都可以。 没有隐式会返回undefind，这里有隐式，就改成这样：
				function CreatePerson(name){
				this.name = name; //this === obj
				this.showName = function(){
				alert(this.name);
				};
				};
				var p1 =new CreatePerson(&#x27;小明&#x27;);
				var p2 =new CreatePerson(&#x27;小强&#x27;);
				p1.showName();

				//把new拿出来，可以写的更简单
				//new后面调用的函数，就是构造函数

				//有一个问题
				alert(p1.showName == p2.showName) //这里返回的是false
				//为什么
				//我们要了解一下对象引用


				//我们要最后弄成true的，因为这样意味着，它们都住在一起来。 不用占用太多的内存。
				//怎么样做到：
				//涉及到 原型：
				//就是去改写对象下面公用的方法或者属性，让公用的方法或者属性在内存中存一份就可以了，好处就是提高性能


				267.原型链：
				function CreatePerson(name){
				this.name = name;
				/*this.showName = function(){
				alert(this.name);
				};*/
				};
				CreatePerson.prototype.showName = function(){
				alert(this.name);
				}

				var p1 =new CreatePerson(&#x27;小明&#x27;);
				var p2 =new CreatePerson(&#x27;小强&#x27;);
				p1.showName();

				alert(p1.showName == p2.showName) // true 了  住一起了

				//有个问题， 属性，能不能放在原型上， 要看是不是变化的，如果是变化的属性，那肯定不能，因为原型是公用的。 公用的我们就放在原型里，不能公用了，我们就放在构造函数里。

				//总结一下：
				//面向对象的写法：
				//先写一个构造函数
				function 构造函数(){
				this.属性
				}
				构造函数.原型.方法 = function(){

				};
				var 对象1 = new 构造函数();
				对象1.方法();

				268.原则：
				1.先写出普通的写法，然后改成面向对象写法
				2.对普通方法进变型： 1.尽量不要出现函数嵌套函数； 2，可以有全局变量； 3.把onload中不是赋值的语句放到单独函数中。

				1.全局变量都是属性；
				2.函数就是方法；
				3.onload中创建对象
				4.该this指向问题  很多this  有些情况下this指向会被修改掉，什么情况下？ 事件或者定时器的时候，this很容易出问题； 我们应该尽量让面向对象中的this指向对象，统一起来。

				269.this指向：面向对象
				// this.aInput[i].onclick =this.change;
				this.aInput[i].onclick = function(){
				This.change(this); //这样就让下面的this从按钮改为对象了
				}
				}
				};
				Tag.prototype.change = function(obj){ // 这个change在哪里调用  上面  因此  这里面的this指的就是this.aInput[i]是个按钮，  因此 this.aInput.length;肯定是错了，这个按钮不是对象啊，怎么会有length属性；this.aInput[i]  this.aDiv[i] 也是有问题的 没有这些属性;; 怎么修正过来？ 把this改为指向对象
				for(var i=0; i&lt;this.aInput.length; i++){
				this.aInput[i].className = &#x27;&#x27;;
				this.aDiv[i].style.display = &#x27;&#x27;;
				}
				obj.className = &#x27;active&#x27;; //这个是对的 按钮的className
				this.aDiv[obj.index].style.display = &#x27;block&#x27;; //index是正确的


				270.原型下的方法  普通的方法
				// 原型： 去改写对象下面公用的方法或者属性，让公用的方法或者属性在内存中存在一份
				//原型：  类似 css中的class  这个是可以复用的
				// 普通方法：  类似  css中的style style是没办法复用的 一个个都要分别加上

				//  原型：prototype  要写在构造函数下面
				//普通 与 原型下的优先级：
				var arr = [];
				arr.number = 10;   // style
				Array.prototype.number = 20;     // class
				alert(arr.number) //  这个时候弹出来的是10

				271. 系统对象的方法的：
				那我们可不可以去自己实现一下 系统对象的方法的：可以的：
				var arr = [1,2,3];
				Array.prototype.push = function(){
				//this : 1,2,3
				//arguments : 4,5,6
				for(var i=0;i&lt;arguments.length;i++){
				this[this.length] = arguments[i]
				}
				return this.length;
				};
				arr.push(4,5,6);
				alert( arr );


				272.包装对象：
				&lt;!--
				包装对象：
				是什么？

				var str = &#x27;hello&#x27;;
				系统的字符串也有方法 charAt  indexOf...
				字符串不是对象啊，怎么会有方法的？
				包装对象：
				基本类型都有自己对应的包装对象
				字符串 数字 布尔值

				var str = new String(&#x27;hello&#x27;);
				alert( typeof str ); 是object
				String.prototype.charAt = function(){};


				/////////////////////////////////
				var str = &#x27;hello&#x27;;

				str.charAt(0);  为什么这里可以用字符串去调用面向对象下的方法。
				这里调用的时候，发生了这么一件事：
				基本类型字符串会找到对应的包装对象类型，然后包装对象把所有的属性和方法给了基本类型，然后包装对象消失。
				也就是str 找到String  然后String下的属性和方法给力str


				var str = &#x27;hello&#x27;;
				如果我想给这个str创建一个方法
				怎么样做？
				比方说一个找到最后字符的方法：
				写成这样：
				String.prototype.lastValue = function(){
				return this.charAt(this.length -1);
				}
				str.lastValue();

				面试题：
				var str = &#x27;hello&#x27;;  走这一个的时候没啥问题
				str.number = 10;    这里意味着，str 会去找String包装对象类型，然后创建一个属性number 赋值为1  然后包装对象消失
				alert(str.number); ?   这里的时候， 又是找到String,然后创建另一个属性number，没有赋值。String消失。 因此这里是undefined
				--&gt;


				273.属性 方法 的继承：
				&lt;!--
				继承，就是在原有对象的基础上，略作修改，得到一个新的对象，不影响原有对象的功能。
				我们可以把新的对象看作是子，而原有对象看作是父。
				继承的好处就是复用代码
				子类继承父类的一些功能。

				1.属性的继承： 调研那个父类的构造函数.call();
				2.方法的继承： for in 的形式 拷贝继承(jquery也是采用拷贝继承)
				--&gt;
				&lt;script&gt;
				function CreatePerson(name, sex){
				this.name = name;
				this.sex = sex;
				};
				CreatePerson.prototype.showName = function(){
				alert(this.name);
				}
				var p1 = new CreatePerson(&#x27;小明&#x27;,&#x27;男&#x27;);
				p1.showName();

				//再创建一个子类：
				function CreateStar(name,sex,job){
				//如果不去继承，那这样写就可以得到属性：
				//this.name = name;
				//this.sex = sex;
				this.job = job;

				//怎么用继承来复用代码
				//this.name = name this.sex = sex; 其父级是有的，我们可以继承过来，然后这里就不写了。
				//怎么继承 写成这样：
				CreatePerson.call(this,name,sex); //call的出现是因为要修正一些这里this的指向， 这个函数在这里是window调用的，但是我们不是要往window里添加属性，因此我们用call()来修正。
				this.job = job;

				};

				//把showName 继承过来
				//可以直接把父类的原型 直接 给到 子类的原型  这样，子类的原型下也有了对应的方法：
				CreateStar.prototype = CreatePerson.prototype;

				//但是这样的方法，有点问题，这里涉及到了对象的引用，就是修改了IP地址。 会影响到。 意思就是它们两现在同居了，如果我现在给子类的原型写一个方法other()， 那父类也会有了这个方法，这样，子类的继承就影响到了父类。那不符合我们继承的概念。
				CreateStar.prototype.other = function(){}
				var p2 = new CreateStar(&#x27;黄晓明&#x27;,&#x27;男&#x27;,&#x27;演员&#x27;);
				//解决方法：
				extend(CreateStar.prototype,CreatePerson.prototype);
				function extend(obj1,obj2){
				for(var attr in obj2){
				obj1[attr] = ojb2[attr];
				}
				}

				274.方法继承  不影响父级
				var a = {
				name : &#x27;小明&#x27;
				};
				var b = a; //这里就涉及到了引用关系。
				b.name = &#x27;小强&#x27;;
				alert(a.name); // 小强  影响了。


				//如何不影响？
				var a = { name : &quot;小明&quot;};
				// var b = a ; //我们想一下，这里是对象直接的赋值是会出事的，如果说，a换成基本类型呢？ 那肯定是不会影响的，朝这个方向走； 我们看能不能把 &#x27;小明&#x27;这个我所需要的字符串，给弄出来：
				var b = {};
				for(var attr in a){  //通过for in 形式
				b[attr] = a[attr];
				}
				b.name = &#x27;小强&#x27;;
				alert(a.name);


				// 我们把for in形式 封装一下：
				function extend(obj1,obj2){
				for(var attr in obj2){
				obj1[attr] = ojb2[attr];
				}
				}

				extend(b,a); // a里面的属性都给力b

				/////////////////////////////
				var a = [1,2,3]
				var b = a;
				b.push(4);
				alert(a);  //这个时候是影响到了的  1 2 3 4

				var a = [1,2,3];
				var b = a;  //  引用关系  同居了
				b = [1,2,3,4];  //  b重新被分派IP了， 引用关系断开 分居
				alert(a); //  1 2 3


				275.拷贝继承方法：实例
				window.onload = function(){
				var d1 = new Drag(&#x27;div1&#x27;);
				d1.init();

				var d11 = new ChildDrag(&#x27;div2&#x27;);
				d11.init();
				}
				function Drag(id){  //父类
				this.obj = document.getElementById(id);
				this.disX = 0;
				this.disY = 0;
				};
				Drag.prototype.init = function(){
				var This = this;
				this.obj.onmousedown = function(ev){
				var ev = ev || window.event;
				This.fnDown(ev);

				document.onmousemove = function(ev){
				var ev = ev || window.event;
				This.fnMove(ev);
				};
				document.onmouseup = function(){
				This.fnUp();
				}
				return false;
				}
				};
				Drag.prototype.fnDown = function(ev){
				this.disX = ev.clientX - this.obj.offsetLeft;
				this.disY = ev.clientY - this.obj.offsetTop	;
				}
				Drag.prototype.fnMove = function(ev){
				this.obj.style.left = ev.clientX - this.disX + &#x27;px&#x27;;
				this.obj.style.top = ev.clientY - this.disY + &#x27;px&#x27;;
				}
				Drag.prototype.fnUp = function(){
				document.onmousemove = null;
				document.onmouseup = null;
				}

				//子类的构造函数
				function ChildDrag(id){ //
				Drag.call(this,id);
				};
				extend(ChildDrag.prototype, Drag.prototype); // 完全拷贝
				// 子类要求限制范围
				ChildDrag.prototype.fnMove = function(ev){
				var L = ev.clientX - this.disX;
				var T = ev.clientY - this.disY;
				if(L &lt; 0){
				L = 0;
				}else if(L &gt; document.documentElement.clientWidth - this.obj.offsetWidth){
				L = document.documentElement.clientWidth - this.obj.offsetWidth;
				};
				if(T &lt; 0){
				T = 0;
				}else if(T &gt; document.documentElement.clientHeight - this.obj.offsetHeight){
				T = document.documentElement.clientHeight - this.obj.offsetHeight;
				}
				this.obj.style.left = L + &#x27;px&#x27;;
				this.obj.style.top = T + &#x27;px&#x27;;
				}
				function extend(obj1,obj2){
				for(var attr in obj2){
				obj1[attr] = obj2[attr];
				}
				}


				276.
				&lt;!--
				面向对象的一些属性和方法
				hasOwnProperty;  看是不是对象自身下面的属性。

				var arr = [];
				arr.num = 10;
				Array.prototype.num2 = 20;
				alert(arr.hasOwnProperty(&#x27;num&#x27;)); //true 这个num是它独有的
				alert(arr.hasOwnProperty(&#x27;num2&#x27;)); //false 原型下的，公用共享的，因此是false



				constructor;查看对象的构造函数
				function Aaa(){
				}
				var a1 =new Aaa();
				alert( a1.constructor ); //Aaa函数

				var arr = [];
				alert( arr.constructor ) //Array函数
				可以用来做判断：
				arr.constructor == Array //  true

				这个东西哪里来的呢?
				是这样的：
				当我们写出一个构造函数：
				function Aaa(){

				}
				程序会自动帮我们加上这个：
				Aaa.prototype.constructor = Aaa;


				那hasOwnProperty这个方法又是哪里来的呢？
				其实它是写在了原型链的最外层Object.prototype那里了。
				并不是它自身的，也不是它原型链的。

				我们测试一下：
				alert(a1.hasOwnProperty == Object.prototype.hasOwnProperty) //应该是true




				不要去修改constructor
				注意下面的情况：
				function Aaa(){
				}
				Aaa.prototype.name = &#x27;小明&#x27;;
				Aaa.prototype.age = 20;

				var a1 = new Aaa();
				alert( a1.constructor );  // Aaa

				如果你写成这样：
				Aaa.prototype = {
				name : &#x27;小明&#x27;,
				age :　20
				};
				var a1 = new Aaa();
				alert( a1.constructor );  //不是Aaa
				这个时候constructor就被你不经意的修改了

				如果非要这么写：我们可以这样：
				Aaa.prototype = {
				constructor : Aaa,
				name : &#x27;小明&#x27;,
				age :　20
				};



				instanceof ： 不是属性和方法， 而是运算符
				对象与构造函数在原型链上是否有关系
				function Aaa(){

				}
				var a1 = new Aaa();
				alert( a1 instanceof Aaa ); 查看实例对象a1与对象Aaa，在圆形链上是否有关系。如果是，返回true



				toString()方法
				这个方法在哪里的？

				var arr =[];
				alert(arr.toString);   可以弹出这个方法的函数

				如果我们自己写一个对象：
				function Aaa(){}
				var  a1 = new Aaa();
				alert( a1.toString  ); 也能找到这个方法
				其实所有的对象都能找到这个方法。
				是不是在最外层原型链上。我们来测一下：
				alert( a1.toString == Object.prototype.toString )
				// --true

				但是在系统对象来测试一下：
				var arr = [];
				alert( arr.toString == Object.prototype.toString ); //false

				因此：
				toString(); 系统对象下面的都是自带的，就是在自身的原型链下，自己写的对象，都是找Object.prototype原型链下面

				作用：
				把对象转成了字符串
				var arr = [];
				alert( typeof arr.toString ); //str


				这个arr是系统对象，它的toString方法在Array原型链下，因我们可以修改它。
				var arr = [1,2,3];
				Array.prototype.toString = function(){
				return this.join(&#x27;+&#x27;);//改成自己需要的
				}
				alert( arr.toString() )



				作用2
				还可以用它来，把数字转化成  多少进制的字符串：
				比方说：
				var num = 255;
				alert( num.toString(16) ); //把255转换为16进制的字符串

				作用3：
				做类型的判断，
				这个判断比较好。

				var x =[] // {} // null // num // string //。。。。
				alert( Object.prototype.toString.call(x ) );  // [object Array] // [object object] // [object number] // [object string]
				可以这样判断：
				if( Object.prototype.toString.call([]) == &#x27;[object Array]&#x27; ){
				}
				建议用这个方法做判断， 最完美。
				--&gt;

				277.面向对象 属性应用
				var cs1 = new ClickStyle();
				cs1.init({
				obj : $(&#x27;#div1&#x27;)
				});
				cs1.name = &#x27;jack&#x27;;
				var num = 352;
				console.log( cs1.hasOwnProperty(&#x27;name&#x27;) ); // name是 cs1的私有属性
				console.log( cs1.constructor == ClickStyle); // cs1的构造函数是ClickStyle
				console.log( cs1 instanceof ClickStyle ); //cs1与ClickStle 在原型上有关系
				console.log(typeof cs1.toString ); //
				console.log( num.toString(16) );// 转换为16进制的字符串
				var x = cs1;
				if( Object.prototype.toString.call(x) == &#x27;[object Object]&#x27; ){
				console.log( &#x27;x是对象&#x27; );
				};
				// [object Object]  [object OArray] [object String] [object Number]

				278.类似继承：
				其他形式的继承：
				前面学的是拷贝继承；
				这里还有2种：
				1.类式继承
				利用构造函数(类)继承的方式
				类？
				js是没有类的概念
				复杂的时候，用到了类。
				我们可以把构造函数想象成类。

				怎么去做？
				function Aaa(){ // 父类
				this.name = &#x27;小明&#x27;;
				}
				Aaa.prototype.showName = function(){
				alert(thi.name);
				}

				function Bbb(){  //子类
				}
				Bbb.prototype = new Aaa();  //这句话就是类式继承  也是引用的关系   如果问，做面向对象继承的时候，怎么样能有一句话完成继承，就是这一句话；    但是其实，这句话，是潜在着问题的： 有哪些问题？ 我们先来弹出 alert(b1.constructor); 看是不是Bbb，然而并不是，而是Aaa； 修改了地址。修改了constructor;  因此我们还需要在这里把这个修正过来：
				Bbb.prototype.constructor = Bbb;
				还有问题：
				什么问题？
				var b1 = new Bbb();
				b1.showName();

				问题在这里： 如果我修改一下：
				b1.name.push(4);
				然后我再重新建一个新对象，按理说，这个新对象不应该有push(4)的值。
				但是却存在着！
				这意味着，不可复用啊。都会牵连。
				怎么解决：总共写成这样：
				var F = function(){};
				F.prototype = Aaa.prototype;
				Bbb.prototype = new F();  // 这意味着只让方法继承过去，属性并没有。 你修改属性，没关系。
				Bbb.prototype.constructor = Bbb;
				那属性怎么继承？
				还是用拷贝继承的属性继承方式：
				function Bbb(){
				Aaa.call(this);
				}

				279.原型造型
				2.原型继承
				借助原型来实现对象继承对象。

				var a = {
				name : &quot;小明&quot;
				};

				var b = cloneObj(a);
				b.name = &#x27;小强&#x27;;
				alert(b.name);


				function cloneObj(obj){
				var F = function(){};
				F.prototype = obj;
				return newF();
				}


				拷贝继承： 通用型的  有new或无new的时候都可以
				类式继承： 适合 new构造函数
				原型继承： 无new的对象 像json


				280.原型链
				&lt;!--
				面向对象中非常重要的东西：
				原型链
				实例对象与原型之间的连接。
				啥意思?
				来一个例子：

				function Aaa(){

				};
				Aaa.prototype.num = 10
				var a1 = new Aaa();
				a1.num;  这里是可以找到10的
				我把num 放到原型下。可以找到。为什么？
				首先，Aaa.prototype就是一个对象 一个原型对象，那
				num就是它的属性。但是我们说，a1为什么能找到呢？

				我们说a1就是实例对象，而Aaa.prototype就是原型对象。
				他们俩之间的一个链接，就叫做原型链。
				它的英文名字叫做_proto_ (隐式连接)

				a1下是没有num这个属性的，找不到的。
				然后它会通过它自身所带的链，往下继续查找。Aaa.prototype
				就找到了。

				如果说我这样：
				function Aaa(){
				this.num = 20;
				}
				Aaa.prototype.num = 10;
				那找到的是多少？ 是20  为什么
				之前说过， 原型的相当于class  优先级没有 Aaa的 相当于style的高。
				这里我们就可以理解为什么优先级会比较高
				因为它是从内层一层层的往外查找的。

				这里延伸出一个问题
				这个原型链由多少层？
				反正不止2层，而最外层的是object.prototype

				我们来测一下：
				function Aaa(){

				}
				Object.prototype.num = 30;
				var a1 = new Aaa();
				alert(a1.num)  -- 30
				--&gt;



				281. angularJs:

				缓存服务：$cacheFactory
				调试服务：$log

				var m1 = angular.module(&#x27;JackApp&#x27;, []);
				    m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;, &#x27;$cacheFactory&#x27;, &#x27;$log&#x27; ,function($scope, $cacheFactory, $log){
				          var cache =  $cacheFactory(&#x27;myCache&#x27;, {capacity:2}); // 命名id  限制缓存的size长度

				            cache.put(&#x27;name&#x27;, &#x27;hello&#x27;);  // 设置信息
				            cache.put(&#x27;age&#x27;, &#x27;27&#x27;);  // 设置信息

				            console.log( cache.get(&#x27;age&#x27;) );  // 获取数据


				            console.log( cache.info() );   // 缓存的数据

				            $scope.name = cache.get(&#x27;age&#x27;);
				             console.log( cache.remove(&#x27;age&#x27;) );  // 删除数据
				            $log.log(&#x27;调试，看数据&#x27;);
				            $log.warn(&#x27;警告&#x27;);
				            $log.info(&#x27;what&#x27;);
				            // $log.error(&#x27;wrong&#x27;);
				    }]);



				282.

				$http服务 请求:

				&lt;!-- angularJs的服务： $scope 、 $watch 、 $apply 、 $rootScope 、 $timeout、 $interval
				、$filter
				$http  完成前端ajax操作的 它封装好了方法 可以方便使用  --&gt;

				var m1 = angular.module(&#x27;JackApp&#x27;,[]);
				m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;,&#x27;$http&#x27;,function($scope, $http){

				    /*$http({
				        method : &#x27;GET&#x27;,
				        url : &#x27;data.php&#x27;
				    }).success(function(data, state, headers, config){
				        console.log(data);
				        console.log(state);
				    }).error(function(data){
				        console.log(data);
				        //数据要通过JSONP转换一下
				    });*/

				    //简写方式：
				    $http.get(&#x27;data.php&#x27;)
				         .success(function(data, state, headers, config){
				            console.log(state);
				    });
				}]);

				283.

				$location服务：

				html:
				&lt;div ng-controller=&quot;Fn1&quot; id=&quot;parent&quot;&gt;
				&lt;ul&gt;
				&lt;li ng-repeat=&quot;id in [1,2,3,4,5]&quot; ng-click=&quot;change(&#x27;div&#x27;+id)&quot;&gt;{{ id }}aaaaaaaa&lt;/li&gt;
				&lt;/ul&gt;
				&lt;div ng-repeat=&quot;id in  [1,2,3,4,5]&quot; ng-attr-id=&quot;div{{ id }}&quot;&gt;{{ id }}&lt;/div&gt;
				&lt;/div&gt;

				angularJs:
				var m1 = angular.module(&#x27;JackApp&#x27;,[]);
				m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;, &#x27;$location&#x27;,&#x27;$anchorScroll&#x27;,function($scope, $location, $anchorScroll){

				    /* 1. 得到网站信息的绝对地址 */
				    var a = $location.absUrl();
				    console.log(&#x27;absUrl: &#x27;+ a );  /* 得到的是进过编码处理的了 */

				    /* 2. 设置路由方面的数据  */
				    /* 设置路径: 看网址后面是不是 自动加了#号和/   #/xyz   */
				    /* 这些设置的路径  我们通过浏览器历史管理 前进后退 发现它们还存在 */
				    /* 我们可以通过这个现象 加上路由的设置  来实现单页面的刷新跳转操作！！ */
				    /* 如果说我们不想要历史管理保存的前进后退  可以加上replace() */
				    $location.path( &#x27;aaa/bbb/ccc&#x27; );
				    // $location.path(&#x27;ddd/eee&#x27;).replace();  // 一般用不上
				    var b = $location.path();
				    console.log(&#x27;path: &#x27;+ b );

				    /* 3. 我们可以设#号后面的hash值 */
				    $location.hash(&#x27;hello&#x27;);  // 设置
				    var c = $location.hash(); // 获取
				    console.log( &#x27;hash: &#x27;+ c );

				    /* 4. 搜索的内容 设置到网址上： */
				    $location.search({ &#x27;name&#x27;: &#x27;李小龙&#x27; });
				    /* 结果：  html#/aaa/bbb/ccc?name=李小龙#hello  */

				    /*  5. 获取地址  */
				    var d  = $location.url();
				    console.log( &#x27;url: &#x27;+ d );
				    /* 结果： /aaa/bbb/ccc?name=%E6%9D%8E%E5%B0%8F%E9%BE%99#hello  */

				    /* 6.获取host */
				    var e = $location.host();
				    console.log(&#x27;host: &#x27;+ e);

				    /* 7.获取端口 */
				    var f = $location.port();
				    console.log(&#x27;port: &#x27;+ f);

				    /* 8.获取协议 */
				    var g = $location.protocol();
				    console.log(&#x27;protocol: &#x27;+ g);

				$anchorScroll：锚点服务：

				/* 9. 锚点的跳转服务： $anchorScroll 这个服务要依赖进来才能用*/
				    $scope.change = function(id){
				        console.log(id);
				        $location.hash(id);
				        $anchorScroll();    /* 手动移动  hash不变  无法跳转问题解决 */
				        /* 依赖进来了就可以了  它会根据hash的变化而滚动 */
				    };

				}]);




				284.
				$scope:
				function Aaa($scope, $rootScope){  // 形参不能修改
				alert(123);
				//它自动帮我们注入参数  也就是依赖注
				//怎么得到自己需要的参数呢？  写$scope就是局部参数
				//$rootScope就是全局参数  $xx  叫服务
				};


				285.
				angularJS:优点
				angulaJS
				基于javascript开发的客户端应用框架
				更快，更简单开发应用
				适用于CRUD应用 或者SPA单页网站开发
				桥段数据的交互

				cmd:输入  npm install angular
				可以下载好。

				优点：
				MVC模式
				模块系统
				指令系统
				依赖注入
				双向数据绑定


				286.
				angularJS的工具方法：
				//1.判断是否是数组：
				var a = [];
				console.log( angular.isArray(a) ); // true

				//2.判断是不是时间对象：
				angular.isDate();

				//3.判断一个元素是不是存在的:
				angular.isDefined();

				//4.判断元素是否不存在
				angular.isUndefined();

				//5.判断是不是函数
				angular.isFunction();

				//6.判断是不是数字
				angular.isNumber();

				//7.判断是不是对象
				angular.isObject();

				//8.判断是不是字符串
				angular.isString();

				//9.判断是不是元素
				angular.isElement();

				window.onload = function(){
				angular.isElement(document.body)// true
				};
				//它也支持jQuery下的元素：
				//  angular.isElement( $(document.body) ) // true;

				// 10. 查看angular版本
				console.log( angular.version );

				// 11.判断2个元素是否相等
				var a = 1;
				var b = 1;
				console.log( angular.equals(a,b) );
				// 这个方法 要注意一下 在原生中[] == [] 是不相等的  但这里相等
				返回的是布尔值！！！！！！

				// 12. 处理数据的时候  进行循环
				var value = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];
				angular.forEach(value,function(value, i){
				console.log( value ); // 值
				console.log( i ); // 索引
				}); //参数1是要操作的数据  2是回调

				var value2 = { &#x27;name&#x27;:&#x27;jie&#x27;, &#x27;age&#x27;:&#x27;26&#x27;};
				var result = [];
				angular.forEach(value2, function(value,key){
				console.log(&#x27;12 ：&#x27;+ value2[key]);
				console.log(&#x27;12：&#x27;+ key);
				// this --&gt;指向的就是第三个参数result 用来装输出的数据
				this.push(value2[key])
				},result);
				console.log( result );


				//13  类似json的字符串转化为真正的json  angularJs转换成json
				var str = &#x27;{&quot;name&quot;:&quot;jie&quot;}&#x27;;
				console.log(&#x27;13: &#x27;+  angular.fromJson( str ) );

				// 14  json转换为 类似json的字符串  angularJs转换成字符串
				var json = {&quot;name&quot; : &quot;jie2&quot; , &quot;age&quot; : &quot;26&quot;};
				console.log( &#x27;14: &#x27; + angular.toJson(json, true) ); // 加了true可以换行显示


				 /* 1. 处理一些默认行为  一个函数 有参数， 但是当使用者不写参数的时候，为了保证不出错，我们
				    需要有一个默认的值  angular.identity()  angular.noop();*/
				    function x(fn, value){
				        return (fn || angular.identity)(value);
				    };
				    var str = &#x27;hello&#x27;;
				    console.log( angular.identity(str) ); // hello
				    console.log( angular.noop() ); // undefined

				    /* 2. 大写小写*/
				    console.log(&#x27;2 ： &#x27;+ angular.lowercase(&#x27;HELLO，WORLD!&#x27;) );
				    console.log(&#x27;2 ： &#x27;+ angular.uppercase(&#x27;hello, world&#x27;) );

				    /* 3.  动态初始化的处理  模块启动 动态实现bootstrap   */
				    var m1 = angular.module(&#x27;myApp1&#x27;,[]);
				    var m2 = angular.module(&#x27;myApp2&#x27;,[]);
				    m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,function($scope){
				        $scope.name = &#x27;hello&#x27;;
				    }]);
				    m2.controller(&#x27;Bbb&#x27;,[&#x27;$scope&#x27;,function($scope){
				        $scope.name = &#x27;hi&#x27;;
				    }]);
				    // &lt;html ng-app=&quot;myApp&quot;&gt;改成&lt;html&gt;  我设置成点击document的时候，初始化实现：
				    //意味着我们能控制它的初始化  想要什么时候就什么时候
				    window.onload = function(){
				        /*document.onclick = function(){
				            angular.bootstrap(document, [&#x27;myApp&#x27;]); //如果是没有名字的 就空[]
				        };*/

				    //当我们页面想要多个App不同的初始化的时候，我们会想到，不同对App，写在对应的元素上不就
				    //可以了吗？ 但事实证明，这是不行的。我们这个时候可以利用这个angular.bootstrap()实现

				        var _Btn = document.getElementById(&#x27;btn&#x27;);
				        var _Div1 = document.getElementById(&#x27;div1&#x27;);
				        var _Div2 = document.getElementById(&#x27;div2&#x27;);
				        _Btn.onclick = function(){
				              angular.bootstrap(_Div1, [&quot;myApp1&quot;]);
				              angular.bootstrap(_Div2, [&quot;myApp2&quot;]);
				        };
				    };


				// 1.
				    /* angular.bind()----&gt;相似与jQuery下的$.proxy()
				    * 用来修改angularJs  this指向的。*/

				     /*function show(a, b){
				        alert(this);  //这个this 指向window
				        console.log(a+&#x27;/&#x27;+b);
				    };
				    angular.bind(document, show)(3,4); //把指向改为document  可以用来传参*/

				    // 2.angular复制对象：
				    //  angular.copy();   // 用来拷贝对象
				    var x = {
				        name : &#x27;hello&#x27;
				    };
				    var y = {
				        age : &#x27;26&#x27;
				    };

				    /*var n = angular.copy(x);
				    console.log( n );*/

				    var m = angular.copy(x, y); //2个参数 意味着： x把所有值都覆盖了y y也是一样
				    console.log( m );
				    console.log( x );
				    console.log( y );

				    var y1 = {
				        age : &#x27;36&#x27;
				    };

				    // 3. angular.extend()  angular 继承
				    var m2 = angular.extend(x, y1); //x继承了y
				    console.log(x);



				287.angularJs模块化写法
				/*模块化开发的好处，可以减少数据之间的全局的污染和冲突，
				可以做到模块之间的相互依赖*/
				/*function Aaa($scope, $rootScope){
				$scope.name = &#x27;hello&#x27;;

				};
				function Bbb($scope, $rootScope){
				$scope.name = &#x27;hi&#x27;;
				};*/
				/*Aaa() Bbb() 写在了全局里 存在这污染的可能
				怎么实现模块化处理*/
				/*写法： angular.module()2个参数 1,模块的名字；
				2，数组； 要依赖的其他模块的数据
				不需要依赖的话 创建空数组就好了 */
				var m1 = angular.module(&#x27;myApp&#x27;,[]); // m1就是一个模块了，
				// 我们要选取  哪一个作为初始的模块
				// 我们在 &lt;html ng-app&gt;这里写的， 就是选取 以哪一个模块作为初始的。
				// 我们可以写成这个的myApp：ng-app=&quot;myApp&quot;

				/*m1.controller(&#x27;Aaa&#x27;,function($scope){
				$scope.name = &#x27;hello&#x27;;
				}); // 控制器  （函数名，回调）
				m1.controller(&#x27;Bbb&#x27;,function($scope){
				$scope.name = &#x27;hi&#x27;;
				});*/

				/*上面的写法就是把2个函数写成了模块的写法。*/
				/*有一个问题：用来开发版本没问题，但是作为线上的版本就有问题，
				因为使用压缩工具 操作的时候，$scope会被压缩，简化 成别的，
				比方说$s  这样就出问题了  我们可以写成这样:*/
				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,function($scope){
				$scope.name = &#x27;hello&#x27;;
				}]);
				m1.controller(&#x27;Bbb&#x27;,[&#x27;$scope&#x27;,function($scope){
				$scope.name = &#x27;hi&#x27;;
				}]);


				288.
				angularJS 运动模块 引入
				http://cdn.bootcss.com/angular.js/1.3.8/angular-animate.min.js

				289.
				angular
				Your name: &lt;input type=&quot;text&quot; ng-model=&quot;yourname&quot; placeholder=&quot;World&quot;&gt;  &lt;!--文本输入指令&lt;input ng-model=&quot;yourname&quot; /&gt;绑定到一个叫yourname的模型变量。--&gt;
				&lt;hr&gt;
				Hello {{yourname || &#x27;World&#x27;}}!   &lt;!-- 双大括号标记将yourname模型变量添加到问候语文本 --&gt;

				&lt;!--现在试着在输入框中键入您的名称，您键入的名称将立即更新显示在问候语中。 这就是AngularJS双向数据绑定的概念。 输入框的任何更改会立即反映到模型变量（一个方向），模型变量的任何更改都会立即反映到问候语文本中（另一方向）。--&gt;
				&lt;!--模板是您用HTML和CSS编写的文件，展现应用的视图。--&gt;

				&lt;!--AngularJS通过作用域来保持数据模型与视图界面UI的双向同步。一旦模型状态发生改变，AngularJS会立即刷新反映在视图界面中，反之亦然--&gt;

				&lt;!--ng-app指令标记了AngularJS脚本的作用域，在&lt;html&gt;中添加ng-app属性即说明整个&lt;html&gt;都是AngularJS脚本作用域。开发者也可以在局部使用ng-app指令，如&lt;div ng-app&gt;，则AngularJS脚本仅在该&lt;div&gt;中运行。--&gt;


				290
				ng-show
				ng-switch 设置默认显示

				&lt;div ng-switch on=&quot;_Btn&quot;&gt;
				   &lt;p ng-switch-default&gt;默认的&lt;/p&gt;
				   &lt;p ng-switch-when=&quot;false&quot;&gt;切换的&lt;/p&gt;
				&lt;/div&gt;

				var m1 = angular.module(&#x27;myApp&#x27;,[]);
				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,function($scope){
				/* ng-show=&quot;true&quot; ng-hide=&quot;false&quot;  这两个是css里的block none的方式*/
				$scope._Btn = true;

				/* ng-if = &quot;true&quot;  这个也可以实现  这个是删除节点 添加节点的方式*/

				/* ng-switch  指定一个来默认的显示  然后通过切换 另一个显示 默认的隐藏 */

				/* ng-open 跟html5的&lt;details&gt;&lt;/details&gt;一起用  这个标签在火狐下不支持*/
				}]);


				291.过滤器：

				var m1 = angular.module(&quot;myApp&quot;,[]);
				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,function($scope){
				     $scope.str = &#x27;你给我出来~！&#x27;;
				     $scope.num = &#x27;2325&#x27;;
				     $scope.str2 = &#x27;superMan&#x27;;
				     $scope.json1 = {&quot;name&quot;:&quot;jack&quot;,&quot;sex&quot;:&quot;man&quot;,&quot;age&quot;:&quot;26&quot;,&quot;contry&quot;:&quot;China&quot;};
				     $scope.str3 = &#x27;呵呵~&#x27;;
				     $scope.arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];
				     $scope.date1 = 6939626669;
				     $scope.order1 = [
				         {&quot;num&quot;:&quot;2&quot;, &quot;str&quot;:&quot;逗逼2&quot;,},
				         {&quot;num&quot;:&quot;3&quot;, &quot;str&quot;:&quot;逗逼3&quot;,},
				         {&quot;num&quot;:&quot;1_&quot;, &quot;str&quot;:&quot;逗逼1&quot;,},
				         {&quot;num&quot;:&quot;4_&quot;, &quot;str&quot;:&quot;逗逼4&quot;,}
				     ];

				}]);
				&lt;/script&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;div ng-controller=&quot;Aaa&quot;&gt;
				&lt;p&gt;{{ str }}&lt;/p&gt;
				&lt;p&gt;{{ num | currency:&quot;￥&quot; }}&lt;/p&gt;
				&lt;p&gt;{{ num | number:1}}&lt;/p&gt;
				&lt;p&gt;{{ str2 | uppercase}}&lt;/p&gt;
				&lt;pre&gt; {{ json1 | json }} &lt;/pre&gt;  &lt;!--过滤器方便用来调试--&gt;
				&lt;p&gt;{{ str3 | limitTo:1}}&lt;/p&gt;
				&lt;p&gt;{{ arr | limitTo:2}}&lt;/p&gt;
				&lt;p&gt;{{ date1 | date:&quot;fullDate&quot;}}&lt;/p&gt;  &lt;!--有很多过滤器  可以到官网文档了解--&gt;
				&lt;p&gt;{{ order1 | orderBy : &quot;str&quot; : true }}&lt;/p&gt; &lt;!-- 排序 --&gt;
				&lt;p&gt;{{ order1 | filter : &quot;逗逼4&quot; }}&lt;/p&gt;   &lt;!--过滤Filter--&gt;
				&lt;p&gt;{{ order1 | filter : &quot;_&quot; }}&lt;/p&gt;   &lt;!--过滤Filter--&gt;
				&lt;p&gt;{{ order1 | filter : &quot;2&quot; : true }}&lt;/p&gt;   &lt;!--过滤Filter--&gt;
				&lt;p&gt;{{ str2 | limitTo : 3 | uppercase }}&lt;/p&gt;   &lt;!--过滤Filter 可以组合使用--&gt;


				292.angularJs  animation运动：
				&lt;div ng-controller=&quot;Aaa&quot;&gt;
				&lt;input type=&quot;checkbox&quot; ng-model=&quot;bBtn&quot;&gt;
				&lt;div ng-if=&quot;bBtn&quot; class=&quot;box&quot;&gt;&lt;/div&gt;
				&lt;!-- &lt;div ng-show=&quot;bBtn&quot; class=&quot;box&quot;&gt;&lt;/div&gt;--&gt;
				&lt;/div&gt;

				要引入运动模块  http://cdn.bootcss.com/angular.js/1.2.9/angular-animate.min.js

				var m1 = angular.module(&#x27;myApp&#x27;,[&#x27;ngAnimate&#x27;]);

				/*m1.animation(&#x27;.box&#x27;,function(){
				return {
				addClass : function(element,sClass,done){
				//console.log(element);
				//console.log(sClass);
				//console.log(done);
				$(element).animate({width:0,height:0},1000,done);
				},
				removeClass : function(element,sClass,done){
				$(element).css({width:0,height:0});
				$(element).animate({width:200,height:200},1000,done);
				}
				};
				});*/

				m1.animation(&#x27;.box&#x27;,function(){
				return {
				leave : function(element,done){
				//console.log(element);
				//console.log(done);
				$(element).animate({width:0,height:0},1000,done);
				},
				enter : function(element,done){
				$(element).css({width:0,height:0});
				$(element).animate({width:200,height:200},1000,done);
				}
				};
				});

				/* animation()
				enter/leave     if.....
				removeClass/addClass    show.....*/

				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,function($scope){

				$scope.bBtn = true;

				}]);


				293.ng-repeat:

				&lt;div ng-controller=&quot;Aaa&quot;&gt;
				&lt;ul&gt;
				&lt;li ng-repeat=&quot;data in dataList&quot;&gt;{{ $index }}&lt;/li&gt;
				&lt;/ul&gt;
				&lt;ul&gt;
				&lt;li ng-repeat=&quot;data in dataList&quot;&gt;{{ $first }}&lt;/li&gt;
				&lt;/ul&gt;
				&lt;ul&gt;
				&lt;li ng-repeat=&quot;data in dataList&quot;&gt;{{ $last}}&lt;/li&gt;
				&lt;/ul&gt;
				&lt;ul&gt;
				&lt;li ng-repeat=&quot;data in dataList&quot;&gt;{{ $middle}}&lt;/li&gt;
				&lt;/ul&gt;
				&lt;ul&gt;
				&lt;li ng-repeat=&quot;data in dataList&quot;&gt;{{ $even}}&lt;/li&gt;
				&lt;/ul&gt;
				&lt;ul&gt;
				&lt;li ng-repeat=&quot;data in dataList&quot;&gt;{{ $odd}}&lt;/li&gt;
				&lt;/ul&gt;

				&lt;!--隔行换色--&gt;
				&lt;ul&gt;
				&lt;li class=&quot;{{ $even ? &#x27;active&#x27; : &#x27;&#x27;  }}&quot; ng-repeat=&quot;data in dataList&quot;&gt;{{ data }}&lt;/li&gt;
				&lt;/ul&gt;


				&lt;div ng-repeat-start=&quot;data in dataList&quot;&gt;{{ data }}&lt;/div&gt;
				&lt;p&gt;{{ data }}&lt;/p&gt;
				&lt;div ng-repeat-end=&quot;data in dataList&quot;&gt;{{ data }}&lt;/div&gt;


				294.没有加controller 怎么实现数据的传递：run()
				//run();
				/* &lt;div ng-controller=&quot;Aaa&quot;&gt; 如果我不加controller控制器 js里也不创建控制器
				全局作用域怎么实现？*/
				var m1 = angular.module(&#x27;myApp&#x27;,[]);
				m1.run([&#x27;$rootScope&#x27;,function( $rootScope ){
				$rootScope.str = &#x27;不加控制器，用run方法，这段文字显示出来了没？&#x27;;
				}]);
				console.log(m1);



				295.事件指令：

				/*事件指令与js中的事件有什么区别： 原生的不支持表达式、数据变量； 而angular中
				* 可以直接写表达式、变量名*/
				/* 1. ng-selected */
				var m1 = angular.module(&#x27;myApp&#x27;,[]);
				/* 2. ng-change  */
				/* 3. ng-copy  ng-cut ng-paste  */
				/* 复制、剪切、粘贴 发生的时候 触发的 */
				/* 4.ng-disabled  可/不可点击 */
				m1.controller(&#x27;aaa&#x27;,[&#x27;$scope&#x27;,&#x27;$interval&#x27;,function($scope, $interval){
				var _Now = 5;
				$scope._BtnText = _Now + &#x27;秒&#x27;;
				$scope.isDisabled = true;

				/* 方法1：*/
				/*var timer = null;
				timer = setInterval(function(){
				    $scope.$apply(function(){
				        _Now--;
				        $scope._BtnText = _Now + &#x27;秒&#x27;;
				        if( _Now == 0 ){
				            clearInterval( timer );
				            $scope._BtnText = &#x27;立即抢购~&#x27;;
				            $scope.isDisabled = false;
				        }
				    })
				},1000);*/

				/* 方法2： */
				var timer2 = null;
				timer2 = $interval(function(){
				    _Now--;
				    $scope._BtnText = _Now + &#x27;秒&#x27;;
				    if( _Now == 0 ){
				        $interval.cancel(timer2);
				        $scope._BtnText = &#x27;立即抢购~&#x27;;
				        $scope.isDisabled = false;
				    }
				},1000);

				}]);
				/* 5.ng-readonly  也是控制能不能输入   只适用于 input-text  textarea  */
				/* 6.ng-checked  checkbox */
				/* 6.ng-valued  value={{ x }} ==》 换成这种：  ng-value = &quot;x&quot; 建议使用这种
				* {{  }}这叫做表达式  这种表达式的方式有一个不好的地方  当js还没有加载完 那页面就是显示{{ 这样的 }}*/


				296.
				服务的 初始化配置：

				var m1 = angular.module(&#x27;myApp&#x27;,[]);
				/* angular供应商provider： 服务的相关初始配置操作。 针对服务的。
				*  操作服务的初始配置， 通过供应商来完成。 注意使用方法 */

				m1.config([&#x27;$anchorScrollProvider&#x27;,function($anchorScrollProvider){

				$anchorScrollProvider.disableAutoScrolling();

				}]);
				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,&#x27;$location&#x27;,&#x27;$anchorScroll&#x27;,function($scope,$location,$anchorScroll){

				$scope.change = function(id){

				$location.hash(id);
				$anchorScroll();

				};

				}]);


				297.路由插件：&lt;script src=&quot;http://cdn.bootcss.com/angular.js/1.2.9/angular-route.min.js&quot;&gt;&lt;/script&gt;
				路由：
				m1.config([&#x27;$routeProvider&#x27;,function($routeProvider){
				    $routeProvider
				            .when(&#x27;/aaa/:num&#x27;, {  /* 有2个aaa路径的要走这里，后面分别是123 456那这里怎么区分？ ：num; 自动去匹配 */
				                templateUrl : &#x27;temp04.html&#x27;, /* 也可以url方式 */
				                controller :&#x27;Fn2&#x27;  // 绑定不一样的函数名 传过去不一样的属性值
				             })
				            .when(&#x27;/bbb&#x27;, {
				                templateUrl : &#x27;temp05.html&#x27;,
				                controller : &#x27;Fn3&#x27;
				             })
				            .when(&#x27;/ccc&#x27;, {
				                templateUrl : &#x27;temp06.html&#x27;,
				                controller : &#x27;Fn4&#x27;

				             })
				            .otherwise({
				                redirectTo : &#x27;/aaa/123&#x27;   /* 初始的hash值 */
				                //templateUrl : &#x27;temp04.html&#x27;
				            });
				    /* 刚加载完页面是没有路由的，要通过点击 才出来
				       我希望一上来就是在首页的状态，如何实现。otherwise() */
				}]);


				m1.run([&#x27;$rootScope&#x27;,function($rootScope){  // 路由相关事件

				$rootScope.$on(&#x27;$routeChangeStart&#x27;,function(event,current,pre){
				    console.log(event);
				    console.log(current);
				    console.log(pre);
				});

				}]);

				m1.controller(&#x27;Fn2&#x27;, [&#x27;$scope&#x27;,&#x27;$location&#x27;,&#x27;$routeParams&#x27;, function($scope, $location, $routeParams){
				    $scope.$location = $location;  /* 也可以用这个服务 代替href    #aaa */
				    $scope.name = &#x27;Fn2属性&#x27;;

				     /* 当我们需要通过获取到hash值的信息来做一些处理的时候：
				     要对hash传参，*/
				    // 这里怎么获得hash参数？提供了一个服务$routeParams
				    console.log( $routeParams );
				}]);
				m1.controller(&#x27;Fn3&#x27;, [&#x27;$scope&#x27;, function($scope){
				    $scope.name = &#x27;Fn3属性&#x27;;
				}]);
				m1.controller(&#x27;Fn4&#x27;, [&#x27;$scope&#x27;, function($scope){
				    $scope.name = &#x27;Fn4属性&#x27;;
				}]);


				298.angular 表格操作 搜索：
				html5:
				&lt;div ng-controller=&quot;Aaa&quot;&gt;
				&lt;input type=&quot;text&quot; ng-model=&quot;filterVal&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;搜索&quot; ng-click=&quot;fnSearch()&quot;&gt;
				&lt;table border=&quot;1&quot;&gt;
				    &lt;tr&gt;
				        &lt;th ng-click=&quot;fnSort(&#x27;name&#x27;)&quot;&gt;姓名&lt;/th&gt;
				        &lt;th ng-click=&quot;fnSort(&#x27;Tel&#x27;)&quot;&gt;电话&lt;/th&gt;
				    &lt;/tr&gt;
				    &lt;tr ng-repeat=&quot;data in dataList&quot;&gt;
				        &lt;td&gt;{{ data.name }}&lt;/td&gt;
				        &lt;td&gt;{{ data.Tel }}&lt;/td&gt;
				    &lt;/tr&gt;
				&lt;/table&gt;
				&lt;/div&gt;



				var m1 = angular.module(&#x27;myApp&#x27;,[]);
				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,&#x27;$filter&#x27;,function($scope, $filter){
				    var orilData =[
				        {&quot;name&quot;:&quot;陈先生&quot;, &quot;Tel&quot;:&quot;2&quot;},
				        {&quot;name&quot;:&quot;何先生&quot;, &quot;Tel&quot;:&quot;3&quot;},
				        {&quot;name&quot;:&quot;温女士&quot;, &quot;Tel&quot;:&quot;1&quot;},
				        {&quot;name&quot;:&quot;张女士&quot;, &quot;Tel&quot;:&quot;6&quot;},
				        {&quot;name&quot;:&quot;王女士&quot;, &quot;Tel&quot;:&quot;5&quot;},
				        {&quot;name&quot;:&quot;刘先生&quot;, &quot;Tel&quot;:&quot;4&quot;}
				    ];
				    $scope.dataList = orilData;
				     /*点击姓名 进行一个排序的操作*/
				    $scope.fnSort = function(arg){
				       //   $scope.dataList = $filter(&#x27;orderBy&#x27;)($scope.dataList, arg, true);
				          /*加了true  顺序是从大到小   false 从小到大*/

				          /*怎么实现 一反一正 来回切换 而且要陪2个不同的开关*/
				          arguments.callee[ &#x27;fnSort&#x27;+arg ] = !arguments.callee[ &#x27;fnSort&#x27;+arg ];
				          // 加上fnSort 避免与angular内部属性冲突
				          $scope.dataList = $filter(&#x27;orderBy&#x27;)($scope.dataList, arg, arguments.callee[ &#x27;fnSort&#x27;+arg ]);
				    };

				    $scope.fnSearch = function(){
				        $scope.dataList = $filter(&#x27;filter&#x27;)(orilData, $scope.filterVal);
				    };
				    /*有一个问题： 搜索过滤 全用完了 影响到了原始数据这样子  我们这样：*/
				    /*用一个变量orilData 保存一下啊  每次交互的都只是$scope.dataList*/
				}]);



				299.自定义属性指令  拖拽指令：
				&lt;div id=&quot;div1&quot; my-drag=&quot;true&quot;&gt; &lt;!-- true 在link的attr里 --&gt;
				&lt;/div&gt;


				var m1 = angular.module(&#x27;JackApp&#x27;,[]);
				m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;,function($scope){

				}]);
				/* 自定义的属性的指令 */
				m1.directive(&#x27;myDrag&#x27;,function(){
				return {
				    restrict : &#x27;A&#x27;,
				    link : function(scope, element, attr){
				        console.log(element);   /* div1 */
				        var disX = 0;
				        var disY = 0;

				        console.log(typeof attr.myDrag); // true 字符串类型 要改成布尔值
				        var _Btn = angular.equals(attr.myDrag, &#x27;true&#x27;); // 判断是否为true  返回的是布尔值
				        console.log(typeof _Btn + &#x27;:&#x27;+ _Btn);

				        element.on(&#x27;mousedown&#x27;, function(ev){
				            var _This = this;
				            disX = ev.pageX - $(this).offset().left;
				            disY = ev.pageY - $(this).offset().top;

				            if(_Btn){  // true 创建虚线框
				                var $line = $(&#x27;&lt;div&gt;&#x27;);
				                $line.css({
				                    width : $(this).outerWidth(),
				                    height : $(this).outerHeight(),
				                    position : &#x27;absolute&#x27;,
				                    left : $(this).offset().left,
				                    top : $(this).offset().top,
				                    border : &#x27;1px dashed red&#x27;
				                });
				                $(document.body).append($line);
				            };

				            $(document).on(&#x27;mousemove&#x27;, function(ev){

				                if(_Btn){ // true  虚线框跑
				                      $line.css({
				                          left : ev.pageX - disX,
				                          top : ev.pageY - disY
				                      });
				                }else{
				                    $(_This).css({
				                        left : ev.pageX - disX,
				                        top : ev.pageY - disY
				                    });
				                }

				            });
				            $(document).on(&#x27;mouseup&#x27;, function(){
				                $(this).off();
				                if(_Btn){  // true div拉过来
				                    $(_This).css({
				                          left :  $line.offset().left,
				                          top  :  $line.offset().top
				                    });
				                    $line.remove();
				                };
				            });
				            return false;
				        });
				    }
				}
				});


				300.自定义标签指令  选项卡：
				&lt;body ng-controller=&quot;Fn1&quot;&gt;
				&lt;my-tab my-id=&quot;div1&quot; my-data=&quot;data1&quot;&gt;&lt;/my-tab&gt;
				&lt;my-tab my-id=&quot;div2&quot; my-data=&quot;data2&quot; &gt;&lt;/my-tab&gt;
				&lt;/body&gt;


				var m1 = angular.module(&#x27;JackApp&#x27;, []);
				m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;,function($scope){
				    $scope.data1 = [
				        {name : &#x27;a&#x27;,  age  : &#x27;1&#x27;},
				        {name : &#x27;b&#x27;,  age  : &#x27;2&#x27;},
				        {name : &#x27;c&#x27;,  age  : &#x27;3&#x27;}
				    ];
				    $scope.data2 = [
				        {name : &#x27;d&#x27;, age : &#x27;4&#x27;},
				        {name : &#x27;e&#x27;, age : &#x27;5&#x27;},
				        {name : &#x27;f&#x27;, age : &#x27;6&#x27;}
				    ]
				}]);
				m1.directive(&#x27;myTab&#x27;,function(){
				  return{
				      restrict : &#x27;E&#x27;,
				      replace : true,
				      scope : {
				          myId : &#x27;@&#x27;,
				          myData : &#x27;=&#x27;
				      },
				      contorller : [&#x27;$scope&#x27;, function($scope){
				            $scope.str = &#x27;xxx&#x27;;
				      }],
				      templateUrl : &#x27;temp0x.html&#x27;,
				      link : function(scope, element, attr){
				               element.delegate(&#x27;input&#x27;,&#x27;click&#x27;,function(){
				                   $(element).find(&#x27;input:button&#x27;).attr(&#x27;class&#x27;,&#x27;&#x27;);
				                   $(this).attr(&#x27;class&#x27;,&#x27;active&#x27;);
				                   $(element).find(&#x27;div&#x27;).css(&#x27;display&#x27;,&#x27;none&#x27;);
				                   $(this).siblings(&#x27;div&#x27;).eq( $(this).index()).css(&#x27;display&#x27;,&#x27;block&#x27;);
				               })
				      }
				  }
				});


				temp0x.html:
				&lt;div id=&quot;{{ myId }}&quot;&gt;
				&lt;input ng-class=&quot;{active: $first}&quot; type=&quot;button&quot; ng-repeat=&quot;data in myData&quot; ng-value=&quot;data.name&quot;&gt;
				&lt;div ng-repeat=&quot;data in myData&quot; ng-style=&quot;{ display:$first? &#x27;block&#x27;: &#x27;none&#x27; }&quot;&gt;{{ data.age }}&lt;/div&gt;
				&lt;/div&gt;


				301.angular 延迟 $q服务

				m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;, &#x27;$q&#x27;, function($scope, $q){
				 var dfd = $q.defer(); //建一个延迟对象
				 function show(){
				     setTimeout(function(){
				       //  dfd.resolve();  //成功
				         dfd.reject();  //失败
				     },4000);
				     return dfd.promise;  /* 注意返回这个 */
				 };

				 show().then(function(){
				     alert(&#x27;成功后触发的函数&#x27;)
				 },function(){
				     alert(&#x27;失败后触发的函数&#x27;)
				 });

				}]);



				302.模块1 去依赖模块2 那模块1下的控制器就能用到 模块2的服务
				这个模块2 是我自己自定义的 而它的服务也是由我自定义出来的。
				模块1的控制器 是控制范围内的html结构数据的交互的， 而控制器里可以
				用到模块2的服务，也就是可以用到模块2服务下的属性和方法，但是模块2服务下的
				属性值我想重新设置一下新的值，完全可以，我们可以通过初始化设置来做到，
				对模块2进行config处理，前提是我们这个模块2的服务是通过provider的方式写出来的。

				模块1 的数据交互中，不能满足，因此通过依赖其他模块来实现借用其它模块的属性
				和方法的目的。

				&lt;script src=&quot;newSer.js&quot;&gt;&lt;/script&gt;
				&lt;script&gt;
				var m1 = angular.module(&#x27;JackApp&#x27;,[&#x27;newModule&#x27;]);
				m2.config([&#x27;newSerProvider&#x27;,function(newSerProvider){
				newSerProvider.name = &#x27;happy&#x27;;
				}]);

				m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;,&#x27;newSer&#x27;,function($scope, newSer){
				    console.log( newSer.name );
				     console.log( newSer.show() );
				}]);
				&lt;/script&gt;


				newSer.js
				var m2 = angular.module(&#x27;newModule&#x27;,[]);
				m2.provider(&#x27;newSer&#x27;,function(){
				return{
				name : &#x27;what happen&#x27;,
				$get : function(){
				        return{
				            name : this.name,
				            show : function(){
				                alert(this.name);
				                return;
				            }
				        }
				}
				}
				});


				303.angular 面向对象写法：

				&lt;div ng-controller=&quot;FnAaa as a1&quot;&gt;   /* ng-controller = &quot; FnAaa as a1 &quot; 控制器  as 下创建一个实例对象  */
				    &lt;div&gt;{{ a1.text }} {{ a1.show() }}&lt;/div&gt;
				&lt;/div&gt;


				var m2 = angular.module(&#x27;myApp&#x27;,[]);
				m2.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;, FnAaa]); //绑定一个构造函数
				function FnAaa($scope){

				};
				FnAaa.prototype.num = &#x27;34&#x27;;
				FnAaa.prototype.text = &#x27;hi&#x27;;
				FnAaa.prototype.show = function(){
				console.log( &#x27;angularJs&#x27; );
				return &#x27;Here I am&#x27;;
				};

				304.光标离开才触发：
				/* ng-model-options    光标移开的时候 才触发*/
				&lt;input type=&quot;text&quot; value=&quot;text&quot; ng-model=&quot;text&quot; ng-model-options=&quot;{updateOn : &#x27;blur&#x27;}&quot;&gt;
				&lt;p&gt;{{ text }}&lt;/p&gt;

				305.ng-include   一个标签里套进去一个html
				&lt;div ng-controller=&quot;Aaa&quot; ng-include=&quot; &#x27;test.html&#x27; &quot;&gt;
				&lt;/div&gt;


				306.angular 没解析完 解析完 问题
				ng-cloak
				&lt;div ng-cloak&gt;{{ text }}&lt;/div&gt;
				自动会在解析完后才显示


				307.angular  数据拿到html结构上  换一种方式：
				ng-bind  只有一个属性的时候：
				&lt;div ng-controller=&quot;Aaa&quot;&gt;
				&lt;div ng-bind=&quot;text&quot; &gt;&lt;/div&gt;
				&lt;/div&gt;

				ng-bind-template 多个属性的时候：
				&lt;div ng-controller=&quot;Aaa&quot; &gt;
				&lt;div ng-bind-template=&quot;{{ text }},{{ text }}&quot;&gt;&lt;/div&gt;
				&lt;/div&gt;

				308.angularJs中  html标签结构  能解析  如何做到：
				引入一个模块：
				&lt;script src=&quot;http://cdn.bootcss.com/angular.js/1.3.0-beta.13/angular-sanitize.min.js&quot;&gt;&lt;/script&gt;

				var m1 = angular.module(&#x27;myApp&#x27;,[&#x27;ngSanitize&#x27;]);
				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,function($scope){
				$scope.text = &#x27;hello&#x27;;
				]);



				309.&lt;!-- angular下的a标签指令 它的特点1:会阻止默认行为--&gt;


				310.angularJS 样式指令设置：

				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,function($scope){
				$scope.text = &#x27;hello&#x27;;

				/* 1.ng-class=&quot;{ red:true }&quot; */

				/* 2.ng-style=&quot;{ color:&#x27;#fff&#x27;, background:&#x27;red&#x27; }&quot; */
				$scope.style = &quot;{ color:&#x27;#fff&#x27;, background:&#x27;red&#x27; }&quot;;
				$scope.sClass = &quot;{ red:true, green:true }&quot;;

				/* 3.ng-href =&quot;{{ url }}&quot; 用它  一旦没解析完， 用户也看不到这样的结构*/
				$scope.url = &quot;http://www.mi.com/&quot;;

				/* 4.ng-attr-x  属性设置   */
				}])

				html:

				ng-class:
				&lt;div ng-class=&quot;{ red:true, green:true }&quot;&gt;{{ text }}&lt;/div&gt;
				ng-style:
				&lt;div ng-style=&quot;{{ style }}&quot;&gt;{{ text }}&lt;/div&gt;

				&lt;div ng-class=&quot;{{ sClass }}&quot;&gt;{{ text }}&lt;/div&gt;

				&lt;a ng-href=&quot;{{ url }}&quot;&gt;Mi&lt;/a&gt;



				311.百度搜索  淡入效果 angular JSONP $http
				&lt;input type=&quot;text&quot; ng-model=&quot;name&quot; ng-keyup=&quot;change(name)&quot;&gt;
				&lt;input type=&quot;button&quot; ng-click=&quot;change(name)&quot; value=&quot;搜索&quot;&gt;
				&lt;ul&gt;
				&lt;li class=&quot;box&quot; ng-repeat=&quot;d in dataList&quot;&gt;{{d}}&lt;/li&gt;
				&lt;/ul&gt;

				&lt;script src=&quot;http://cdn.bootcss.com/angular.js/1.3.8/angular-animate.min.js&quot;&gt;&lt;/script&gt;


				var m1 = angular.module(&#x27;myApp&#x27;,[&#x27;ngAnimate&#x27;]);
				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,&#x27;$http&#x27;,&#x27;$timeout&#x27;,function($scope,$http,$timeout){
				var timer = null;
				$scope.data = [];

				$scope.change = function(name){

				    $timeout.cancel(timer);

				    timer = $timeout(function(){

				        $http({
				            method : &#x27;JSONP&#x27;,
				            url : &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#x27;+name+&#x27;&amp;cb=JSON_CALLBACK&#x27;
				        }).success(function(data){
				            //console.log(data);
				            $scope.data = data.s;
				        });
				    },500);
				};
				}]);

				css:
				.box{ transition:1s all;}
				.box.ng-enter{ opacity:0;}
				.box.ng-enter-active{ opacity:1;}
				.box.ng-leave{ display:none;}
				.box.ng-enter-stagger{
				animation-delay : 100ms;
				}



				312.自定义指令：

				var m1 = angular.module(&#x27;JackApp&#x27;,[]);
				/* 创建自定义指令 参数1：对应的指令名字； 参数2：回调 */
				/* 怎么用？  restrict表示定义的类型 是标签指令呢还是属性指令...*/
				/* restrict ： &#x27;E&#x27; 意味着是标签指令 element嘛 &#x27;A&#x27;代表属性指令  &#x27;AE&#x27; 属性+标签指令
				*  字母一定要大写； &#x27;C&#x27;代表class相对应的指令*/
				/* template : &#x27;&lt;div&gt;制作的模版&lt;/div&gt;&#x27;  这是模版*/
				/* replace : true  意味着里面的模版替换掉父级 */
				/* 注释的写法 &#x27;M&#x27;代表 */    &lt;!-- directive:hi --&gt;
				m1.directive(&#x27;hi&#x27;,function(){
				    return {
				        restrict : &#x27;E&#x27;,
				        replace : true,   //意味着里面的模版替换掉父级
				        template : &#x27;&lt;div&gt;我的模版&lt;/div&gt;&#x27;
				    }
				});
				m1.directive(&#x27;hi2&#x27;,function(){
				    return {
				        restrict : &#x27;A&#x27;,
				        template : &#x27;&lt;div&gt;我的模版(hi2)&lt;/div&gt;&#x27;
				    }
				});
				m1.directive(&#x27;hi3&#x27;,function(){
				    return {
				        restrict : &#x27;AEC&#x27;,
				        replace : true,
				        template : &#x27;&lt;div&gt;我的模版(hi3)&lt;/div&gt;&#x27;
				    }
				});
				m1.directive(&#x27;myHi&#x27;,function(){
				    return {
				        restrict : &#x27;AEC&#x27;,
				        replace : true,
				        template : &#x27;&lt;div&gt;我的模版(myHi)&lt;/div&gt;&#x27;
				    }
				});

				m1.directive(&#x27;myTab&#x27;,function(){
				    return{
				        restrict : &#x27;E&#x27;,
				        //scope : true,
				        scope : {
				            myId : &#x27;@&#x27;,  /* @绑定的是字符串 写的是什么就是什么 */
				            myName : &#x27;=&#x27;, /* =绑定的是数据的解析 它会找对应的变量*/
				            myFn : &#x27;&amp;&#x27;  /* &amp; 绑定的是函数  要在对应的地方写上点击指令什么的才会 */
				        },
				        controller : [&#x27;$scope&#x27;, function($scope){
				            $scope.name = &#x27;数据进来了&#x27;;
				        }],   /* 共享的数据都写到这里， 独有的数据 比方说id名现在都是div1  怎么设置一个div1 一个div2
				                  通过传参的方式，把数据传进去; 在scope里写  用@ */
				        templateUrl : &#x27;temp01.html&#x27;
				    }
				});

				m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;,function($scope){
				     $scope.name = &#x27;hello&#x27;;
				     $scope.show = function(n){
				         alert(n)  /* 注意怎么样传参 */
				     }
				}]);


				&lt;hi&gt;&lt;div&gt;我的模版&lt;/div&gt;&lt;/hi&gt;
				&lt;p hi2&gt;&lt;/p&gt;
				&lt;p class=&quot;hi3&quot;&gt;&lt;/p&gt;
				&lt;hi3&gt;&lt;div&gt;我的模版(hi3)&lt;/div&gt;&lt;/hi3&gt;
				&lt;!-- directive:hi --&gt;

				&lt;my-hi&gt;&lt;div&gt;&lt;/div&gt;我的模版(myHi)&lt;/div&gt;&lt;/my-hi&gt;
				&lt;p my-hi&gt;&lt;/p&gt;
				&lt;p class=&quot;my-hi&quot;&gt;&lt;/p&gt;

				&lt;my-tab my-id=&quot;div1&quot; my-Name=&quot;name&quot; my-Fn=&quot;show(num)&quot;&gt;&lt;/my-tab&gt;
				&lt;my-tab my-id=&quot;div2&quot; my-Name=&quot;name&quot; my-Fn=&quot;show()&quot;&gt;&lt;/my-tab&gt;
				&lt;!-- 可以复用 才算指令 如果我给body加个控制器 然后 name
				在 temp01.html里能接受到吗  是可以的 现在问题来了 如果说我想该一下其中
				一个name的值 但是发现都变了。 这是因为它们的作用域是共享的。这样就不能实现
				差异性。 怎么办？ scope ： true;   这样就具有独立作用域了;  这样还是不够的，因为它
				找不到的时候还会往上找....还会受到影响，这里涉及到隔离作用域：不再跟外层作用域有任何关系
				写法： scope ：｛｝
				那怎么跟外面进行数据的交互呢？controller :［］--&gt;


				313.两个自定义标签指令 嵌套关系 的数据交互：
				&lt;hello&gt;  &lt;!-- 2个自定义指令嵌套 --&gt;
				&lt;hi&gt;

				&lt;/hi&gt;
				&lt;/hello&gt;



				    var m1 = angular.module(&#x27;JackApp&#x27;,[]);
				    m1.directive(&#x27;hello&#x27;,function(){
				          return {
				                restrict : &#x27;E&#x27;,
				                replace : true,
				                template : &#x27;&lt;div ng-transclude&gt;hello angular&lt;a ng-transclude&gt;&lt;/a&gt;&lt;/div&gt;&#x27;,
				                transclude : true ,
				                controller : function($scope){
				                    // $scope.name = &#x27;miaov&#x27;;  x
				                       this.name = &#x27;我要传数据给我里面的hi指令&#x27;;
				                }
				                /* hi的标签不见了 因为这个模版 把hello标签替换掉了，
				                 * 因此 hi标签不见了。 */

				           };
				    });
				    m1.directive(&#x27;hi&#x27;,function(){
				            return {
				                  restrict : &#x27;E&#x27;,
				                  replace : true,
				                  require : &#x27;^hello&#x27;,
				                  template : &#x27;&lt;span&gt;hi angular&lt;/span&gt;&#x27;,
				                  link  : function(scope, element, attr, reController){
				                        console.log( reController );  //要依赖的controller对象
				                        console.log( reController.name )
				                  }
				                  /* 怎么把hi标签添加到hello标签里头 不被覆盖掉
				                     给hello标签 加上 transclude：true； 然后加上新标签
				                     写上指令 让hi标签扔进去。 ng-transclude指令写在
				                     哪个元素上 哪个元素里的就被hi替换掉*/

				                  /* 这个hi指令，要接受来自hello指令的数据。如何做？
				                     hello里的controller 先有数据  这个数据要this.数据名 = 数据；
				                     这样才能拿到。 这边要接受 要写上require: &#x27;^hello&#x27; 意味着向上
				                     找hello指令 如果不加^, 意味着在hi身上找hello指令
				                     &#x27;?hello&#x27; 意思是 自身一旦找不到 不报错 只是undefined
				                     最好写成这样： &#x27;?^hello&#x27;*/

				                    /* link :  Dom操作、针对当前指令的内容的实现功能
				                       controller :  多调用同一指令的共享数据、 指令交互时扮演的是
				                       供给其它指令寻找到的数据和方法的角色。
				                      */
				             };
				    });

				314. angular 自定义服务:
				&lt;!-- filter() 自定义过滤器  directive()自定义指令
				自定义服务： 不要用$，避免污染； 依赖注入使用的时候，最好写在系统
				带的服务的后面。

				m1.factory();   用这个方法写的自定义服务  不支持 初始化配置的操作。
				m1.provider();  支持初始化配置的操作写法  稍微复杂  建议用这个
				--&gt;

				315.写一个 x-y的自定义 随机数 的服务：

				m1.provider(&#x27;myRandomNum&#x27;,function(){

				return {
				bolInt : false,
				int : function(argBol){
				if(argBol){
				this.bolInt = true;
				}
				else{
				this.bolInt = false;
				}
				},
				$get : function(){
				var This = this;
				return function(num1,num2){
				return This.bolInt ? Math.round(Math.random()*(num2 - num1)) + num1 : Math.random()*(num2 - num1) + num1;
				};
				}
				};
				});
				m1.config([&#x27;myRandomNumProvider&#x27;,function(myRandomNumProvider){

				myRandomNumProvider.int(false);

				}]);

				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,&#x27;myRandomNum&#x27;,function($scope,myRandomNum){

				console.log( myRandomNum(-3,6) );
				}]);


				316.angular 表单的验证：
				&lt;div ng-controller=&quot;Fn1&quot;&gt;
				&lt;form novalidata name=&quot;myForm&quot;&gt;
				    &lt;input type=&quot;text&quot; name=&quot;myText&quot; ng-model=&quot;text&quot; required ng-minlength=&quot;5&quot; ng-pattern=&quot;/^[a-zA-Z]+$/&quot;&gt;  &lt;!-- email等进行测试
				    得到真假值  来处理验证通过未通过情况，来处理初始非初始的情况--&gt;

				   &lt;div&gt;{{ myForm.myText.$valid }}&lt;/div&gt;
				   &lt;div&gt;{{ myForm.myText.$invalid }}&lt;/div&gt;
				   &lt;div&gt;{{ myForm.myText.$pristine }}&lt;/div&gt;
				   &lt;div&gt;{{ myForm.myText.$dirty }}&lt;/div&gt;
				   &lt;div&gt;{{ myForm.myText.$error }}&lt;/div&gt;

				   &lt;br/&gt;
				   &lt;!--&lt;input type=&quot;email&quot; name=&quot;myText&quot; ng-model=&quot;text&quot; &gt;

				   &lt;div&gt;{{ myForm.myText.$valid }}&lt;/div&gt;
				   &lt;div&gt;{{ myForm.myText.$invalid }}&lt;/div&gt;
				   &lt;div&gt;{{ myForm.myText.$pristine }}&lt;/div&gt;
				   &lt;div&gt;{{ myForm.myText.$dirty }}&lt;/div&gt;
				   &lt;div&gt;{{ myForm.myText.$error }}&lt;/div&gt;--&gt;
				&lt;/form&gt;
				&lt;/div&gt;


				css:
				input.ng-valid{ border:2px solid green;}
				input.ng-invalid{ border:1px red solid; }

				angularJs:
				var m1 = angular.module(&#x27;JackApp&#x27;,[]);
				m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;,function($scope){
				     /* $valid  有效的表达式 验证通过  这个值就是true 反之则false */
				     /* $invalid  无效的表达式 验证不通过  这个值就是true 反之则false */
				     /* $pristine  原始值 没有修改过 初始状态  这个值就是true 反之则false */
				     /* $dirty  修改过 非初始状态  这个值就是true 反之则false */
				     /* $error  不管验证通过还是失败 都会存有我们的验证信息 */
				     /* 要使用上面的  需要通过name的方式进行查找   要绑定一下ng-model
				     * 数据都要进行双向的绑定。*/
				     $scope.text = &#x27;hello&#x27;;
				    /*  angular中的class使用：
				    *   xx.ng-valid{xxx};
				    *   xx.ng-invalid{xxx};
				    *   xx.ng-pristine{xxx};
				    *   xx.ng-dirty{xxx};
				    * */
				 }]);


				317: angular 表单验证实例：
				 &lt;form novalidata name=&quot;LogForm&quot;&gt;
				   &lt;div&gt;
				       &lt;label&gt;用户名：&lt;/label&gt;
				       &lt;input type=&quot;text&quot; ng-model=&quot;regText.name&quot; name=&quot;LogText&quot; required ng-pattern=&quot;/^[a-zA-Z]+$/&quot; ng-blur=&quot;change(&#x27;regText&#x27;, LogForm.LogText.$error)&quot;&gt;
				       &lt;span ng-repeat=&quot;re in regText.regList | filter : regText.regVal&quot;&gt;{{ re.tip }}&lt;/span&gt;
				   &lt;/div&gt;

				   &lt;div&gt;
				       &lt;label&gt;密码：&lt;/label&gt;
				       &lt;input type=&quot;password&quot; ng-model=&quot;regPassword.name&quot; name=&quot;LogPassword&quot; required ng-minlength=&quot;6&quot; ng-blur=&quot;change(&#x27;regPassword&#x27;, LogForm.LogPassword.$error)&quot;&gt;

				       &lt;span ng-repeat=&quot;re in regPassword.regList | filter : regPassword.regVal&quot;&gt;{{ re.tip }}&lt;/span&gt;
				   &lt;/div&gt;
				  &lt;/form&gt;


				  html:

				var m1 = angular.module(&#x27;JackApp&#x27;,[]);
				m1.controller(&#x27;Fn1&#x27;,[&#x27;$scope&#x27;,function($scope){
				    $scope.regText = {
				      regVal : &#x27;default&#x27;,
				      regList : [
				                {name : &#x27;default&#x27;, tip : &#x27;请输入用户名&#x27;},
				                {name : &#x27;required&#x27;, tip : &#x27;用户名不能为空&#x27;},
				                {name : &#x27;pattern&#x27;, tip : &#x27;用户名必须是字母&#x27;},
				                {name : &#x27;pass&#x27;, tip : &#x27;√&#x27;}
				      ]
				    };

				    $scope.regPassword = {
				        regVal : &#x27;default&#x27;,
				        regList : [
				            { name : &#x27;default&#x27;, tip : &#x27;请输入密码&#x27;},
				            { name : &#x27;required&#x27;, tip : &#x27;密码不能为空&#x27; },
				            { name : &#x27;minLength&#x27;, tip : &#x27;密码至少6位&#x27;},
				            { name : &#x27;pass&#x27;, tip : &#x27;√&#x27;}
				        ]
				    };

				$scope.regPassword2 = {
				    regVal : &#x27;default&#x27;,
				    regList : [
				        { name : &#x27;default&#x27;, tip : &#x27;请输入密码&#x27;},
				        { name : &#x27;required&#x27;, tip : &#x27;密码不能为空&#x27; },
				        { name : &#x27;minLength&#x27;, tip : &#x27;密码至少6位&#x27;},
				        { name : &#x27;pass&#x27;, tip : &#x27;√&#x27;}
				    ]
				};

				    $scope.change = function(reg, err){

				        //console.log( $scope[reg] == $scope.regPassword2);
				        if( $scope[reg] == $scope.regPassword2 ){
				           // console.log( $(&#x27;input:password&#x27;).eq(0).val() == &#x27;&#x27; );
				            if( $(&#x27;input:password&#x27;).eq(0).val() != &#x27;&#x27; ){
				                if( $(&#x27;input:password&#x27;).eq(1).val() != $(&#x27;input:password&#x27;).eq(0).val() ){
				                        $scope.newTip = &#x27;两次密码不同&#x27;;
				                }else{
				                        $scope.newTip = &#x27;ok&#x27;;
				                }
				            }
				        }

				        for(var attr in err){
				                if( err[attr] == true ){
				                    $scope[reg].regVal = attr;
				                    return;  // 下面的就不执行了
				                }
				        };
				        $scope[reg].regVal = &#x27;pass&#x27;;
				    };
				}]);



				318: 过滤器   自定义过滤器：
				/*在Js中使用过滤器 是通过服务的方式 $scope $rootScope 这些就是服务
				* 过滤器的就是$filter*/
				var m1 = angular.module(&quot;myApp&quot;,[]);
				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,&#x27;$filter&#x27;,function($scope, $filter){
				 $scope.name = &#x27;meil&#x27;;
				 $scope.str = $filter(&#x27;uppercase&#x27;)(&#x27;whathappen&#x27;);
				 $scope.num = $filter(&#x27;number&#x27;)(&#x27;23982389&#x27;,1);  //传参
				}]);
				/*自定义控制器 是在模块下的方法filter*/
				/*我自定义一个首字母大写的方法来firstUpper*/
				m1.filter(&#x27;firstUpper&#x27;,function(){
				 return function(str, num){
				     console.log( str );
				     console.log( num );
				   return str.charAt(0).toUpperCase() + str.substring(1);
				 }
				});
				// 自定义过滤器 js中实现：
				m1.controller(&#x27;Bbb&#x27;,[&#x27;$scope&#x27;,&#x27;$filter&#x27;,function($scope, $filter){
				 $scope.str = $filter(&#x27;firstUpper&#x27;)(&#x27;what&#x27;);
				}]);


				window.onload = function(){
				 var str = [&#x27;a&#x27;];
				 console.log(typeof str.toString() );
				};


				&lt;div ng-controller=&quot;Aaa&quot;&gt;
				        &lt;p&gt;{{ name }}&lt;/p&gt;
				        &lt;p&gt;{{ str }}&lt;/p&gt;
				        &lt;p&gt;{{ num }}&lt;/p&gt;
				        &lt;p&gt;{{ name | firstUpper : 2 }}&lt;/p&gt;
				&lt;/div&gt;

				&lt;div ng-controller=&quot;Bbb&quot;&gt;
				    &lt;p&gt;{{ str }}&lt;/p&gt;
				&lt;/div&gt;


				319:路由 + resource:
				var m1 = angular.module(&#x27;myApp&#x27;,[&#x27;ngRoute&#x27;,&#x27;ngResource&#x27;]);

				m1.config([&#x27;$routeProvider&#x27;,function($routeProvider){ /* 配置一下路由 */

				$routeProvider
				 .when(&#x27;/aaa/:name&#x27;,{  //地址  点击切换地址  页面显示出来
				     template : &#x27;&lt;div&gt;{{data.name}}&lt;/div&gt;&lt;div&gt;{{data.age}}&lt;/div&gt;&lt;div&gt;{{data.job}}&lt;/div&gt;&#x27;,
				     controller : &#x27;Aaa&#x27;
				 })
				 .otherwise({  // 初始
				         redirectTo : &#x27;/aaa/zhangsan&#x27;
				 });

				}]);

				m1.controller(&#x27;Aaa&#x27;,[&#x27;$scope&#x27;,&#x27;$resource&#x27;,&#x27;$location&#x27;,&#x27;$routeParams&#x27;,function($scope,$resource,$location,$routeParams){

				$scope.$location = $location;  //挂在到$scope上

				console.log( $routeParams); // 设置好路由，可以接受到上面的参数

				if($routeParams.name){  //第一次 $routeParams 空的

				var objRe = $resource( $routeParams.name +&#x27;.json&#x27;,{},{});  //拿到参数后 请求数据

				$scope.data = objRe.get();  // 把数据挂到$scope上
				/* 成组的json对象 数组的对象 我们需要用objRe.query()来获取
				*/

				}
				}]);




				&lt;div ng-controller=&quot;Aaa&quot;&gt;
				&lt;input type=&quot;button&quot; value=&quot;张三&quot; ng-click=&quot;$location.path(&#x27;aaa/zhangsan&#x27;)&quot;&gt;  &lt;!-- 点击后通过$location来改 --&gt;
				&lt;input type=&quot;button&quot; value=&quot;李四&quot; ng-click=&quot;$location.path(&#x27;aaa/lisi&#x27;)&quot;&gt;
				&lt;div ng-view&gt;
				&lt;/div&gt;
				&lt;/div&gt;






				320: jQuery:
				toggleClass
				每一个li当点击的时候，当前这个li颜色变为red
				           $(&#x27;li&#x27;).click(function(){
				                 $(this).toggleClass(&#x27;red&#x27;);
				           });


				淡入淡出：
				        fadeOut(); 淡出   参数 : 时间
				        fadeIn(); 淡入
				        $(&#x27;#div1&#x27;).fadeOut();

				事件只执行一次：
				$(&#x27;div&#x27;).one(&#x27;click&#x27;,function(){ xxxx})   // one()  事件只执行一次


				阻止默认阻止冒泡：
				        ev.preventDefault()阻止默认事件

				        ev.stopPropagation(); 阻止冒泡操作

				          return false  阻止默认+阻止冒泡


				键值：
				    ev.which ----键值
				        类似与原生的keyCode




				alert($(window).height()); //浏览器时下窗口可视区域高度
				alert($(document).height()); //浏览器时下窗口文档的高度
				alert($(document.body).height());//浏览器时下窗口文档body的高度
				alert($(document.body).outerHeight(true));//浏览器时下窗口文档body的总高度 包括border padding margin
				alert($(window).width()); //浏览器时下窗口可视区域宽度
				alert($(document).width());//浏览器时下窗口文档对于象宽度
				alert($(document.body).width());//浏览器时下窗口文档body的高度
				alert($(document.body).outerWidth(true));//浏览器时下窗口文档body的总宽度 包括border padding margin

				alert($(document).scrollTop()); //获取滚动条到顶部的垂直高度
				alert($(document).scrollLeft()); //获取滚动条到左边的垂直宽度





				2个事件：
				        // 有滚动条：
				            // 滚动事件、窗口大小改变事件
				            $(window).on(&#x27;resize scroll&#x27;, function(){
				                    oDiv.css(&#x27;left&#x27;,( $(window).width() - oDiv.outerWidth() )/2);
				                    oDiv.css(&#x27;top&#x27;,( $(window).height() - oDiv.outerHieght() )/2 + $(window).srcollTop() );
				            })


				        $(&#x27;div&#x27;).on(&#x27;click mouseover&#x27;,function(){
				                xxxx;
				                $(&#x27;div&#x27;).off(&#x27;mouseover&#x27;);//只是取消输入的事件
				         })




				             $(&#x27;span&#x27;).insertBefore($(&#x27;div&#x27;))  把span添加到div的前面

				             $(&#x27;div&#x27;).insertAfter( $(&#x27;span&#x27;) );    div扔到span的后面

				             $(&#x27;div&#x27;).appendTo( $(&#x27;span&#x27;) ) // div加到span里  往后加

				             $(&#x27;div&#x27;).prependTo( $(&#x27;span&#x27;) )  // div加到span 里  放在前面



				             $(&#x27;span&#x27;).before($(&#x27;div&#x27;))  //span前面，放div;  后续操作对象是span





				         $(&#x27;div&#x27;).width()  // 100  不带单位

				         $(&#x27;div&#x27;).innerWidth()  //width + padding
				        $(&#x27;div&#x27;).outerWidth() // width + padding + border
				        $(&#x27;div&#x27;).outWidth(true) // .... + margin



				        我要给三个div都加id  id名分别以0 1 2 ....命名：
				        $(&#x27;div&#x27;).attr(&#x27;id&#x27;,function(arr){
				                return &#x27;id&#x27; + arr;
				        })


				                     我要判断元素里有没有对应的class：
				                    alert( $(&#x27;div&#x27;).hasClass(&#x27;box&#x27;) ) -----true/false
				                    if(	$(&#x27;div&#x27;).hasClass(&#x27;box&#x27;) ){
				                            xxxxx
				                    } else {
				                            xxxxx
				                    }




				                $(&#x27;ul li&#x27;).addClass(function( index currentClass ){
				                        var addedClass;
				                        if( currentClass === &#x27;red&#x27; ){
				                            addedClass = &#x27;orange&#x27;;
				                        }
				                        return addedClass;
				                })   ----找到特殊样式的li，给它加class


				                $(&#x27;ul li&#x27;).addClass(funciton(index){
				                 return &#x27;item&#x27; + index;
				                })  -----给每一个li加上class 分别各自索引值



				过滤选取：

				        $(&#x27;div&#x27;).filter(&#x27;.box&#x27;).css(&#x27;background&#x27;,&#x27;red&#x27;);
				排除选取：
				         $(&#x27;div&#x27;).not(&#x27;.box&#x27;).css(&#x27;background&#x27;,&#x27;red&#x27;);



				jQuery插件
				有些方法jQuery没有
				动jQuery源码有危险
				间接的--利用插件
				不会影响到jQ库

				2种：
				$.extend : 扩展工具方法下的插件形式 $.xxx()
				$.fn.extend : 扩展到JQ对象下的插件形式 $().xxx();


				//例如，自己写一个拖拽
				$.fn.extend({
				    drag : function(){
				        //注意这里的this, 指的是拖拽的对象$(&#x27;div&#x27;)
				        var disX = 0;
				        var disY = 0;
				        var that = this;
				        this.mousedown(function(ev){
				            disX = ev.pageX -$(this).offset().left;
				            disY = ev.pageY - $(this).offset().top;

				            $(document).mousemove(function( ev ){
				                that.css(&#x27;left&#x27;,&#x27;ev.pageX - disX&#x27;);
				                that.css(&#x27;top&#x27;,&#x27;ev.pageY - disY&#x27;);
				            })

				            $(document).mouseup(function(){
				                $(this).off();
				            })
				            return false;
				        })
				    }
				})
				......
				&lt;/script&gt;


				$(&#x27;div&#x27;).drag();-----&gt;  就可以用了



				$.extend({
				    xxxx : function{
				        return xxxx;
				    }
				})

				$.extend({
				    xxxx : function{
				        return xxxx;
				    }
				})



				8.jQuery里使用ajax

				$.ajax({
				    url : &#x27;xxx.php&#x27;,
				    data : &#x27;name=jack&amp;age=26,
				    type : &#x27;POST&#x27;,
				    success : function( data ){xxx},
				    error : function(){alert(&#x27;wrong&#x27;)}
				})

				jQuery官网可以了解ajax
				还有很多参数....

				还有这样的方法：
				$.get(&#x27;xxx.php?xxxxx&#x27;,{name : &#x27;hello&#x27;},function(){});  很简单 get提交
				$.post(.....)
				$.getJSON(&#x27;xxx.php?callback=fn&#x27;,function(data){
				data-----json的数据
				}) 请求json类型的数据
				这就是关于到jsonp，用来解决数据的问题

				注意：
				$.get()-----是ajax在jQuery里的一种get提交方法
				$().get()-----是把jQuery转化为原生的对象，使用。





				7.makeArray()
				把类数组转化为真正的数组

				var aDiv = document.getElementsByTagName(&#x27;div&#x27;);
				aDiv是一个集合，有下标，但不是真正的数组，不能使用数组的方法，像：
				aDiv.push(); ------&gt;报错
				可以转换：
				$.makeArray( aDiv ).push();-----&gt;不报错


				6. parseJSON()
				解析成json
				var str = &#x27;{&quot;name&quot; : &quot;jack&quot;}&#x27;  // 注意这里的是严格的json写法
				$.parseJSON( str ).name ----&gt;jack



				5.noConflict() 避免变量名冲突造成影响：
				$ ------&gt;这个不是jQuery独有的，大家都可以拿来用，因此有可能会出现相同的变量名，不同的赋予意义，造成影响代码的执行。
				怎么用？
				var $1 = $.noConflict();
				var $ = 10;
				$1(function{xxxx})
				上面，$已经是10了，因此下面的函数找不到$
				我们可以在上面声明一个新的变量，然后写成上面那样



				4.proxy()  改变this指向的

				function show(){
				alert( this );
				}
				show();
				这个时候, this指的是window
				如果我要改变,那写成这样：
				$.proxy(show,obj)(); ----这个时候，this就指向obj,注意这个时候别忘了后面的调用中括号()，不然没有调用。
				如果我要传参，可以在两个地方写入实参：
				function show( n1,n2 ){
				alert(n1);
				alert(n2);
				alert(this);
				};
				$.proxy(show,obj)(3,4);	$(document).click($.proxy(show,obj,3,4))



				3. inArray() 类似于字符串的indexof方法
				  去找它们的位置 只不过这个是给数组用的

				  var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];
				  $.inArray(&#x27;b&#x27;,arr); ----&gt;在arr数组里找b，如果有，会弹出1； 如果没有找到，弹出-1；



				2.trim() 去掉字符串里的空格
				  var str = &#x27;  hi  &#x27;;
				  $.trim( str ); ----&gt; 弹出的没有空格



				1.type
				  $.type() ---&gt;判断类型
				  $.type( a ) ----&gt;判断a
				  这个判断很强大
				  原生的判断 typeof x
				  区分非常有限，很多都是弹出----object
				  无法进一步具体判断
				  而这个工具方法
				  $.type( a )-----string、array、......


				工具方法：
				  $().css()...$().html()...$().val()
				  上面的这一派只能给JQ 对象用

				  还有一派：
				  $.xxx()
				  $.yyy()
				  这个不仅可以给JQ用，也可以给原生JS用
				  统一把这个叫做工具方法！



				5,trigger主动触发
				      $(&#x27;obj&#x27;).on(&#x27;click&#x27;,function(){xxx})
				      上面的函数，只有在点击的时候才会触发
				      如果我想一上来就触发，或者在别的时候任意我希望的地方触发，可以这样写：
				      $(&#x27;obj&#x27;).trigger(&#x27;click&#x27;);

				      调用很方便，
				      对于自定义事件，非常好用：
				      $(&#x27;obj&#x27;).on(&#x27;xxx&#x27;,funtion(){xxxxx})j
				      $(&#x27;obj&#x27;).trigger(&#x27;xxx&#x27;)



				      6.事件细节
				      ev.data  事件数据
				      ev.target  事件流
				      ev.type 事件类型
				      $(&#x27;#div2&#x27;).on(&#x27;click&#x27;,{abc : &#x27;123&#x27;},function( ev ){
				              alert( ev.data.abc )---&gt;123//	可以实现往事件里送参数
				              alert( ev.target )——————&gt;弹出是谁的事件
				              alert( ev.type ) ----&gt;弹出click

				      })



				事件委托
				先前的用法：
				$(&#x27;li&#x27;).on(&#x27;click&#x27;,function(){xxx})
				把事件加到每一个li上

				这里的是：
				$(&#x27;ul&#x27;).delegate(&#x27;li&#x27;,&#x27;click&#x27;,function(){xxxxx})
				把事件给到了ul身上，利用冒泡的原理实现。

				事件委托的好处：
				    1，省略了循环，提高性能
				    2，往ul里添加新的li节点的时候，不用考虑这个节点有没有事件，因为都在ul上


				阻止事件委托：
				$(&#x27;ul&#x27;).underlegate();





				3. delay();
				    延迟
				    $(this).animate({width : 300},200).delay(1000).animate({height : 300},2000)
				    先走完宽，停顿一秒，再往下走高


				2.stop(); 停止运动
				默认只会阻止当前的运动

				如何把所有的运动阻止掉
				参数1：加上true
				阻止后续的运动
				$(&#x27;obj&#x27;).stop(true)
				参数2：也是true
				可立即停止到当前运动指定的目标点
				后续的运动，不会停到其目标点
				如何实现立即停止到所有指定的目标点
				$(&#x27;obj&#x27;).finish();




				serialize()  把表单信息用&amp;串联起来，方便提交到后端处理

				$(&#x27;form&#x27;).serialize()----&gt;  a=1&amp;b=2&amp;c=3

				$(&#x27;fomr&#x27;).serializeArray() ----&gt; 数组： 每一个数组是一个类对象




				slice() 我要选li中的下标： 1-3个
				$(&#x27;li&#x27;).slice(1,4)




				wrap(); 包装
				比方说我要给所有的span都包装一个div
				$(&#x27;span&#x27;).wrap(&#x27;&lt;div&gt;&#x27;)


				wrapAll(); 整体包装
				$(&#x27;#content&#x27;).wrapAll(&#x27;&lt;div&gt;&#x27;);
				注意： 如果整体包装时，发现里面的结构，有些不是它要包装的元素，那它会把不是的放到下面，然后包装


				wrapInter();内部包装
				$(&#x27;span&#x27;).wrapInter(&#x27;&lt;div&gt;&#x27;)

				upwrap();  删除包装（父级），不包括body
				$(&#x27;span&#x27;).unwrap();




				clone() :
				  复制一个div，扔到span里
				    $(&#x27;div&#x27;).clone().appendTo($(&#x27;span&#x27;))
				  可以传一个参数:true  操作行为也加上
				      比方说原版的div有点击事件
				    $(&#x27;div&#x27;).clone(true).appendTo($(&#x27;span&#x27;))
				    克隆出来的也会有



				parents() :
				获取该元素的祖先节点---集合
				$(&#x27;#div1&#x27;).parents().css(x,x)
				有个参数---筛选的作用
				$(&#x27;#div1&#x27;).parents(&#x27;body&#x27;)

				closest()  :
				获取最近的指定的祖先节点，包括当前元素自身，必须写筛选的参数。只能找到一个元素




				siblings() ：
				 获取的是，当前元素的，所有的兄弟节点的集合
				 可以输入参数，进行筛选

				 $(&#x27;span&#x27;).siblings().css();
				 $(&#x27;span&#x27;).siblings(&#x27;strong&#x27;).css();



				nextAll() :
				    找下面所有的兄弟节点

				prevAll() :
				    找上面所有的兄弟节点


				nextUntil() :
				    截至到哪里的意思
				    $(&#x27;span&#x27;).nextUntil(&#x27;em&#x27;)
				    span ----- em  之间的元素节点





				remove() : 删除节点  $(&#x27;div&#x27;).remove();
				   返回值，就是删除的对象；
				   有时候还需要用到这个被删掉的元素节点
				   因此，我们可以保存一下
				   var oDiv = $(&#x27;div&#x27;).remove();
				   删除之后，再添加回来
				   关于它的事件都没有效果的。


				detach() : 删除节点
				   再添加回来
				   会保留被删元素的操作行为。




				outerWidth();------&gt; 宽度 + padding + 边框
				outerWidth(true);----&gt;再加上margin值

				原生的offsetWidth  ----相似---  jQuery的 outerWidth()
				区别：
				原生	： $(&#x27;#div1&#x27;).get(0).offsetWidth
				   如果我把div隐藏了，会发现找不到div的宽度
				jQuert:  $(&#x27;#div1&#x27;).outerWidth();
				    隐藏了，仍然能获取到





				拖拽至网格：
				html:
				&lt;div class=&quot;table&quot;&gt;
				&lt;table&gt;
				&lt;tbody&gt;
				&lt;tr&gt;
				&lt;/tr&gt;
				&lt;/tbody&gt;
				&lt;/table&gt;
				&lt;div class=&quot;red&quot;&gt;
				&lt;/div&gt;

				css:
				*{
				padding:0;
				margin:0;
				}
				table{
				border-collapse:collapse;}

				tr{
				width:500px;
				height:50px;}

				th{
				width:50px;
				height:50px;
				border:1px solid #000;}

				.table{
				margin:49px 0 0 49px;
				width:1200px;
				height:600px;
				position:relative;}

				.red{
				width:50px;
				height:50px;
				background:red;
				position:absolute;
				top:1px;left:1px;
				cursor:pointer;}

				js:
				$(function(){
				    for( var i=0; i&lt;20; i++){
				         var newTh = $(&#x27;&lt;th&gt;&#x27;);
				         $(&#x27;tr&#x27;).append(newTh);
				    }

				    for( var i=0; i&lt; 3; i++ ){
				        var newTr = $(&#x27;tr&#x27;).clone();
				        $(&#x27;tbody&#x27;).append(newTr);
				    }


				    var disX = 0;
				    var disY = 0;
				    var redTimer = 0;

				    $(&#x27;.red&#x27;).mousedown(function(ev){

				                disX = ev.pageX - $(&#x27;.red&#x27;).offset().left;
				                disY = ev.pageY - $(&#x27;.red&#x27;).offset().top;

				                $(document).mousemove(function(ev){

				                        $(&#x27;.red&#x27;).css({
				                                left : ev.pageX-disX-50,
				                                top : ev.pageY -disY-50
				                        });
				                })
				                $(document).mouseup(function(ev){
				                    $(document).off(&#x27;mousemove&#x27;);

				                    var L = ev.pageX-disX-50;
				                    var T = ev.pageY -disY -50;
				                    var n1 = Math.round(L/51);
				                    var n2 = Math.round(T/51);
				                    $(&#x27;.red&#x27;).css({
				                        left : 1 + 51*n1 ,
				                        top : 1 + 51*n2
				                    })
				                })
				                return false;
				    })
				})





				$(&#x27;li&#x27;).eq(2).before(&#x27;&lt;li&gt;苹果&lt;/li&gt;&#x27;);
				$(&#x27;li&#x27;).eq(3).after(&#x27;&lt;li&gt;奇酷&lt;/li&gt;&#x27;)



				加载完后：
				$(window).load(function(){
				alert(&#x27;加载完毕，要我做什么？&#x27;)
				})


				获取有动画的元素：
				$(&#x27;*:animated&#x27;).fadeOut(3000);


				当我要选索引值小于x的所有li的时候
				$(&#x27;li:lt(3)&#x27;).css(&#x27;border&#x27;,&#x27;1px solid red&#x27;)


				当我要选索引值大于x的所有里的时候
				$(&#x27;li:gt(1)&#x27;).css(&#x27;background&#x27;,&#x27;red&#x27;)


				当我要选取属性值等于或者不等于某个值的li的时候
				//$(&#x27;*[abc=123]&#x27;).slideUp();
				$(&#x27;li[abc!=dfd]&#x27;).slideUp();


				当我要选取有属性abc的元素的时候
				$(&#x27;*[src]&#x27;).hide();
				$(&#x27;*[abc]&#x27;).slideUp();


				当我要选取隐藏的元素的时候
				$(&#x27;*:hidden&#x27;).fadeIn(2000);


				当我要选取所有li中含有span或其他标签的li时候
				$(&#x27;li:has(span)&#x27;).css(&#x27;background&#x27;,&#x27;green&#x27;)


				当我要选取其文本中含有某文字的这个元素的时候
				$(&#x27;li:contains(小米)&#x27;).css(&#x27;background&#x27;,&#x27;red&#x27;)



				当我要选取获取了光标的元素时
				$(&#x27;*:focus&#x27;).val(&#x27;hello&#x27;)


				当我要选取表单中所有选中状态的元素时
				$(&#x27;input:checked&#x27;).slideUp();


				当我要选取表单中所有被disabled禁用的元素
				$(&#x27;input:disabled&#x27;).slideUp();


				$(&#x27;li:not(.test)&#x27;).css(&#x27;background&#x27;,&#x27;red&#x27;)
				当我要选除当前li的所有其他li时


				当我要修改尺寸的时候height()_width()
				$(&#x27;li:first&#x27;).width(&#x27;50%&#x27;);
				$(&#x27;li:last&#x27;).width(&#x27;125&#x27;);



				当我要让每一个li依次产生淡出的效果
				$(&#x27;li&#x27;).hide().each(function(index){
				$(this).delay(500*index).fadeIn(1000);
				})



				当使用each循环的时候，可以用this.id_this.type_this.value...
				$(&#x27;li&#x27;).each(function(){
				alert(this.id);
				})
				$(&#x27;input&#x27;).each(function(){
				alert(this.type)
				})



				当html（）里面用一个匿名函数返回我想要的内容时
				$(&#x27;li[abc=123]&#x27;).html(function(){
				return &#x27;&lt;span&gt;&#x27;+$(&#x27;input:text&#x27;).val() + &#x27;&lt;/span&gt;&#x27;;
				})


				自定义事件:trigger触发：

				$(&#x27;div&#x27;).on(&#x27;turn&#x27;,function(){
				$(this).animate({left:400},1000).delay(1000).animate({left :400, top: 100},1000).delay(1000).animate({left :0, top: 100},1000).delay(1000).animate({left :0, top: 300},1000)
				})
				$(&#x27;ul&#x27;).mouseover(function(){
				$(&#x27;div&#x27;).trigger(&#x27;turn&#x27;);
				})


				主动触发：
				$(&#x27;ul&#x27;).delegate(&#x27;li&#x27;,&#x27;click&#x27;,function(){
				$(this).animate({
				height : 50
				},600,&#x27;linear&#x27;)
				});

				$(&#x27;input&#x27;).click(function(){
				$(&#x27;li&#x27;).trigger(&#x27;click&#x27;);
				})


				slice():
				$(&#x27;li&#x27;).slice(1,4).css(&#x27;background&#x27;,&#x27;red&#x27;);
				$(&#x27;span&#x27;).slice(1,3).css(&#x27;background&#x27;,&#x27;green&#x27;)




				圣杯布局：
				&lt;style&gt;
				.layout:after{ clear:both; content:&quot;&quot;; display:table;}
				.layout_aside, .layout_main{ float:right;}
				.layout{ padding-right:420px; text-align:center; color:#fff;}
				.layout_main{ width:100%; background-color: green;}
				.layout_aside_first{ width:200px; background-color: red; margin-right:-420px;}
				.layout_aside_second{ width:200px; background-color: red; margin-right:-210px;}
				&lt;/style&gt;
				&lt;/head&gt;
				&lt;body&gt;
				&lt;div class=&quot;layout&quot;&gt;
				&lt;aside class=&quot;layout_aside layout_aside_first&quot;&gt;01左侧边栏宽度固定&lt;/aside&gt;
				&lt;aside class=&quot;layout_aside layout_aside_second&quot;&gt;02左侧边栏宽度固定&lt;/aside&gt;
				&lt;div class=&quot;layout_main&quot;&gt;主内容栏宽度自适应&lt;/div&gt;
				&lt;/div&gt;



				关于 json遍历 jquery遍历
				    var json1 = {name : &#x27;jack&#x27;, age : &#x27;35&#x27;};
				   $.each(json1,function(name, value){
				            if(value == &#x27;35&#x27;){
				               // alert(2)
				            }
				   });

				   var arr1 = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];
				   var index = $.inArray(&#x27;c&#x27;,arr1);
				   console.log( arr1[index] );

				   var json2 = [
				       {name : &#x27;jack&#x27;, age : &#x27;26&#x27;},
				       {name : &#x27;jie&#x27;, age : &#x27;23&#x27;}
				   ];
				   for(var p in json2){
				        console.log( json2[p].name +&#x27;/&#x27;+json2[p].age );
				   }




				$.extend();
				$.fn.extend({
				setCss : function(oAttr) {
				    var sName = &quot;&quot;;
				    var aName = [&quot;Webkit&quot;, &quot;Moz&quot;, &quot;O&quot;];
				    for (sName in oAttr)
				    {
				        if (sName.charAt(0) === &quot;$&quot;)
				        {
				            for (var i = 0; i &lt; aName.length; i++)
				            {
				                this.css(aName[i] + sName.substring(1), oAttr[sName]);
				            }
				            this.css(sName.substring(1), oAttr[sName]);
				        }
				        else {
				            this.css(sName, oAttr[sName]);
				        }
				    }
				}
				});



				Web API参考：
				利用API来完成各种各样的任务。
				我们可以利用接口来开发web应用程序或者网站。




				网页性能管理详解
				作者： 阮一峰
				日期： 2015年9月17日
				你遇到过性能很差的网页吗？
				这种网页响应非常缓慢，占用大量的CPU和内存，浏览起来常常有卡顿，页面的动画效果也不流畅。

				你会有什么反应？我猜想，大多数用户会关闭这个页面，改为访问其他网站。作为一个开发者，肯定不愿意看到这种情况，那么怎样才能提高性能呢？
				本文将详细介绍性能问题的出现原因，以及解决方法。
				一、网页生成的过程
				要理解网页性能为什么不好，就要了解网页是怎么生成的。

				网页的生成过程，大致可以分成五步。
				HTML代码转化成DOM
				CSS代码转化成CSSOM（CSS Object Model）
				结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
				生成布局（layout），即将所有渲染树的所有节点进行平面合成
				将布局绘制（paint）在屏幕上
				这五步里面，第一步到第三步都非常快，耗时的是第四步和第五步。
				&quot;生成布局&quot;（flow）和&quot;绘制&quot;（paint）这两步，合称为&quot;渲染&quot;（render）。

				二、重排和重绘
				网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。
				以下三种情况，会导致网页重新渲染。
				修改DOM
				修改样式表
				用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）
				重新渲染，就需要重新生成布局和重新绘制。前者叫做&quot;重排&quot;（reflow），后者叫做&quot;重绘&quot;（repaint）。
				需要注意的是，&quot;重绘&quot;不一定需要&quot;重排&quot;，比如改变某个网页元素的颜色，就只会触发&quot;重绘&quot;，不会触发&quot;重排&quot;，因为布局没有改变。但是，&quot;重排&quot;必然导致&quot;重绘&quot;，比如改变一个网页元素的位置，就会同时触发&quot;重排&quot;和&quot;重绘&quot;，因为布局改变了。
				三、对于性能的影响
				重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。
				提高网页性能，就是要降低&quot;重排&quot;和&quot;重绘&quot;的频率和成本，尽量少触发重新渲染。
				前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。

				div.style.color = &#x27;blue&#x27;;
				div.style.marginTop = &#x27;30px&#x27;;
				上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。
				如果写得不好，就会触发两次重排和重绘。

				div.style.color = &#x27;blue&#x27;;
				var margin = parseInt(div.style.marginTop);
				div.style.marginTop = (margin + 10) + &#x27;px&#x27;;
				上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。
				一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。
				offsetTop/offsetLeft/offsetWidth/offsetHeight
				scrollTop/scrollLeft/scrollWidth/scrollHeight
				clientTop/clientLeft/clientWidth/clientHeight
				getComputedStyle()
				所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。

				// bad
				div.style.left = div.offsetLeft + 10 + &quot;px&quot;;
				div.style.top = div.offsetTop + 10 + &quot;px&quot;;

				// good
				var left = div.offsetLeft;
				var top  = div.offsetTop;
				div.style.left = left + 10 + &quot;px&quot;;
				div.style.top = top + 10 + &quot;px&quot;;
				一般的规则是：
				样式表越简单，重排和重绘就越快。
				重排和重绘的DOM元素层级越高，成本就越高。
				table元素的重排和重绘成本，要高于div元素
				四、提高性能的九个技巧
				有一些技巧，可以降低浏览器重新渲染的频率和成本。
				第一条是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。
				第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。
				第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。

				// bad
				var left = 10;
				var top = 10;
				el.style.left = left + &quot;px&quot;;
				el.style.top  = top  + &quot;px&quot;;

				// good
				el.className += &quot; theclassname&quot;;

				// good
				el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;;
				第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。
				第五条，先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。
				第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。
				第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。
				第八条，使用虚拟DOM的脚本库，比如React等。
				第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染（详见后文）。
				五、刷新率
				很多时候，密集的重新渲染是无法避免的，比如scroll事件的回调函数和网页动画。
				网页动画的每一帧（frame）都是一次重新渲染。每秒低于24帧的动画，人眼就能感受到停顿。一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。如果能达到每秒70帧甚至80帧，就会极其流畅。

				大多数显示器的刷新频率是60Hz，为了与系统一致，以及节省电力，浏览器会自动按照这个频率，刷新动画（如果可以做到的话）。

				所以，如果网页动画能够做到每秒60帧，就会跟显示器同步刷新，达到最佳的视觉效果。这意味着，一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。

				一秒之间能够完成多少次重新渲染，这个指标就被称为&quot;刷新率&quot;，英文为FPS（frame per second）。60次重新渲染，就是60FPS。
				如果想达到60帧的刷新率，就意味着JavaScript线程每个任务的耗时，必须少于16毫秒。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。
				六、开发者工具的Timeline面板
				Chrome浏览器开发者工具的Timeline面板，是查看&quot;刷新率&quot;的最佳工具。这一节介绍如何使用这个工具。
				首先，按下 F12 打开&quot;开发者工具&quot;，切换到Timeline面板。

				左上角有一个灰色的圆点，这是录制按钮，按下它会变成红色。然后，在网页上进行一些操作，再按一次按钮完成录制。
				Timeline面板提供两种查看方式：横条的是&quot;事件模式&quot;（Event Mode），显示重新渲染的各种事件所耗费的时间；竖条的是&quot;帧模式&quot;（Frame Mode），显示每一帧的时间耗费在哪里。
				先看&quot;事件模式&quot;，你可以从中判断，性能问题发生在哪个环节，是JavaScript的执行，还是渲染？

				不同的颜色表示不同的事件。

				蓝色：网络通信和HTML解析
				黄色：JavaScript执行
				紫色：样式计算和布局，即重排
				绿色：重绘
				哪种色块比较多，就说明性能耗费在那里。色块越长，问题越大。


				帧模式（Frames mode）用来查看单个帧的耗时情况。每帧的色柱高度越低越好，表示耗时少。

				你可以看到，帧模式有两条水平的参考线。

				下面的一条是60FPS，低于这条线，可以达到每秒60帧；上面的一条是30FPS，低于这条线，可以达到每秒30次渲染。如果色柱都超过30FPS，这个网页就有性能问题了。
				此外，还可以查看某个区间的耗时情况。

				或者点击每一帧，查看该帧的时间构成。

				七、window.requestAnimationFrame()
				有一些JavaScript方法可以调节重新渲染，大幅提高网页性能。
				其中最重要的，就是 window.requestAnimationFrame() 方法。它可以将某些代码放到下一次重新渲染时执行。

				function doubleHeight(element) {
				var currentHeight = element.clientHeight;
				element.style.height = (currentHeight * 2) + &#x27;px&#x27;;
				}
				elements.forEach(doubleHeight);
				上面的代码使用循环操作，将每个元素的高度都增加一倍。可是，每次循环都是，读操作后面跟着一个写操作。这会在短时间内触发大量的重新渲染，显然对于网页性能很不利。
				我们可以使用window.requestAnimationFrame()，让读操作和写操作分离，把所有的写操作放到下一次重新渲染。

				function doubleHeight(element) {
				var currentHeight = element.clientHeight;
				window.requestAnimationFrame(function () {
				element.style.height = (currentHeight * 2) + &#x27;px&#x27;;
				});
				}
				elements.forEach(doubleHeight);
				页面滚动事件（scroll）的监听函数，就很适合用 window.requestAnimationFrame() ，推迟到下一次重新渲染。

				$(window).on(&#x27;scroll&#x27;, function() {
				window.requestAnimationFrame(scrollHandler);
				});
				当然，最适用的场合还是网页动画。下面是一个旋转动画的例子，元素每一帧旋转1度。

				var rAF = window.requestAnimationFrame;

				var degrees = 0;
				function update() {
				div.style.transform = &quot;rotate(&quot; + degrees + &quot;deg)&quot;;
				console.log(&#x27;updated to degrees &#x27; + degrees);
				degrees = degrees + 1;
				rAF(update);
				}
				rAF(update);
				八、window.requestIdleCallback()
				还有一个函数window.requestIdleCallback()，也可以用来调节重新渲染。
				它指定只有当一帧的末尾有空闲时间，才会执行回调函数。

				requestIdleCallback(fn);
				上面代码中，只有当前帧的运行时间小于16.66ms时，函数fn才会执行。否则，就推迟到下一帧，如果下一帧也没有空闲时间，就推迟到下下一帧，以此类推。
				它还可以接受第二个参数，表示指定的毫秒数。如果在指定 的这段时间之内，每一帧都没有空闲时间，那么函数fn将会强制执行。

				requestIdleCallback(fn, 5000);
				上面的代码表示，函数fn最迟会在5000毫秒之后执行。
				函数 fn 可以接受一个 deadline 对象作为参数。

				requestIdleCallback(function someHeavyComputation(deadline) {
				while(deadline.timeRemaining() &gt; 0) {
				doWorkIfNeeded();
				}

				if(thereIsMoreWorkToDo) {
				requestIdleCallback(someHeavyComputation);
				}
				});
				上面代码中，回调函数 someHeavyComputation 的参数是一个 deadline 对象。
				deadline对象有一个方法和一个属性：timeRemaining() 和 didTimeout。
				（1）timeRemaining() 方法
				timeRemaining() 方法返回当前帧还剩余的毫秒。这个方法只能读，不能写，而且会动态更新。因此可以不断检查这个属性，如果还有剩余时间的话，就不断执行某些任务。一旦这个属性等于0，就把任务分配到下一轮requestIdleCallback。
				前面的示例代码之中，只要当前帧还有空闲时间，就不断调用doWorkIfNeeded方法。一旦没有空闲时间，但是任务还没有全执行，就分配到下一轮requestIdleCallback。
				（2）didTimeout属性
				deadline对象的 didTimeout 属性会返回一个布尔值，表示指定的时间是否过期。这意味着，如果回调函数由于指定时间过期而触发，那么你会得到两个结果。
				timeRemaining方法返回0
				didTimeout 属性等于 true
				因此，如果回调函数执行了，无非是两种原因：当前帧有空闲时间，或者指定时间到了。

				function myNonEssentialWork (deadline) {
				while ((deadline.timeRemaining() &gt; 0 || deadline.didTimeout) &amp;&amp; tasks.length &gt; 0)
				doWorkIfNeeded();

				if (tasks.length &gt; 0)
				requestIdleCallback(myNonEssentialWork);
				}

				requestIdleCallback(myNonEssentialWork, 5000);
				上面代码确保了，doWorkIfNeeded 函数一定会在将来某个比较空闲的时间（或者在指定时间过期后）得到反复执行。
				requestIdleCallback 是一个很新的函数，刚刚引入标准，目前只有Chrome支持，不过其他浏览器可以用垫片库。



				性能问题：
				从加载的角度考虑：
				1 我们可以合并javascript css，再压缩；构建工具grunt
				2 对于小图片和背景图片，我们可以考虑用css雪碧图来处理。该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。减少加载网页图片时对服务器的请求次数  提高页面的加载速度
				3 使用外联式引用CSS、JavaScript
				4 在服务器端设置Gzip： Gzip现今已经成为Internet 上使用非常普遍的一种数据压缩格式  大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度  这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来.一般对纯文本内容可压缩到原大小的40%.这样传输就快了，效果就是你点击网址后会很快的显示出来.当然这也会增加服务器的负载. 一般服务器中都安装有这个功能模块的。
				5 js文件的引入 不要放在头部 这样会阻塞 应该放在/body 或者通过异步加载的方式引入 css，通过Link在头部引入 避免写成内部样式
				异步加载js 写法：&lt;script&gt;
				(function() {
				var s = document.createElement(&#x27;script&#x27;);
				s.type = &#x27;text/javascript&#x27;;
				s.async = true;
				s.src = &#x27;http://yourdomain.com/script.js&#x27;;
				var x = document.getElementsByTagName(&#x27;script&#x27;)[0];
				x.parentNode.insertBefore(s, x);
				})()
				&lt;/script&gt;
				6 按需加载 延迟加载lazyload.js
				&lt;img class=&quot;lazy&quot; data-original=&quot;img/example.jpg&quot; width=&quot;640&quot; height=&quot;480&quot;&gt;
				&lt;noscript&gt;
				&lt;img src=&quot;img/example.jpg&quot; width=&quot;640&quot; heigh=&quot;480&quot;&gt;
				&lt;/noscript&gt;

				$(function() {
				$(&quot;img.lazy&quot;).lazyload();
				});

				$(&quot;img.lazy&quot;).lazyload({
				threshold : 200
				});

				$(&quot;img.lazy&quot;).lazyload({
				event : &quot;click&quot;
				});

				$(&quot;img.lazy&quot;).lazyload({
				effect : &quot;fadeIn&quot;
				});


				7 图片可以需要的时候再加载，也可以在图片身上做文章---- 压缩图片 的大小
				工具网址: https://tinypng.com/
				http://zhitu.isux.us/

				8 图片预加载：
				function preloadimg(arr,obj,ipt){
				var arrImg= [&#x27;img1&#x27;,&#x27;img2&#x27;,&#x27;img3&#x27;,&#x27;img4&#x27;,&#x27;img5&#x27;,&#x27;img6&#x27;];

				var img =new Image();
				obj.innerHTML=&quot;&lt;p&gt;图片加载中...&lt;/p&gt;&quot;;


				for(var i=0; i&lt;arr.length; i++){
				arrImg[i] = new Image();
				arrImg[i].src = arr[i];
				}

				console.log(arrImg)
				for(var i=0; i&lt;arr.length; i++){
				arrImg[i].onload = function(){
				    obj.innerHTML=&quot;&quot;;
				    document.body.appendChild(this);
				}
				arrImg[i].onerror = function() {
				    alert(2)
				}
				}//img.src一定要写在img.onload之后，否则在IE中会出现问题


				}



				var arrPic = [&#x27;1.jpg&#x27;,&#x27;2.jpg&#x27;,&#x27;7.jpg&#x27;,&#x27;4.jpg&#x27;,&#x27;5.jpg&#x27;,&#x27;6.jpg&#x27;];


				function show(){
				var div=document.getElementsByTagName(&quot;div&quot;)[0];
				var input=document.getElementsByTagName(&quot;input&quot;);
				preloadimg(arrPic,div,input[0]);
				}
				window.onload=show;


				9 减少Cookie  Cookie会影响加载速度

				10  重定向会影响加载速度
				我们在网站建设中，时常会遇到需要网页重定向的情况：
				1.网站调整（如改变网页目录结构）；
				2.网页被移到一个新地址；
				3.网页扩展名改变(如应用需要把.php改成.Html或.shtml)。
				这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。


				11  第三方资源不可控会影响页面的加载和显示，因此要异步加载第三方资源



				从脚本执行的角度优化：
				1  CSS写在头部，JavaScript写在尾部或异步
				2  空Src会重新加载当前页面，影响速度和效率    避免图片和iFrame等的空Src
				3  多次重设图片大小会引发图片的多次重绘，影响性能  避免重设图片大小
				4  DataURL图片没有使用图片的压缩算法文件会变大，并且要解码后再渲染，加载慢耗时长  尽量避免使用DataURL

				css角度优化：
				1 避免写在HTML标签中写Style属性
				2 CSS表达式的执行需跳出CSS树的渲染，因此请避免CSS表达式
				body {
				background-color: expression((new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );
				}
				3  · 正确使用Display的属性
				Display属性会影响页面的渲染，因此请合理使用
				a) display:inline后不应该再使用width、height、margin、padding以及float
				b) display:inline-block后不应该再使用float
				c) display:block后不应该再使用vertical-align
				d) display:table-*后不应该再使用margin或者float

				4   Float在渲染时计算量比较大  不滥用Float
				5   过多的Font-size引发CSS树的效率  不声明过多的Font-size
				6  为了浏览器的兼容性和性能，值为0时不要带单位
				7  各种浏览器前缀  标准化：
				a) 无前缀应放在最后
				b) CSS动画只用 （-webkit- 无前缀）两种即可
				c) 其它前缀为 -webkit- -moz- -ms- 无前缀 四种，（-o-Opera浏览器改用blink内核，所以淘汰）

				8 高级选择器执行耗时长且不易读懂，避免使用


				[JavaScript执行角度优化：
				1 尽量改变Class而不是Style
				2 避免使用document.write
				3 减少drawImage
				4 每次Dom选择都要计算，缓存他
				5 每次.length都要计算，用一个变量保存这个值
				6  尽量使用事件代理，避免批量绑定事件
				7 ID选择器是最快的

				渲染角度优化：
				1  Viewport可以加速页面的渲染，请使用以下代码
				&lt;meta name=”viewport” content=”width=device-width, initial-scale=1″&gt;
				2 Dom节点太多影响页面的渲染，应尽量减少Dom节点
				3  · 动画优化
				a) 尽量使用CSS3动画
				b) 合理使用requestAnimationFrame动画代替setTimeout
				c) 适当使用Canvas动画 5个元素以内使用css动画，5个以上使用Canvas动画（iOS8可使用webGL）
				4  高频事件优化
				Touchmove、Scroll 事件可导致多次渲染
				a) 使用requestAnimationFrame监听帧变化，使得在正确的时间进行渲染
				b) 增加响应变化的时间间隔，减少重绘次数

				5  · GPU加速
				CSS中以下属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）来触发GPU渲染，请合理使用
				PS：过渡使用会引发手机过耗电增加




				&lt;meta name=&quot;generator&quot; content=&quot;ultraedit&quot;&gt;
				指的是我这文件是用什么来生成的，是用ultraedit。
				&lt;meta name=&quot;anthor&quot; contnet=&quot;me&quot;&gt;
				作者是谁，是我。
				&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=http://www.baidu.com&quot;&gt;
				在三秒中之后刷新当前页面，指到www.baidu.com。
				&lt;meta http-equiv=&quot;content-type&quot; content=text/html;charset=gb2312&quot;&gt;这句话的意思是：下面内容的类型是什么，content=text/html指的是当前页面是一个html格式，charset=gb2312编码是gb2312(简体中文)。

				http-equiv  ：指明下面要设置的项目
				content  ：指明该项目要设置的内容






				css编码规则：
				/* Bad CSS */
				.selector, .selector-secondary, .selector[type=text] {
				padding:15px;
				margin:0px 0px 15px;
				background-color:rgba(0, 0, 0, 0.5);
				box-shadow:0px 1px 2px #CCC,inset 0 1px 0 #FFFFFF
				}

				/* Good CSS */
				.selector,
				.selector-secondary,
				.selector[type=&quot;text&quot;] {
				padding: 15px;
				margin-bottom: 15px;
				background-color: rgba(0,0,0,.5);
				box-shadow: 0 1px 2px #ccc, inset 0 1px 0 #fff;
				}

				顺序：
				.declaration-order {
				/* Positioning */
				position: absolute;
				top: 0;
				right: 0;
				bottom: 0;
				left: 0;
				z-index: 100;

				/* Box-model */
				display: block;
				float: right;
				width: 100px;
				height: 100px;

				/* Typography */
				font: normal 13px &quot;Helvetica Neue&quot;, sans-serif;
				line-height: 1.5;
				color: #333;
				text-align: center;

				/* Visual */
				background-color: #f5f5f5;
				border: 1px solid #e5e5e5;
				border-radius: 3px;

				/* Misc */
				opacity: 1;
				}

				不要使用@import
				&lt;!-- Use link elements --&gt;
				&lt;link rel=&quot;stylesheet&quot; href=&quot;core.css&quot;&gt;

				&lt;!-- Avoid @imports --&gt;
				&lt;style&gt;
				@import url(&quot;more.css&quot;);
				&lt;/style&gt;



				带前缀的属性：
				/* Prefixed properties */
				.selector {
				-webkit-box-shadow: 0 1px 2px rgba(0,0,0,.15);
				box-shadow: 0 1px 2px rgba(0,0,0,.15);
				}


				短的一行 多的换行
				/* Single declarations on one line */
				.span1 { width: 60px; }
				.span2 { width: 140px; }
				.span3 { width: 220px; }

				/* Multiple declarations, one per line */
				.sprite {
				display: inline-block;
				width: 16px;
				height: 15px;
				background-image: url(../img/sprite.png);
				}
				.icon           { background-position: 0 0; }
				.icon-home      { background-position: 0 -20px; }
				.icon-account   { background-position: 0 -40px; }



				/* Bad example */
				.element {
				margin: 0 0 10px;
				background: red;
				background: url(&quot;image.jpg&quot;);
				border-radius: 3px 3px 0 0;
				}

				/* Good example */
				.element {
				margin-bottom: 10px;
				background-color: red;
				background-image: url(&quot;image.jpg&quot;);
				border-top-left-radius: 3px;
				border-top-right-radius: 3px;
				}


				代码是由人编写并维护的。请确保你的代码能够自描述、注释良好并且易于他人理解。好的代码注释能够传达上下文关系和代码目的。不要简单地重申组件或 class 名称。
				对于较长的注释，务必书写完整的句子；对于一般性注解，可以书写简洁的短语。

				/* Bad example */
				/* Modal header */
				.modal-header {
				...
				}

				/* Good example */
				/* Wrapping element for .modal-title and .modal-close */
				.modal-header {
				...
				}



				bootstarp插件：

				Bootstrap 插件概览

				在前面 布局组件 章节中所讨论到的组件仅仅是个开始。Bootstrap 自带 12 种 jQuery 插件，扩展了功能，可以给站点添加更多的互动。即使您不是一名高级的 JavaScript 开发人员，您也可以着手学习 Bootstrap 的 JavaScript 插件。利用 Bootstrap 数据 API（Bootstrap Data API），大部分的插件可以在不编写任何代码的情况被触发。

				站点引用 Bootstrap 插件的方式有两种：

				单独引用：使用 Bootstrap 的个别的 *.js 文件。一些插件和 CSS 组件依赖于其他插件。如果您单独引用插件，请先确保弄请这些插件之间的依赖关系。
				编译（同时）引用：使用 bootstrap.js 或压缩版的 bootstrap.min.js。

				不要尝试同时引用这两个文件，因为 bootstrap.js 和 bootstrap.min.js 都包含了所有的插件。

				所有的插件依赖于 jQuery。所以必须在插件文件之前引用 jQuery。请访问 bower.json 查看 Bootstrap 当前支持的 jQuery 版本。
				data 属性

				你可以仅仅通过 data 属性 API 就能使用所有的 Bootstrap 插件，无需写一行 JavaScript 代码。这是 Bootstrap 中的一等 API，也应该是你的首选方式。
				话又说回来，在某些情况下可能需要将此功能关闭。因此，我们还提供了关闭 data 属性 API 的方法，即解除以 data-api 为命名空间并绑定在文档上的事件。就像下面这样：f

				$(document).off(&#x27;.data-api&#x27;)

				如需关闭一个特定的插件，只需要在 data-api 命名空间前加上该插件的名称作为命名空间即可，如下所示：

				$(document).off(&#x27;.alert.data-api&#x27;)

				编程方式的 API

				我们为所有 Bootstrap 插件提供了纯 JavaScript 方式的 API。所有公开的 API 都是支持单独或链式调用方式，并且返回其所操作的元素集合（注：和jQuery的调用形式一致）。例如：

				$(&quot;.btn.danger&quot;).button(&quot;toggle&quot;).addClass(&quot;fat&quot;)

				所有的方法都可以接受一个可选的选项对象作为参数，或者一个代表特定方法的字符串，或者不带任何参数（这种情况下，将会初始化插件为默认行为），如下所示：

				// 初始化为默认行为
				$(&quot;#myModal&quot;).modal()
				// 初始化为不支持键盘
				$(&quot;#myModal&quot;).modal({ keyboard: false })
				// 初始化并立即调用 show
				$(&quot;#myModal&quot;).modal(&#x27;show&#x27;)

				每个插件在 Constructor 属性上也暴露了其原始的构造函数：$.fn.popover.Constructor。如果您想获取某个特定插件的实例，可以直接通过页面元素获取：

				$(&#x27;[rel=popover]&#x27;).data(&#x27;popover&#x27;).

				避免命名空间冲突

				某些时候 Bootstrap 插件可能需要与其他 UI 框架一起使用。在这种情况下，可能会发生命名空间冲突。如果不幸发生了这种情况，你可以通过调用插件的 .noConflict 方法恢复其原始值。

				// 返回 $.fn.button 之前所赋的值
				var bootstrapButton = $.fn.button.noConflict()
				// 为 $().bootstrapBtn 赋予 Bootstrap 功能
				$.fn.bootstrapBtn = bootstrapButton

				事件

				Bootstrap 为大多数插件的独特行为提供了自定义事件。一般来说，这些事件有两种形式：

				动词不定式：这会在事件开始时被触发。例如 ex: show。动词不定式事件提供了 preventDefault 功能。这使得在事件开始前可以停止操作的执行。

				$(&#x27;#myModal&#x27;).on(&#x27;show.bs.modal&#x27;, function (e) {
				// 阻止模态框的显示
				if (!data) return e.preventDefault()
				})

				过去分词形式：这会在动作执行完毕之后被触发。例如 ex: shown。


				模态框 bootstap：
				&lt;div class = &quot;container&quot;&gt;
				&lt;button class=&quot;btn btn-primary btn-sm&quot; data-target=&quot;#myModal&quot; data-toggle=&quot;modal&quot;&gt;模态框&lt;/button&gt;
				&lt;a data-toggle=&quot;modal&quot; href=&quot;remote.html&quot; data-target=&quot;#myM odal&quot;&gt;添加html内容&lt;/a&gt;


				&lt;div class=&quot;modal fade&quot; id=&quot;myModal&quot; role=&quot;dialog&quot;  aria-hidden=&quot;true&quot;&gt;
				&lt;div class=&quot;modal-dialog&quot;&gt;
				&lt;div class=&quot;modal-content&quot;&gt;
				&lt;div class=&quot;modal-header&quot;&gt;
				&lt;button type=&quot;button&quot; data-dismiss=&quot;modal&quot; class=&quot;close&quot;  aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/button&gt;
				&lt;h4 class=&quot;modal-title&quot;&gt;标题&lt;/h4&gt;
				&lt;/div&gt;
				&lt;div class=&quot;modal-body&quot;&gt;
				内容...
				&lt;/div&gt;
				&lt;div class=&quot;modal-footer&quot;&gt;
				&lt;button class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot; type=&quot;button&quot;&gt;关闭&lt;/button&gt;
				&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;
				提交更改
				&lt;/button&gt;
				&lt;/div&gt;
				&lt;/div&gt;
				&lt;/div&gt;
				&lt;/div&gt;
				&lt;/div&gt;

				&lt;!--
				使用模态窗口，您需要有某种触发器。您可以使用按钮或链接。这里我们使用的是按钮。
				如果您仔细查看上面的代码，您会发现在 &lt;button&gt; 标签中，data-target=&quot;#myModal&quot; 是您想要在页面上加载的模态框的目标。您可以在页面上创建多个模态框，然后为每个模态框创建不同的触发器。现在，很明显，您不能在同一时间加载多个模块，但您可以在页面上创建多个在不同时间进行加载。
				在模态框中需要注意两点：
				第一是 .modal，用来把 &lt;div&gt; 的内容识别为模态框。
				第二是 .fade class。当模态框被切换时，它会引起内容淡入淡出。
				aria-labelledby=&quot;myModalLabel&quot;，该属性引用模态框的标题。
				属性 aria-hidden=&quot;true&quot; 用于保持模态窗口不可见，直到触发器被触发为止（比如点击在相关的按钮上）。
				&lt;div class=&quot;modal-header&quot;&gt;，modal-header 是为模态窗口的头部定义样式的类。
				class=&quot;close&quot;，close 是一个 CSS class，用于为模态窗口的关闭按钮设置样式。
				data-dismiss=&quot;modal&quot;，是一个自定义的 HTML5 data 属性。在这里它被用于关闭模态窗口。
				class=&quot;modal-body&quot;，是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的主体设置样式。
				class=&quot;modal-footer&quot;，是 Bootstrap CSS 的一个 CSS class，用于为模态窗口的底部设置样式。
				data-toggle=&quot;modal&quot;，HTML5 自定义的 data 属性 data-toggle 用于打开模态窗口。
				--&gt;

				&lt;script src = &quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;
				&lt;script src = &quot;js/bootstrap.js&quot;&gt;&lt;/script&gt;
				&lt;script src = &quot;js/ie10ViewBug.js&quot;&gt;&lt;/script&gt;
				&lt;script&gt;
				$(function(){

				$(&#x27;#myModal&#x27;).modal(&#x27;toggle&#x27;);

				$(&#x27;#myModal&#x27;).on(&#x27;hide.bs.modal&#x27;,function(){
				console.log(&#x27;hide方法调用，老子就被触发&#x27;);
				});
				$(&#x27;#myModal&#x27;).on(&#x27;show.bs.modal&#x27;,function(){
				console.log(&#x27;show方法调用，老子就被触发&#x27;);
				});
				$(&#x27;#myModal&#x27;).on(&#x27;shown.bs.modal&#x27;,function(){
				console.log(&#x27;模态框彻底过渡出来，老子才触发&#x27;);
				});
				$(&#x27;#myModal&#x27;).on(&#x27;hidden.bs.modal&#x27;,function(){
				console.log(&#x27;模态框完全被隐藏，老子才触发&#x27;);
				});
				})
				&lt;/script&gt;



				FireBug教程：
				FireBug组件： FireBug选项、点击检查元素工具、撤销和恢复、显示命令行、面板选择、 控制台、HTML面板、css面板、脚本面板、DOM面板、网络面板
				1. 使用FireBug查看和编辑HTML
				2. 使用Firebug查看和编辑Css
				3. 使用 Firebug 调试 JavaScript
				一步步调试代码 你可以一步步的执行代码。这对代码调试非常有用
				使用断点调试  点调试可以终止代码的执行，你可以通过指定代码范围来查看错误是不是在指定代码范围内。这对于 错误调试很有用。 如果你点击&quot;Step over（单步跳过）&quot; 按钮, Firebug 会更新所有变量直到你在右侧窗口中终止断点执行。
				使用表达式让断点工作 以写一个表达式，在条件为真时，断点会停止代码的执行。

				4. Firebug页面概况查看
				使用Firebug的概况，你可以测试Web页面导致延迟加载的文件。
				通过打开页面 Firebug &gt; Console（控制台）&gt; Profile（概况）。
				你需要重新加载页面，然后点击&quot;概况&quot;查看页面载入情况。

				5. Firebug动态执行JavaScript
				您可以使用Firebug来编写并实时执行一个JavaScript。
				这是为了测试，并确保该脚本工作正常，这是将JavaScript代码部署在生产环境前的好方法。
				打开Firebug &gt; Script(脚本) &gt; 显示命令行，
				按Enter键后，马上你就能看到代码的输出

				6. Firebug监控网络情况  Firebug可以监控网页中每个文件加载的时间

				闭包：
				什么是闭包
				1.函数嵌套函数
				2.内部函数可以引用外部函数的参数和变量
				3.变量不会被垃圾回收机制回收，长期驻扎；
				垃圾回收机制：函数执行完，会删除变量。


				闭包有什么好处  用在哪里
				1.达到想要的变量长期贮存的目的；
				2.避免全局布局的污染
				3.私有成员的存在。
				用在哪里:
				1.使用闭包代替全局变量
				2.Ajax callback回调函数中经常需要继续使用主调函数的某一些参数。用闭包来解决。函数外或在其他函数中访问某一函数内部的参数
				用法：
				模块化代码
				闭包需要注意什么:
				ie下内存泄漏

				/*var a = 1;
				function fn1(){
				a++;
				function fn2(){
				alert(a)
				}
				return fn2();
				}
				fn1();
				fn1();*/

				/*function fn1(){  // 有没有这样的经历，写一个业务逻辑的过程中，把变量放进函数里面了，但是发现不行，因为，每次执行的时候，我这个变量被重新赋值了， 这不是我想要的，因为我的这个变量不是常量，而是一个根据业务逻辑会变化的值，而且我的业务逻辑，要一次次的回头重新执行函数，这是没办法的。 这样就带来一个问题，重新回头执行，那它就又被重新赋值了。于是我们很无奈的把它拿出来，变成一个全局变量，这样可以解决问题。但是如果工程项目大，那这种方式会遗留出大量大量的全局变量，存在这污染的可能。 闭包的技术，解决了这个问题， 变量放进去，又不会被重复的执行。而且是常驻的。
				var a = 1;
				a++;
				function fn2(){
				alert(a)
				}
				return fn2;
				}
				fn1()();
				fn1()();*/
				/*function fn1(){ *//* 闭包技术是怎么解决的呢？     你想啊，我的目的是变量不要放在全局，那就有一个方案，放到一个函数里就是局部的了。用到闭包技术，是因为我把变量放进函数里以后碰到了一个问题，为了解决这个问题，我们用的解决方案就叫做闭包。闭包的大体思路是，用return出去，然后立马把函数封存到全局 大家喜滋滋的用这个函数就好了  总结起来就是，你不就是要把变量放进去吗  好的，我已经解决了，变量换回来的是一个函数 变量存在里头 做的业务逻辑也在这个函数里。 *//*
				var a = 1;  // 变量在里头 这是要达到的目的
				return function fn2(){
				a++;
				alert(a)
				}
				}
				var result = fn1();   //fn1就只是执行一次， 然后给到result  这个时候result是函数fn2 我这个result是在全局声明的，因此是常驻的(只有当关闭网页的时候，才会回收);
				console.log( typeof result );
				result(); //当result执行的时候，这里就相当于有一个函数在这里了。只是借用了也下fn1而已，在fn1手里取到变量，做完手头上的事 a=2，带着变量a喜滋滋的就过来全局这里常年居住了。
				result(); //再次执行，意味着  拿着变量a=2，做完手头上的事 a=3。*/
				//升级一下写法：
				/*var x = (function (){ alert(1) });
				console.log( x ); //这不就是function fn1(){alert(1)}嘛
				x();*/

				/*var x = (function(){  *//* 模块化代码  *//*
				var a = 1;
				return function(){
				    a++;
				    alert(a);
				}
				})();
				x();
				x();*/
				// 我们知道 上面的基本上就是  变量转函数  这里我们来实现 变量转json的 模块化
				var x = (function(){
				var a = 1;
				function fn1(){
				a++;
				alert(a);
				}
				function fn2(){
				a++;
				alert(a);
				}
				return {
				fn1 : fn1,
				fn2 : fn2
				}
				})();
				x.fn1();
				x.fn2();
				console.log( fn1 );// 全局是找不到的。

				var _List = document.getElementById(&#x27;list&#x27;);
				var _Lis = _List.getElementsByTagName(&#x27;li&#x27;);
				/*for( var i=0; i&lt;_Lis.length; i++ ){
				_Lis[i].onclick = function(){
				console.log(i);  // 出现的是3 原因，当我们点击的时候for循环早早的就把事儿给办的妥妥的了   我要实现的是点击的时候 0 1 2... 依次  实现的思路是：  for循环，你就算跑的再快，也是需要在这个循环里一次一次的溜达过去的，我只要想办法，每次你过的时候，给你半路劫了；
				}
				}*/
				/*for( var i=0; i&lt;_Lis.length; i++ ){
				var x = (function(i){
				//alert(i);
				_Lis[i].onclick = function(){
				console.log(i);
				}
				})(i);
				}*/
				for(var i=0; i&lt;_Lis.length; i++ ){
				_Lis[i].onclick = (function(i){
				return function(){
				console.log(i);
				}
				})(i);
				}


				var oDiv = document.getElementById(&#x27;div1&#x27;);
				/*
				* 内存泄漏：  当跳转页面的时候，变量不会释放，一直存在内存中，cpu负荷累加
				* 关闭浏览器的时候，才能释放掉
				* 怎么才会内存泄漏：
				*       一个变量，这个变量是dom节点获得的  或者是宿主对象的时候
				*       它的一个属性/方法onclick，  去引用一个内部函数function(){}
				*       而函数内部又去引用外部的oDiv.id  互相引用的话会出现。
				* */
				oDiv.onclick = function(){
				alert( oDiv.id );
				}
				//解决方案：
				window.onunload = function(){
				oDiv.onclick = null;  // 中间截断 就不会
				}


				(function(){
				var oUl = document.getElementById(&#x27;list&#x27;);
				var aLi = oUl.getElementsByTagName(&#x27;li&#x27;);
				for(var i=0; i&lt;aLi.length;i++){
				var e = aLi[i];
				e.onclick = function(){
				alert( this.innerHTML );
				}
				}
				})();

				function fn1(){
				var a = 1;
				fn2 = function(){  //这里就产生了闭包
				return a;
				}
				}
				// 上面的代码中， fn2直接赋值， 是全局的。
				//  fn2();//你不是说是全局的吗，为什么这里找不到， 这是因为fn1没有执行，因此里面还未产生闭包
				fn1();
				console.log( fn2() );
				console.log( fn2 );  // 现在就找到了把


				/*function fn1(x){
				alert(x)
				}
				setTimeout(function(){
				fn1(4)
				},2000);*/

				//使用闭包里解决  某执行的时候要传递的参数
				var fnBB = (function(a){
				var x = 2;
				return function(){
				alert(a);
				}
				})(22)
				setTimeout(fnBB, 2000);
				var oBtn = document.getElementById(&#x27;btn&#x27;);
				oBtn.onclick = fnBB;


				// 例子：获取Table中被点击的行
				function fn1(){
				var oConsole = document.getElementById(&#x27;console&#x27;);
				var oMyTab = document.getElementById(&#x27;myTab&#x27;);
				var aTr = oMyTab.getElementsByTagName(&#x27;tr&#x27;);
				for( var i=0; i&lt;aTr.length; i++ ){
				aTr[i].onmouseover = function(){
				this.style.background = &#x27;#333&#x27;;
				this.style.color = &#x27;#fff&#x27;;
				}
				aTr[i].onmouseout = function(){
				this.style.background = &#x27;#fff&#x27;;
				this.style.color = &#x27;#333&#x27;;
				}
				var e = aTr[i];
				var fnBB = (function(x){  // 本身一上来执行一次  然后e点击事件触发 执行里面的闭包
				return function(){
				oConsole.innerHTML = &quot;&quot;;
				oConsole.innerHTML = &quot;点击的是第&quot;+ (x+1) +&quot;行&quot;;
				}
				})(i);
				e.onclick = fnBB;
				}
				}

				//添加线程
				function CreateDiv(){}
				CreateDiv.prototype.n = 0;
				CreateDiv.prototype.add = function(){
				var div = document.createElement(&#x27;div&#x27;);
				div.style.backgroundColor = &quot;#f60&quot;;
				div.style.color = &quot;#fff&quot;;
				div.style.marginBottom = &quot;4px&quot;;
				div.style.height = &quot;30px&quot;;
				div.style.lineHeight = &quot;30px&quot;;
				this.n++;
				div.setAttribute(&#x27;month&#x27;,this.n);
				document.body.appendChild(div);
				return div;
				}
				var c1 = new CreateDiv();
				Thread = function(){};
				Thread.prototype.start = function(){

				var div = c1.add();
				if( div.getAttribute(&quot;month&quot;) &gt;=21 ){
				div.innerHTML = &quot;只允许跑20个线程，看看你的CPU，都撑爆啦...&quot;;
				return;
				}
				var num = div.getAttribute(&#x27;month&#x27;);
				setInterval(function(){
				div.innerHTML = &quot;第&quot;+ div.getAttribute(&quot;month&quot;) +&quot;个线程运行中...&quot;+(num++);
				},50);
				}
				function addThread(){
				var T1 = new Thread();
				T1.start();
				}

				事件委托：

				var oUl = document.getElementById(&#x27;ul&#x27;);
				var aLi = oUl.getElementsByTagName(&#x27;li&#x27;);
				oUl.onmouseover = function(ev){
				var ev = ev || window.event;
				var origin = ev.target || ev.srcElement;
				console.log( origin.nodeName );
				if(origin.nodeName == &#x27;LI&#x27;){
				origin.style.background = &#x27;red&#x27;;
				}else{
				return;
				}
				}
				oUl.onmouseout = function(ev){
				var ev = ev || window.event;
				var origin = ev.target || ev.srcElement;
				if(origin.nodeName == &#x27;LI&#x27;){
				origin.style.background = &#x27;&#x27;;
				}else{
				return;
				}
				}
				//利用冒泡的原理  事件冒泡到父级上 执行触发效果
				//好处 ： 提高性能;  新添加的li依然有这个事件（想想就知道了）； 在for循环的方法中，新添加的li有没有事件，想一想，应该没有把，它都已经循环了，才添加的。
				// 怎么找到是哪个li 是事件源 这个涉及到ev  有兼容问题
				//  ie :  window.event.srcElement
				//  标准下 ：  ev.target
				var n = 3;
				function fn(){
				var oLi = document.createElement(&#x27;li&#x27;);
				n++;
				oLi.innerHTML = &quot;111&quot;*n;
				oUl.appendChild( oLi );
				}

				函数声明 函数表达式：
				/*
				函数声明： function fn(){}
				函数表达式：
				命名函数表达式： function fn(){};
				匿名函数表达式： function(){}
				* */

				function fn(){}  // 函数声明
				var a = function fn(){} // 命名函数表达式
				var b = function (){} // 匿名函数表达式
				(function fn(){})
				~function fn(){}
				+function fn(){}
				-function fn(){}
				!function fn(){}  // 都是函数表达式

				//有什么区别呢？
				/*
				1. 函数表达式是可以用()直接执行的，声明是不行。
				2. 函数声明会被提前解析出来，预解析
				* */

				// 根据上下文来判断，怎么根据上下文判断？

				//function fn2(){ alert(&#x27;李赛凤&#x27;) }();  //不行
				//var x = function fn2(){ alert(&#x27;快递费&#x27;) }() // 可以弹出
				//  ~function fn2(){ alert(&#x27;快递费&#x27;) }() // 可以弹出


				var a = function fn1(){
				alert(&#x27;ok&#x27;);
				}
				a(); // 浏览器都支持
				//fn1(); //标准浏览器下只是解析成一个a函数， 这样写是报错的；  ie6 7解析成2个函数 可以执行，

				//尽量要用  var a = function(){}这样的表达式  不要用命名表达式，存在着问题风险

				//
				(function fn(){ alert(&#x27;d&#x27;) })
				//  fn();  // 上面是函数表达式，这样执行， 就跟上面的一样，报错。
				// 常用 匿名函数表达式  那命名函数表达式什么情况下可以使用：
				var a = (function a(){
				return function(){
				debugger;
				}
				})();
				a();


				枚举法：
				/*
				* 枚举算法： 解决某些问题的时候，可能没有办法按照一定的规律从候选项中选出正确的，这时，我们可以从这些候选项中进行验证找到。
				*
				* */
				var aA = document.getElementsByTagName(&#x27;a&#x27;);
				var oUl = document.getElementById(&#x27;ul&#x27;);
				var aLi = oUl.getElementsByTagName(&#x27;li&#x27;);
				for( var i=0; i&lt;aA.length; i++ ){
				aA[i].onclick = function(){
				if( mj( this.innerHTML ) ){  //如果ul里没有相应的a  就添加 有的话就不用添加  我怎么判断
				var oLi = document.createElement(&#x27;li&#x27;);
				oLi.innerHTML = this.innerHTML;
				if( !aLi[0] ){
				oUl.appendChild( oLi );
				}else{
				oUl.insertBefore( oLi, aLi[0] );
				}
				}else{
				mj2( this.innerHTML );
				}
				}
				}
				function mj( text ){
				for( var i=0; i&lt;aLi.length;i++ ){
				if( aLi[i].innerHTML == text ){
				    //表示里面已经有了
				    return false;
				}
				}
				//循环后 都没找到有：
				return true;
				}
				function mj2( text ){
				for( var i=0; i&lt;aLi.length; i++ ){
				if( aLi[i].innerHTML == text ){
				oUl.insertBefore( aLi[i], aLi[0] );
				}
				}
				}




				写一个类 绑定一个事件 触发一个事件 按顺序执行
				E = function(){
				    function _isEmptyObj(obj){
				        for(var a in obj){
				            return false;
				        }
				        return true;
				    }
				    function _each(ary, callback){
				        for(var i=0,len=ary.length; i&lt;len;){
				            callback(i, ary[i]) ? i=0 : i++;
				        }
				    }
				    function _remove(el, type){
				        var handler = el.listeners[type][&#x27;_handler_&#x27;];
				        el.removeEventListener ?
				            el.removeEventListener(type, handler, false) :
				            el.detachEvent(&#x27;on&#x27;+type, handler);
				        delete el.listeners[type];
				        if(_isEmptyObj(el.listeners)){
				            delete el.listeners;
				        }
				    }
				    // 添加事件
				    function add(el, type, fn){
				        el.listeners = el.listeners || {};
				        var listeners = el.listeners[type] = el.listeners[type] || [];
				        listeners.push(fn);
				        if(!listeners[&#x27;_handler_&#x27;]){
				            listeners[&#x27;_handler_&#x27;] = function(e){
				                var evt = e || window.event;
				                for(var i=0,fn; fn=listeners[i++];){
				                    fn.call(el, evt);
				                }
				            }
				            el.addEventListener ?
				                el.addEventListener(type, listeners[&#x27;_handler_&#x27;], false) :
				                el.attachEvent(&#x27;on&#x27; + type,  listeners[&#x27;_handler_&#x27;]);
				        }
				    }
				    // 删除事件
				    function remove(el, type, fn){
				        if(!el.listeners) return;
				        var listeners = el.listeners &amp;&amp; el.listeners[type];
				        if(listeners) {
				            _each(listeners, function(i, f){
				                if(f==fn){
				                    return listeners.splice(i, 1);
				                }
				            });
				            if(listeners.length == 0){
				                _remove(el,type);
				            }
				        }
				    }
				    //主动触发事件
				    function dispatch(el ,type){
				        try{
				            if(el.dispatchEvent){
				                var evt = document.createEvent(&#x27;Event&#x27;);
				                evt.initEvent(type,true,true);
				                el.dispatchEvent(evt);
				            }else if(el.fireEvent){
				                el.fireEvent(&#x27;on&#x27;+type);
				            }
				        }catch(e){};
				    }
				    return {
				        add: add,
				        remove: remove,
				        dispatch: dispatch
				    };
				}();E = function(){
				        function _isEmptyObj(obj){
				            for(var a in obj){
				                return false;
				            }
				            return true;
				        }
				        function _each(ary, callback){
				            for(var i=0,len=ary.length; i&lt;len;){
				                callback(i, ary[i]) ? i=0 : i++;
				            }
				        }
				        function _remove(el, type){
				            var handler = el.listeners[type][&#x27;_handler_&#x27;];
				            el.removeEventListener ?
				                el.removeEventListener(type, handler, false) :
				                el.detachEvent(&#x27;on&#x27;+type, handler);
				            delete el.listeners[type];
				            if(_isEmptyObj(el.listeners)){
				                delete el.listeners;
				            }
				        }
				        // 添加事件
				        function add(el, type, fn){
				            el.listeners = el.listeners || {};
				            var listeners = el.listeners[type] = el.listeners[type] || [];
				            listeners.push(fn);
				            if(!listeners[&#x27;_handler_&#x27;]){
				                listeners[&#x27;_handler_&#x27;] = function(e){
				                    var evt = e || window.event;
				                    for(var i=0,fn; fn=listeners[i++];){
				                        fn.call(el, evt);
				                    }
				                }
				                el.addEventListener ?
				                    el.addEventListener(type, listeners[&#x27;_handler_&#x27;], false) :
				                    el.attachEvent(&#x27;on&#x27; + type,  listeners[&#x27;_handler_&#x27;]);
				            }
				        }
				        // 删除事件
				        function remove(el, type, fn){
				            if(!el.listeners) return;
				            var listeners = el.listeners &amp;&amp; el.listeners[type];
				            if(listeners) {
				                _each(listeners, function(i, f){
				                    if(f==fn){
				                        return listeners.splice(i, 1);
				                    }
				                });
				                if(listeners.length == 0){
				                    _remove(el,type);
				                }
				            }
				        }
				        //主动触发事件
				        function dispatch(el ,type){
				            try{
				                if(el.dispatchEvent){
				                    var evt = document.createEvent(&#x27;Event&#x27;);
				                    evt.initEvent(type,true,true);
				                    el.dispatchEvent(evt);
				                }else if(el.fireEvent){
				                    el.fireEvent(&#x27;on&#x27;+type);
				                }
				            }catch(e){};
				        }
				        return {
				            add: add,
				            remove: remove,
				            dispatch: dispatch
				        };
				    }();






					JSONP

					它的出现是为了解决ajax中的一个问题

					跨域问题

					当点击按钮的时候

					通过ajax， 异步的去获取当前同文件夹下的，甚至是同域名地下的文件

					oBtn.onclick = function() {

						var xhr = new XMLHttpRequest();

						最好把监听放到前面：

						xhr.onreadystatechange = function(){

								if( xhr.readyState == 4 ){

										if( xhr.status == 200 ){
											alert(xhr.responseText);
										}
								}
						}


						xhr.open(&#x27;get&#x27;,&#x27;1.txt&#x27;,true);   请求
						xhr.send();

					}


					 获取豆瓣的：
					 	xhr.open(&#x27;get&#x27;,&#x27;http://api.docban.com/book/subjects?q=javascript&amp;alt=json&amp;max-results=1&#x27;,true);
						xhr.send();

						这样不能得到什么
						出现错误
						跨域问题
						一个域名下的文件去请求了和它不一样的域名下的资源文件
						产生跨域请求
						请求受到限制

						怎么解决？
						实际工作中
						这种请求是比较多的

						可以通过服务端中转  服务端代码代理 本地代理

						可以通过flash

						可以通过jsonp

						bob.ippoli.to了解jsonp

						json width padding:
							去取东西
							原理：
								1, 用到script标签，属性src
								2，用script标签加载资源是没有跨域问题的。



						&lt;script src=&quot;http://api.docban.com/book/subjects?q=javascript&amp;alt=json&amp;max-results=1&quot;&gt;&lt;/script&gt;

						这样用，可以了吗？
						 script能打开其它类型的文件吗？

						 如果用img 去加载一张图片，认的是文件的内容，不是文件名，文件名只是用来辨认的
						 script也是的
						 只要是合法的js文件，就认
						 可以获取数据
						 但是我们用不了
						 没有变量去获取它
						 怎么办？


						 &lt;script&gt;
						  	function  fn( data ){
								alert(data);
							}
						 &lt;/script&gt;
						 &lt;script src = &#x27;1.txt&#x27;&gt;&lt;/script&gt;


						 1.txt 的内容：   fn([1,2,3]);

						上面这种，就是jsonp的模式

						paddiing的意思 内填充

						在资源加载进来之前，定义好一个函数，这个函数接受一个参数，这个参数就是我们所要的数据，在函数里面利用这个参数做一些事情。
						然后需要的是时候，通过js标签加载对应的远程文件资源，
						当被加载进来时，就会去执行前面定义好的函数，并且把
						数据当作函数的参数传入。

						我要做一件事：
							一个按钮
							点击后，
							数据拿到手
							之前是一旦引入文件，就会执行
							现在我希望，点击的时候
							才获得这个数据

							 oBtn.onclick = function(){

									动态创建标签
									var oScript = document.createElement(&#x27;script&#x27;);
										oScriopt.src = &#x27;1.txt&#x27;;
										document.body.appendChild(&#x27;oScript&#x27;)
							 }


							 实现到这一步，你会发现它特别像ajax

							 不过，使用过程中，还有很多细节问题，需要考虑

							 有一种情况：
							 	 oScript.src = &#x27;getData.php&#x27;;



								 getDate.php
								 			$arr1 = arry(&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;);

											echo &#x27;fn(&#x27;.json_encode($arr1).&#x27;)&#x27;



									function fn(data ) {

										var html = &#x27;&#x27;;
										var oUl1....
										for ( var i=0 i&lt;data.length; i++ ){
											html += &lt;li&gt;&#x27;+ data[i] +&#x27;&lt;/li&gt;
										}
										oUl1.innerHTML = html;
									}





									它有一问题：
										依赖于函数fn
										需要后端给个函数fn
										跟我这边的fn一样

										当点击的时候，执行它
										当点击另外一个对象的时候
										我还是要获得数据，
										可是它又会执行我不想要的函数
										这可咋办？


									http://localhost/2015-12-08/getData.php?t=str
									http://localhost/2015-12-08/getData.php?t=num

								后端定义一个值
								$callback = isset($_GET[&#x27;callback&#x27;])?$_GET[&#x27;callback&#x27;]:&#x27;fn1&#x27;;
								后端根据前端传过来的值，动态输出callback
								http://localhost/2015-12-08/getData.php?callback=fn7


								回来的值就是fn7
								意味着：

								oScript.src = &#x27;getData.php?callback=fn7&#x27;;

								这样就执行fn7



								后端干的就那一次



				     bind()方法：
				        if(!Function.prototype.bind){
				                    Function.prototype.bind = function(obj){
				                        var _This = this;
				                        var _Args = arguments;

				                        return function(){  // 因为bind()方法返回的就是一个函数
				                            var args = [];  //装好参数传到这个函数
				                            for(var i=0;i&lt;_Args.length;i++){
				                                args.push(_Args[i]);
				                            }
				                            for(var i=0;i&lt;arguments.length;i++){
				                                args.push(arguments[i]);
				                            }
				                            return _This.apply(obj,args); // 以obj的方法的身份，来调用函数666666666666666666666666666666666666666666555555556
				                        }
				                    }
				                }


				                  // 创建一个对象
				                  var obj1 = {
				                      name : &quot;1&quot;
				                  };

				                 //创建一个函数：
				                  function showT(){
				                      alert(this.name);
				                      console.log(arguments);
				                  }

				                    var newFn =  showT.bind(obj1,[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]);
				                    console.log( newFn() )

				                  //bind()方法作用： 将一个函数绑定到一个对象上
				                          // showT函数 绑定在obj1对象下，能访问到obj1的属性； 第二个参数，是传递的实参，生成的新对象具有。


				     call()、 apply()
				        如果我想要，以对象obj的方法的身份，来去调用一个函数Fn,那么我们可以写成这样：
				            Fn.call(obj)
				            Fn.apply(obj)
				        二者之间，传参方面有点区别：
				            Fn.call(obj,1,2)
				            Fn.call(obj,[1,2])


				    如果我要判断，一个字符串里，有没有某个字符？
				        str.indexOf(&quot;x&quot;)   // 如果没有 返回-1
				        例子：检查URL没有有查询部分  ？
				        if( url.indexOf(&quot;?&quot;) === -1 ){
				            url += &quot;?jsonp=&quot;+cbName
				        }else{
				            url +=&quot;&amp;jsonp=&quot;+cbName
				        }

				    使用jQuery的时候，有时我们需要判断一个元素是否是某个选择器对应的元素的时候：
				        $(&quot;div&quot;).each(function(){
				            if( $(this).is(&quot;:hidden&quot;) ) return;
				            ///......
				        })
				        function fn(ev){
				            var ev = ev || event;

				            $(ev.target).is(&quot;#btn&quot;) // 如果是 true
				        }

				    jQuery绑定事件：用法
				        $(&quot;#btn&quot;).(&quot;click&quot;,fn);

				        $(&quot;img&quot;).bind({
				            mouseover : function(){ $(this).stop().delay(100).fadeTo(300,1.0);},
				            mouseout :　function(){ $(this).stop().fadeTo(300,0.5); }
				        })

				    jQuery的延迟： delay()
				        $(&quot;img&quot;).fadeTo(100,0.5).delay(200).slideUp();


				    jQuery的 jQuery.getScript();函数
				        异步加载文件：
				        适用于同源、跨源：
				        jQuery.getScript(&quot;http://example.com/js/widget.js&quot;);
				        jQuery.getScript(&quot;js/myPlugin.js&quot;,function(){
				            xxxxx
				        });

				    jQuery的 getJSON()函数：
				        获取到文本之后，解析成json
				        jQuery.getJSON(&quot;data.json&quot;,function(data){
				            data.....
				        })

				        如果url后面含有=？,说明这是一个JSONP请求，
				        jQuery会创建一个回调函数，并用回调函数的函数名，代替？号，
				        这个时候getJSON的行为，就像请求脚本文件一样，而不是json对象，



				    JSONP请求，封装：
				        function getJSONP(url,callback){
				            var cbnum = &quot;cb&quot; + getJSONP.counter++; // 计数器
				            var cbname = &quot;getJSONP.&quot;+cbnum;

				            if(url.indexOf(&quot;?&quot;) === -1){
				                url += &quot;?jsonp=&quot; + cbname;
				            }else{
				                url += &quot;&amp;jsonp=&quot;+ cbname;
				            }

				            var script = document.createElement(&quot;script&quot;);
				            getJSONP[cbnum] = function(response){
				                   try{
				                        callback(response);
				                   }
				                   finally{
				                        delete getJSONP[cbnum];
				                        script.parentNode.removeChild(script);
				                   }
				            }

				            script.src = url;
				            document.body.appendChild(script);
				        }
				        getJSONP.counter = 0;  // 创建位移回调函数名称的计数器


				Git是行业标准的版本控制系统的Web开发
				使用Git命令帮助追踪到项目的变化：
				git init创建新的Git仓库
				git status检查工作目录和暂存区的内容
				git add添加从工作目录中文件的暂存区域
				git diff显示工作目录和临时区域之间的差异
				git commit永久存储文件的变化从暂存区的库



				==========================================
				关于jquery
				      $(&quot;div&quot;).width();   ------&gt;内容宽
				      $(&quot;div&quot;).innerWidth(); -----&gt; 内容宽 + padding
				      $(&quot;div&quot;).outerWidth();  ----&gt;内容宽 + padding + border
				      $(&quot;div&quot;).outerWidth(true)  -----&gt;  内容宽 + padding + border + margin

				      $(&quot;div&quot;).innerWidth(200);  ---- &gt; 设置了内容宽180  padding 10
				      $(&quot;div&quot;).outerWidth(200);  ---- &gt; 设置了内容宽178  padding 10    border 1

				      $(&quot;div&quot;).outerWidth(200,true); -----&gt; 内容宽 =  200 - padding - border - margin

				      原生js获取不到隐藏元素的尺寸
				      JQ是可以获取隐藏元素的尺寸

				      可视区的高： $(window).height()  
				      页面的高：  $(document).height();

				      页面的滚动距离： $(document).scrollTop(); 
				      当页面滚动到底部时：
				        $(document).scrollTop() == $(document).height - $(window).height()

				       设置滚动到某个位置： $(document).scrollTop(300);

				       $(&quot;div&quot;).scrollTop();

				       $(&quot;div&quot;).offset().left   ------ 相对于整个页面的， 不是可视区


				       $(&quot;divIn&quot;).offset().left  -------  外层divOut 定不定位， 都不会影响取值，都是相对页面

				       $(&quot;divIn&quot;).position().left  --------   可以获取到相对与divOut的，
				       注意！ 但是不包含无视margin的。就算divOut有margin，但是还是取不到的

				       小技巧： 里层到外层的距离  不管它什么有没有定位
				       $(&quot;divIn&quot;).offset().left - $(&quot;divOut&quot;).offsetParent().offset().left


				       懒加载：
				       $(window).scroll(toChange);
				       function toChange(){
				        $(&quot;img&quot;).each(function(i,e){
				            if( $(e).offset().top &lt;  $(window).height() + $(document).scrollTop() ){
				                 var src =  $(e).attr(&quot;_src&quot;);
				                 $(e).attr(&quot;src&quot;,src);
				            }
				        })
				       }

				=======================================
				jQ事件：
				        在JQ中的事件操作都是绑定的形式，可以绑定多个。
				        $(&quot;div&quot;).on(&quot;click mouseover&quot;,function(){
				          alert(123);
				          $(this).off();  // 删除所有
				          $(this).off(&quot;mouseover&quot;)   //只针对xx
				        })
				        弹出一次  然后就不会弹出了


				        $(&quot;div&quot;).click(function(ev){
				            alert( ev.pageY );   //  相对于整个页面的
				            alert( ev.clientY );   // 相对于可视区
				        })

				        $(&quot;div&quot;).keydown(function(ev){
				            alert( ev.which );
				            alert(  ev.ctrlKey );
				            alert( ev.target );    //事件源
				        })


				        $(&quot;div&quot;).click(function(ev){
				            //什么都不写、 会冒泡到document 
				            ev.stopProgation();   //阻止冒泡
				        })

				        $(document).click(function(ev){
				          alert(&quot;123&quot;);
				        })


				        $(document).contextmenu(function(ev){
				            ev.preventDefault(); //阻止默认事件
				        })


				        在一个函数里 写一个  return false   阻止了默认事件  也组织了冒泡


				        $(&quot;ul&quot;).delegate(&quot;li&quot;,&quot;click&quot;,function(ev){
				              $(this)   -------&gt;   li
				              $(ev.delegateTarget)    -------&gt;找到的是ul
				              $(ev.delegateTarget).undelegate()    -----&gt;取消委托   不要off();  off()是针对on事件的
				        })


				        =============================
				        主动触发：
				            trigger();
				            $(&quot;#input&quot;).click(function(){
				                var li = $(&quot;&lt;li&gt;+$(&quot;#input2&quot;).val()+&lt;/li&gt;&quot;);
				                $(&quot;ul&quot;).append( $li );
				            })
				            $(&quot;#input2&quot;).keydown(function(ev){
				                if( ev.which == 13 ){
				                    $(&quot;#input1&quot;).trigger(&quot;click&quot;);   // 不可能在这里，重新写业务代码吧，我们可以模拟一个触发点击， 就用到它。


				                    //还有一种写法：
				                    $(&quot;#input1&quot;).click();    // 主动触发 
				                }
				            })

				            命名空间的利用：
				            $(&quot;div&quot;).on(&quot;click&quot;,function(){
				                alert(1);
				            })
				            $(&quot;div&quot;).on(&quot;click.abc&quot;,function(){
				              alert(2)
				            })

				            $(&quot;div&quot;).trigger(&quot;click.abc&quot;);    // 只触发对应的


				            运用：
				                拖拽的效果中：
				                $(this).off();   //  这里是把拖拽元素时  所有的document的move 和up事件都取消掉，但是有可能我们是需要的。因此这里存在这bug的问题，利用命名空间：
				                $(ths).off(&quot;mousemove.drag&quot;).off(&quot;mouseup.drag&quot;);

				    ==================================================
				    工具方法，jquery对象方法：也可以被原生js用
				      $.type();  ------------------  查看变量的类型
				      type of   复杂的就判断不出来了
				      而 $.type()比较强大
				      $.type(x);


				      $.isFunction( x ) -----------------------判断是不是函数

				      $.isArray( x )   ----------  是不是数组

				      $.isWindow( window ) -------- 判断是不是window

				      $.isEmptyObject( [] )   -------   判断是不是空

				      $.extent()
				        对象继承操作

				        拷贝的时候，注意一下，默认是浅拷贝的，意思就是json里面还有json,拷贝会出现引用问题

				        如果要实现深拷贝：
				        $.extend(true,x,y);


				    $.proxy();
				    $.proxy( show, document )(a,b);    // 要调用


				    ==================================
				    jQ运动
				    $(&quot;div&quot;).show(&quot;noraml&quot;)  // 400
				    $(&quot;div&quot;).show(&quot;slow&quot;) //600
				    $(&quot;div&quot;).show(&quot;fast&quot;)  //200
				    宽高  透明度 都调整

				    $(&quot;div&quot;).toggle();
				    $(&quot;div&quot;).fadeToggle();
				    $(&quot;div&quot;).slideToggle();

				    $(&quot;div&quot;).animate({
				      left : &quot;+=100&quot;
				    },100,&quot;linear&quot;,function(){
				      alert(&quot;over&quot;)
				    })

				    //第二种写法：
				    $(&quot;div&quot;).animate({
				      left : &quot;+=100&quot;
				    },{
				        duration : 200,
				        easing : &quot;linear&quot;,
				        complete : function(){

				        },
				        step : function(a,b){   --------检测定时器每一次变化
				            console.log(a);
				            console.log(b.pos);    ----- 运动过程中的比例值   0 — 1
				        }
				    })


				    应用：
				    2秒呢 0变化到3903494594

				     $(&quot;div&quot;).animate({
				      num : &quot;move&quot;
				    },{
				        duration : 2000,
				        easing : &quot;linear&quot;,
				        complete : function(){

				        },
				        step : function(a,b){  
				            console.log(a);
				            $(&quot;console&quot;).html(parseInt(b.pos*3903494594
				);    
				        }
				    })


				    运动队列：
				      $(&quot;input&quot;).click(function(){
				          $(&quot;div&quot;).animate({left : 300},1000)
				                      .animate({height : 300},1000)
				                      .animate(width : 300},1000);
				      })
				      同步的方式，一个一个的链式的运动


				      $(&quot;div&quot;).stop();   -------- 默认下，只会停止当前运动
				      $(&quot;div&quot;).stop(true);   --------  停止包括所有后续的链式运动
				      $(&quot;div&quot;).stop(true,true);  ------   停止到指定的目标点  只是当前的到指定的目标点
				      $(&quot;div&quot;).finish();  ------------  所有的包括后续运动都停止到指定目标点


				      $(&quot;div&quot;).mouseover(function(){
				          $(this).animate({width : 100, height:100})
				      }.mouseout(function(){
				          $(this).animate({width : 0,height:0})
				      }))
				      我们快速的移入移出， 会出现的问题是： 移开了还在那里跑，因为有很多队列需要时间去完成。
				      怎么离开立即停止：
				        写成这样： stop()  // 每一次都清空队列

				      $(&quot;div&quot;).mouseover(function(){
				          $(this).stop().animate({width : 100, height:100})
				      }.mouseout(function(){
				          $(this).stop().animate({width : 0,height:0})
				      }))

				      ===============================================

				      $.parseJSON
				            把json类型的字符串转换成真正的json数据


				      $.parseHTML
				            转化html形式的字符串为DOM节点
				            var html = &quot;&lt;div&gt;div&lt;/div&gt;&quot;;
				            var x = $.parseHTML( html );
				            console.log( $.type( x ) );  --------  Array 数组
				            $(&quot;body&quot;).append( x[0] );

				      $.parseXML()  把XML形式的字符串，转成真正的XML节点


				=======================================

				$.ajax();
				  

				插件：
				  $.brower; ----------------   判断哪一种浏览器
				  $.browser.name

				  $.cookie的插件
				        设置：  $.cookie(&quot;name&quot;,&quot;hello&quot;);
				        获取： $.cookie(&quot;name&quot;)
				        关掉浏览器，数据消失
				        如何长期存储：
				        $.cookie(&quot;name&quot;,&quot;hi&quot;,{ expires : 7 })   // 7 天

				jQuery UI
				组件：  一群插件的集合，更强大


				jQuery easyUI
				更强大，更多的是后端
				  

				抽奖练习：
				  $(&#x27;input&#x27;).click(function(){
				    
				    stepNum = Math.floor(Math.random()*$Li.length + $Li.length);
				    
				    var timer = setInterval(function(){
				      
				      $Li.eq(iNow).attr(&#x27;class&#x27;,&#x27;active&#x27;).siblings().attr(&#x27;class&#x27;,&#x27;&#x27;);
				      
				      stepNum--;  
				      if(stepNum == 0){
				        clearInterval(timer);
				        alert( $Li.eq(iNow).html() );
				      }
				      
				      iNow++;
				      if(iNow == $Li.length){
				        iNow = 0;
				      }
				      
				    },100);
				    
				  });


				  左右ul添加li练习：
				    $(&#x27;li&#x27;).click(function(){
				    $(this).toggleClass(&#x27;active&#x27;);
				  });
				  
				  $(&#x27;input&#x27;).click(function(){
				    
				    $($(this).attr(&#x27;from&#x27;)).find(&#x27;.active&#x27;).appendTo( $($(this).attr(&#x27;to&#x27;)) ).removeClass(&#x27;active&#x27;);
				    
				  });



				星星评分：
				      var bBtn = true;
				  var timer = null;
				  $(&#x27;li&#x27;).mouseover(function(){
				    if(bBtn){
				      clearTimeout(timer);
				      $(&#x27;li&#x27;).slice(0,$(this).index()+1).css(&#x27;background&#x27;,&#x27;blue&#x27;);
				      $(&#x27;li&#x27;).slice($(this).index()+1).css(&#x27;background&#x27;,&#x27;red&#x27;);
				    }
				    
				  }).mouseout(function(){
				    if(bBtn){
				      timer = setTimeout(function(){
				        $(&#x27;li&#x27;).css(&#x27;background&#x27;,&#x27;red&#x27;);
				      },100);
				    }
				    
				  }).click(function(){
				    
				    bBtn = false;
				  });


				轮播：
				    var $olLi = $(&#x27;ol li&#x27;);
				  var $ulLi = $(&#x27;ul li&#x27;);
				  var oneWidth = $ulLi.width();
				  var iNow = 0;
				  var timer = null;
				  
				  $ulLi.slice(1).each(function(){
				    $(this).css(&#x27;left&#x27;,oneWidth);
				  });
				  
				  $olLi.mouseover(function(){
				    clearTimeout(timer);
				    timer = setTimeout($.proxy(function(){
				      $(this).attr(&#x27;class&#x27;,&#x27;active&#x27;).siblings().attr(&#x27;class&#x27;,&#x27;&#x27;);
				      var index = $(this).index();
				      
				      if( iNow &lt; index ){
				        $ulLi.eq( $(this).index() ).css(&#x27;left&#x27;,oneWidth);
				        $ulLi.eq(iNow).animate({ left : -oneWidth },400);
				        
				      }
				      else if( iNow &gt; index ){
				        $ulLi.eq( $(this).index() ).css(&#x27;left&#x27;,-oneWidth);
				        $ulLi.eq(iNow).animate({ left : oneWidth },400);
				      }
				      $ulLi.eq( $(this).index() ).animate({ left : 0 },400);
				      
				      iNow = index;
				    },this),400);
				  });



				  ajax实例：
				                var iNow = 0;
				          $(&#x27;#input1&#x27;).click(function(){
				            
				            $.ajax({
				              url : &#x27;add.php&#x27;,
				              type : &#x27;POST&#x27;,
				              data : {val:$(&#x27;#t1&#x27;).val()},
				              dataType : &#x27;json&#x27;, 
				              success : function(data){
				                var $li = $(&#x27;&lt;li&gt;&#x27;);
				                var mainId = data.mainId;
				                $li.html(&#x27;&lt;span mainId=&quot;&#x27;+ mainId +&#x27;&quot;&gt;&#x27;+ data.text +&#x27;&lt;/span&gt; &lt;span class=&quot;close&quot;&gt;X&lt;/span&gt;&#x27;);
				                $(&#x27;ul&#x27;).prepend( $li );
				              }
				            });
				            
				          });
				          
				          $(&#x27;ul&#x27;).delegate(&#x27;span.close&#x27;,&#x27;click&#x27;,function(){
				            var $elem = $(this);
				            $.ajax({
				              url : &#x27;remove.php&#x27;,
				              data : {&#x27;mainId&#x27; : $elem.attr(&#x27;mainId&#x27;) },
				              success : function(data){
				                $elem.parent().remove();
				              }
				            });
				            
				          });
				          
				          $(&#x27;#input2&#x27;).click(function(){
				            iNow++;
				            $.ajax({
				              url : &#x27;loadPage.php?num=&#x27;+iNow,
				              dataType : &#x27;json&#x27;,
				              success : function(data){
				                
				                for(var i=0;i&lt;data.length;i++){
				                  var $li = $(&#x27;&lt;li&gt;&#x27;);
				                  var mainId = data[i].mainId;
				                  var text = data[i].text;
				                  $li.html(&#x27;&lt;span mainId=&quot;&#x27;+ mainId +&#x27;&quot;&gt;&#x27;+text +&#x27;&lt;/span&gt; &lt;span class=&quot;close&quot;&gt;X&lt;/span&gt;&#x27;);
				                  
				                  $(&#x27;ul&#x27;).append( $li );
				                }
				              }
				              
				            });
				            
				          });


				          add.php
				              &lt;?PHP

				              $a = $_POST[&quot;val&quot;];
				              
				              $arr=array();
				              $arr[&quot;mainId&quot;]=&quot;111111&quot;;  
				              $arr[&quot;text&quot;]=&quot;$a&quot;;  
				              
				              echo json_encode($arr); 

				            ?&gt;



				            loadPage.php
				            &lt;?PHP

				              if( $_GET[&quot;num&quot;] == 1 ){
				                echo &#x27;[{&quot;mainId&quot;:&quot;3456666&quot;,&quot;text&quot;:&quot;回到房间打开饭盒&quot;},{&quot;mainId&quot;:&quot;345646666&quot;,&quot;text&quot;:&quot;sdfsdfff&quot;},{&quot;mainId&quot;:&quot;345896666&quot;,&quot;text&quot;:&quot;分哈哈哈哈哈&quot;}]&#x27;;
				              }
				              else if( $_GET[&quot;num&quot;] == 2 ){
				                echo &#x27;[{&quot;mainId&quot;:&quot;345668866&quot;,&quot;text&quot;:&quot;ssssssssss&quot;},{&quot;mainId&quot;:&quot;3456462666&quot;,&quot;text&quot;:&quot;llkkkkk&quot;},{&quot;mainId&quot;:&quot;345896666&quot;,&quot;text&quot;:&quot;痘痘的都&quot;}]&#x27;;
				              }
				              else if( $_GET[&quot;num&quot;] == 3 ){
				                echo &#x27;[{&quot;mainId&quot;:&quot;3411156666&quot;,&quot;text&quot;:&quot;回到s房间打开饭盒&quot;},{&quot;mainId&quot;:&quot;3456464666&quot;,&quot;text&quot;:&quot;对对对&quot;},{&quot;mainId&quot;:&quot;3458966666&quot;,&quot;text&quot;:&quot;ffff&quot;}]&#x27;;
				              }

				            ?&gt;

				=============================================
				jQuery高级部分：
				        清空元素里 内容：
				            $(&quot;div&quot;).empty();

				        删除节点：
				        $(&quot;div&quot;).click(function(){
				          alert(&quot;23&quot;)
				        })
				        var oDiv = $(&quot;div&quot;).remove();
				        $(body).append(oDiv); -----------  事件也被删掉了

				        var oDiv = $(&quot;div&quot;).detach();  ---------------   再次添加回来事件还在


				        替换节点：
				            $(&quot;span1&quot;).replaceWith( $(&quot;div1&quot;) );
				            div1把span1替换掉

				            $(&quot;span1&quot;).replaceAll( $(&quot;div1&quot;) );
				            span1去替换div1

				移上去移开  解决冒泡产生的问题：mouseenter、mouseleave
				      $(&quot;div1&quot;).mouseenter(function(){
				          $(&quot;div2&quot;).animate({top:0})
				      })
				      $(&quot;div1&quot;).mouseleave(function(){
				          $(&quot;div2&quot;).animate({top:-100})
				      })


				光标移入：
				    $(&quot;input&quot;).on(&quot;focus&quot;,function(){
				        alert(13);
				    })

				    focus、blur 这两个，没有冒泡。 只支持input textarea...
				    如果我需要冒泡： focusin、focusout
				        $(&quot;div1&quot;).on(&quot;focusin&quot;,function(){
				          alert(&quot;hei&quot;)
				        })

				只触发一次的事件： one
				    $(&quot;div&quot;).one(&quot;mouseover&quot;,function(){
				        aelrt(&quot;hei&quot;)
				    })

				on 事件  各个参数：
				  $(&quot;div&quot;).on(&quot;click&quot;,&quot;span&quot;,{name:&quot;hello&quot;},function(ev){
				          console.log( ev.data.name );
				          alert(123); --------  点击div里的span 才会弹出
				  })

				  $(&quot;div&quot;).delegate(&quot;span&quot;,&quot;click&quot;,function(ev){
				      alert(132)
				  })
				 其实 上面的on  跟 这里的delegate 是一样的

				changedTouches:
				 $(&quot;div&quot;).on(&quot;touchstart&quot;,function(ev){
				        alert( ev.changedTouches ); -------------  找不到的，因为ev是jquery封装的，并非原生的。如果获取原生的ev ：

				        ev.originalEvent -----------------  原生的ev
				        ev.originalEvent.changedTouches  -----  找到
				 })


				 =====================
				 自定义事件：  滚轮 放大缩小地图
				      $(&quot;img1&quot;).on(&quot;zoomIn&quot;,function(){  ----------  缩小事件
				              $(this).css(&quot;width&quot;,200)
				      })

				      $(&quot;img1&quot;).on(&quot;zoomOut&quot;,function(){  ----------  放大事件
				              $(this).css(&quot;width&quot;,100)
				      })

				      $(&quot;img1&quot;).on(&quot;DOMMouseScroll&quot;,function(ev){
				          if( ev.originalEvent.detail &gt; 0 ){
				              $(this).trigger(&quot;zoomIn&quot;);
				          }else{
				              $(this).trigger(&quot;zoomOut&quot;);
				          }
				      })

				====================================
				冒泡第二种写法
				$(&quot;div1&quot;).on(&quot;click&quot;,function(){
				    alert(1234)
				})
				$(&quot;span1&quot;).on(&quot;click&quot;,function(){
				    ev.stropPropagation();   --------  阻止冒泡  点击后不弹1234   自身的事件不会阻止

				    ev.stopImmediatePropagation();   -------  阻止冒泡  自身的事件 也阻止

				    alert(&quot;span的事件会触发吗？&quot;)
				})


				==============================
				鼠标键值：
				  $(&quot;obj&quot;).on(&quot;mousedown&quot;,function(ev){
				          alert( ev.which );
				  })

				==========================
				$(document).ready(function(){})   ---------------   DOM加载完就会执行  解析速度更快   可能存在   图片没加载完  获取到的width() 可能会不同  过一下就变了

				$(window).onload(function(){})   --------  整个页面加载完才会执行


				========================
				数据缓存：
				      $(&quot;div&quot;).data(&quot;name&quot;,&quot;hello&quot;);
				      alert( $(&quot;div&quot;).data(&quot;name&quot;) );

				      attr 也可以实现

				      二者区别：
				      attr :   属性  属性值  往dom元素身上添加
				      data  :  数据存到了一个大的集合中   可以防止内存泄漏  方便缓存大量数据

				      $(obj).removeData(&quot;name&quot;);
				      $(obj).removeAttr(&quot;name&quot;);
				      $(obj).removeProp(&quot;name&quot;);

				=========================
				  prop()
				      var bBtn = true;
				      $(&quot;input[type=button]&quot;).click(function(){
				            if( bBtn ){
				                  $(&quot;input[type=checkbox]&quot;).prop(&quot;checked&quot;,true)
				            }else{
				                  $(&quot;input[type=checkbox]&quot;).prop(&quot;checked&quot;,false)
				            }
				            bBtn = ! bBtn;
				      })

				===========================

				var a  = [1,2,3];
				var b = [4,5,6];
				var c = $.merge(a,b)
				console.log( c );


				var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;];
				var arr1 =  $.map( arr, function(val,i){
				      return xxxx;  // 重新操作数组
				} )


				var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;];
				$.inArray(&quot;b&quot;,arr)  ------------ 1


				aLi  ----------------  类数组
				$.makeArray( aLi )   -----------------   转成数组


				var str = &quot;  hello  &quot;;
				$.trim( str )  ------------------  清掉空格


				=================================
				字符串查询  url 查询  拼接  $.param()
				var obj = { &quot;name&quot; :  &quot;hello&quot;, &quot;age&quot; : &quot;20&quot; }
				obj = $.param( obj );
				console.log( obj ); -------------  name=hello&amp;age=20


				&lt;form&gt;
				  &lt;input type=&quot;text&quot; name=&quot;a&quot; value=&quot;1&quot;&gt;
				  &lt;input type=&quot;text&quot; name=&quot;b&quot; value=&quot;2&quot;&gt;
				  &lt;input type=&quot;text&quot; name=&quot;c&quot; value=&quot;3&quot;&gt;
				&lt;/form&gt;
				//只是针对form中的name、value形式


				var a =$(&quot;form&quot;).serialize();   ---------------- a=1&amp;b=2&amp;c=3

				$.ajax({
				  data : a
				})

				var b = $(&quot;form&quot;).serializeArray();  -------  数组形式
				        [
				          {  name : &quot;a&quot;, value : &quot;1&quot;},
				          {  name : &quot;b&quot;, value : &quot;2&quot;},
				          {  name : &quot;c&quot;, value : &quot;3&quot;}
				        ]

				==========================
				$.each()

				$.each(arr,function(i,val){
				    console.log(i)
				    console.log(val)
				})

				$.each(json,function(i,val){
				      
				})








				1、 window在PHP开发环境搭建
				    WAMP平台？
				    W:windows操作系统
				    A:apache服务器
				    M:mysql数据库
				    P: PHP语言

				    集成开发环境？
				    就是一个软件安装成功之后，三个软件都安装成功了。
				    WAMP软件
				    appserv软件
				    PHPstorm
				    XAMPP


				    AppServ：
				       安装完后的目录下的  apache24---config----httpd.conf修改配置

				       C:\AppServ\MySQL\data\mysql
				       这里是我建好的数据

				        php里的php.ini文件
				        可以设置配置

				        www 目录
				        所有的php文件都在这里

				        php.info.php文件
				        输入所有php的配置信息
				        http://localhost:60/phpinfo.php

				        我设置了端口 60
				        http://localhost:60/

				        集成开发环境工具：
				            能够编辑PHP代码
				            能进行调试
				            能运行php文件
				            能提高开发效率
				        phpstrom 、 zendstudio

				2、 phpstrom
				        配置localhost
				        Run----- Edit  config...------设置好
				        run


				3、 什么是php
				    hypertext preprocess
				    超文本预处理器
				    可以嵌入到html页面中的脚本语言
				    语法借鉴了c语言、perl语言的语法风格

				4、 php特点：
				    可以嵌入Html
				    支持关系型数据库、nosql数据库
				    任何操作系统下都可以开发php

				5、  FaceBook网站是全球第一个使用php进行开发的网站

				6、  hello.php文件
				     里面是html结构，后缀为php，没关系。
				     运行
				     借助一个工具： FileZilla
				     链接到服务器上
				     文件上传到服务器的根目录


				7、&lt;?phh  开始
				   ?&gt;  结束
				   单行注释：   //
				   多行注释：  /* */
				    php是一个相对比较安全的语言，在进行执行php后，在页面上看不到任何php代码


				8、php中的变量：
				    可变的量
				    由字母、数字及下划线组成，不能使用数字作为开头，中间不能包含特殊的句点，要有一定的语义

				    声明标量： $变量名=值
				    php语言是弱类型的语言，就是说对语法格式要求不是特备的严格，所有在定义变量时不需要为其
				    指定数据类型，定义变量赋值时会自动分配数据类型

				    $name=&quot;xxx&quot;;

				    使用： 直接$变量名进行使用就可以了，在使用变量时一定不要将变量前的$符号丢了

				    //非法的变量：
				    $3php = &quot;abc&quot;;
				    不要用数字开头，  字母下划线都可以的

				    可变变量：
				        就是I一个变量名可以变化的，我们可以使用一个变量的值，作为另外一个变量的变量名


				    变量的引用：
				        在定义一个变量时，我们可以将另外一个变量的值和地址同时赋值给这个变量

				        $in = 10;
				        $out = $in;
				        echo $out;


				9、 变量的数据类型：
				        1)、 $bool = true; 布尔类型
				        2)、 $int = 12;  数字类型
				        3)、 $str = &#x27;string type&#x27;;  字符串类型
				             单引号定义： 执行的速度更快一些
				             双引号定义： 能够解析变量   &quot;{$num}&quot;

				        4)、 $double = 3.1415926;  浮点
				        5)、 $arr = array(1,2,3);   数组
				        6)、 class Test{ }  $t = new Test()   对象
				        7)、 $f = fopen(&#x27;test.txt&#x27;,w)  echo &#x27;&lt;br&gt;&#x27;.gettype($f) ----- resouce 资源类型
				        8)、 echo &#x27;&lt;br&gt;&#x27;.gettype($e);  ----- null  没有定义$e


				10、 数据类型之间转换
				        1)、 自动转换：
				                在各个变量进行运算过程中自动进行相应的转换
				                整形 会转换成 浮点型
				                字符串和布尔 会转换成浮点
				                所有类型都会自动向浮点类型转换
				            $int = 12;
				            $double = 3.1415;
				            $re = $int + $double;
				            var_dump( $re )   //_dump 能够打印变量的值和类型 自动输出功能

				            $str = &#x27;12abc&#x27;;
				            $re = $int + $str;
				            var_dump( $re )   //   这个时候字符串里有数字字符， 会转换为数字

				            $re = $double + $str;
				            var_dump( $re )

				            $re = $bool + $double;
				            var_dump($re)

				        2)、 强制转换
				                (类型关键字)$变量名
				                (int) (integer) 整形
				                (bool) (boolean) 布尔
				                (string)
				                (array)
				                (double)(float)(real)
				                (object)
				                (resource)

				                $str = &quot;1.345aaa&quot;;
				                var_dump( (int)$str );  //强制转换为 int整形


				        3)、 变量类型的判断
				                is_int()
				                is_bool()
				                is_string()
				                is_double()
				                is_array()
				                is_object()
				                is_numeric()


				11、  php中的常量
				       不变的量，一个常量一旦被定义了就不能进行修改

				       定义：
				            define(&quot;常量名&quot;，&quot;常量值&quot;，[&#x27;是否区分大小写默认false&#x27;])

				        常量的命名规则：
				        和变量命名规则一样，常量的命名一般采用大写的方式

				       常量的使用：
				       直接使用常量的名称

				        define(&quot;Pi&quot;,2.1);
				        echo Pi;

				12、  php中的运算符
				      1)、算术运算符：  + - * / % ++ --

				          $a = 12;
				          $b = $a++; 后加加，先运算后加// $b = ++$a;前加加 ，先加后运算 //  有区别
				          echo $a.&#x27;&lt;br&gt;&#x27;.$b;

				      2)、字符串运算符
				           .     链接2个字符串
				           ,     也是链接2个字符串

				      3)、 赋值运算符
				            $c =1;
				            $c += 12;

				      4)、  比较运算符
				            ==
				            ===
				            &gt;
				            &lt;
				            &gt;=
				            &lt;=
				            !=
				            !==

				      5)、 逻辑运算符
				            and &amp;&amp;
				            or ||
				            not  !
				            xor  ----   x1 xor x2    -----&gt; x1  x2不一样  ==》true

				      6)、 三元运算符
				            $sany = (true and true) ? &quot;yes&quot; : &quot;no&quot;;


				13、php中的分支结构
				        1)、 概念： 就是程序在运行过程中可能会有多种情况发生，此时我们需要使用php中的分支语句去控制程序的流程走向
				        2)、 if分支结构
				                 单分支  if(){}  一件事情发生只有一种结果
				                 双分支  if(){}else{}  2种结果
				                 多分支   if(){} else if(){} else if(){}  2种以上
				                 分支的嵌套  if语句中还有一个或一个以上的if语句
				                 switch case 分支结构



				14、 php中的for循环
				        1)、for循环：  一般用于有规律的循环
				            for($i = 1; $i&lt;10; $i++){
				                echo $i, &#x27;&lt;br&gt;&#x27;;
				            }

				        2)、  while循环  ： 一般用于数据库中的数据的遍历
				            while(条件){
				                循环体
				                循环递增
				            }

				            $i = 1;
				            while( $i&lt;=10 ){
				                echo $1 . &#x27;&lt;br&gt;&#x27;;
				                $i++;
				            }

				        3)、do while循环
				            do{
				                循环体
				                递增
				            }while()

				            $i = 10;
				            do{
				                echo $i.&#x27;&lt;br&gt;&#x27;;
				            }whiel( $i&lt;=10 );


				15、php中数组的定义
				        1、
				        $arr = array(1,2.2,true,&#x27;abc&#x27;);

				        $arr2[0] = 123;
				        $arr2[1] = &quot;456&quot;;

				        二维数组：
				        $arr3 = array(
				            array(1,2,3,4),
				            array(&#x27;a&#x27;,&#x27;b&#x27;),
				            array(20,&#x27;c&#x27;)
				        )

				        关联数组的定义：
				        $stu = array(
				            &quot;stu_1&quot; =&gt; array(&quot;name&quot; =&gt; &quot;jack&quot;,&quot;age&quot; =&gt; 23, &quot;addr&quot; =&gt; &quot;beijing&quot;),
				            &quot;stu_2&quot; =&gt; array(&quot;name&quot; =&gt; &quot;jack2&quot;,&quot;age&quot; =&gt; 25, &quot;addr&quot; =&gt; &quot;beijing&quot;),
				            &quot;stu_3&quot; =&gt; array(&quot;name&quot; =&gt; &quot;jack3&quot;,&quot;age&quot; =&gt; 24, &quot;addr&quot; =&gt; &quot;beijing&quot;),
				        )
				        echo &quot;&lt;br&gt;&quot; . $su[&quot;stu_1&quot;][&quot;name&quot;];


				        $stu2 = array(&quot;name&quot; =&gt; &quot;wangz&quot;,3=&gt;12,&#x27;guangzhou&#x27;)

				        2、
				        索引遍历
				        $arr = array(12,3,44,&quot;bar&quot;);

				        for循环遍历：
				        for($i=0;$i&lt;count($arr);$++){
				            echo $arr[$i].&quot;&lt;br&gt;&quot;;
				        }

				        ----------------------

				        foreach遍历数组  一般用于遍历关联数组
				        foreach($arr as $key=&gt;$value){
				            echo $key.&#x27;=&gt;&#x27;.$value.&#x27;&lt;br&gt;&#x27;;
				        }

				        ------------------------
				        二维索引数组
				        $arr2 = arr(
				            array(12,434,5,6),
				            array(1,3,56,2),
				            array(&quot;c&quot;,&quot;d&quot;,&quot;df&quot;)
				        )
				        for( $j=0;$j&lt; count( $arr2 ); $j++ ){
				            for( $m=0; $m&lt;count( $arr2[$j] ); $m++ ){
				                echo $arr2[$j][$m].&quot;-&quot;;
				            }
				        }

				        ---------------------------
				        遍历关联数组：
				        $arr = arr( &quot;name&quot; =&gt; &quot;ksdkf&quot;, &quot;age&quot;=&gt;23, &quot;addr&quot;=&gt;&quot;beijing&quot;);
				        foreach( $arr as $k =&gt; $v ){
				            echo $k.&quot;=&gt;&quot;.$v.&#x27;&lt;br&gt;&#x27;;
				        }



				        $arr2 = array(
				            &#x27;std_1&#x27; =&gt; array(&#x27;name&#x27; =&gt; &#x27;dfd&#x27;, &#x27;age&#x27;=&gt; 34, &#x27;fe&#x27;=&gt; &#x27;beijing&#x27;),
				            &#x27;std_2&#x27; =&gt; array(&#x27;name&#x27; =&gt; &#x27;sdf&#x27;, &#x27;age&#x27;=&gt; 36, &#x27;fe&#x27;=&gt; &#x27;guangzhou&#x27;),
				            &#x27;std_3&#x27; =&gt; array(&#x27;name&#x27; =&gt; &#x27;fgf&#x27;, &#x27;age&#x27;=&gt; 21, &#x27;fe&#x27;=&gt; &#x27;shenzhen&#x27;)
				        );
				        echo &#x27;&lt;table width=&quot;80%&quot; border=&quot;1&quot; cellpadding=&quot;10&quot; align=&quot;center&quot;&gt;&#x27;;

				        foreach( $arr2 as $v ){
				            echo &#x27;&lt;tr align=&quot;center&quot;&gt;&#x27;;

				        //列
				            foreach( $v as $value ){
				                echo &#x27;&lt;td&gt;&#x27;. $value . &#x27;&lt;/td&gt;&#x27;;
				            }
				            echo &#x27;&lt;/tr&gt;&#x27;;
				        }


				        -----------------------

				        list()遍历  用于接收数组中的下标为索引的元素值  按从左到右的顺序给list()函数中的每一个变量进行依次赋值
				        each()遍历  用于一次性得到数组中的元素的值和下标

				        list($a, $b, $c) = array(&#x27;1&#x27; =&gt; &#x27;abc&#x27;,12,13,32);
				        echo $a.&#x27;&lt;br&gt;&#x27;;
				        echo $b.&#x27;&lt;br&gt;&#x27;;
				        echo $c.&#x27;&lt;br&gt;&#x27;;


				        $arr2 = array(1,3,5,6,2);
				        var_dump( each($arr2) );


				16、 操作数组的函数：
				       is_array()
				--------
				       $arr = array();
				       if( is_array($arr) ){
				        echo &#x27;是数组&#x27;；
				       }else{
				        echo &#x27;不是数组&#x27;；
				       }

				--------
				       implode();

				       $arr2 = array(&#x27;hello&#x27;,&#x27;php&#x27;,&#x27;i&#x27;);
				       $mes = implode(&#x27; &#x27;, $arrNew);
				       echo $mes. &#x27;&lt;br&gt;&#x27;;   //-------  hellophpi

				--------
				       unset()

				       unset( $arr2[1] )   // ----- 删掉其中一个

				--------
				       range();  //建立一个包含指定范围单元的数组

				       $arr = range(1,30);
				       echo &#x27;&lt;pre&gt;&#x27;;
				       var_dump($arr4);

				--------
				       array_keys  //返回键名

				      $arr =array(&#x27;name&#x27; =&gt; &quot;kskf&quot;,&#x27;age&#x27;=&gt;&#x27;23&#x27;)
				       $keys = array_keys($srr)
				       echo &#x27;&lt;pre&gt;&#x27;;
				       var_dump($keys)

				--------
				       arr_merge() // 数组合并

				       $merge = array($arr1, $arr2);
				       echo &#x27;&lt;pre&gt;&#x27;;
				       var_dump($merge)


				--------
				        sort();  // 升 排序
				        $arr = array(233,4,64,23)
				        sort($arr);
				        var_dump( $arr )

				--------
				        rsort()  //降 排序

				--------
				        asort();  // 升 排序 保留下标

				--------
				        arsort();  // 将 排序 保留下标

				--------
				        in_array();  // 是否在数组中
				        if( in_array(12,$arr) ){ echo &quot;在数组中&quot; }

				--------
				        array_pop()  删除最后一个

				-------
				        array_shift() 删除第一个

				--------
				        array_push()  最后添加

				--------
				        array_unshift() 前面添加


				17、 数组指针操作函数

				        指针： 把索引数组中的索引下标，看成我们指针所指向的位置
				        end ----- 将数组的内部指针指向最后一个单元
				        current ----- 返回数组中的当前单元
				        reset ----- 将数组的内部指针指向第一个单元
				        next -----  将数组中内部指针向前移动一位
				        prev ----- 将数组的内部指针倒回一位



				18、 php中的函数
				        1)、
				            定义一个1-100累加和的函数
				            function sum(){
				                $sum = 0;
				                for( $i =1; $i &lt; 101; $i++ ){
				                    $sum += $i;
				                }
				                return $sum;
				            }
				            $re = sum();
				            echo $re;

				            //判断函数是否存在
				            if( function_exists(&quot;get&quot;) ){ get() }


				        2)、 参数传递
				            func_num_args()  得到传的参数的个数
				            func_get_args()  得到参数值
				           func_get_arg()得到参数值 一次性获得一个


				            function sum( $a, $b ){
				                return $a + $b;
				            }
				            $re = sum(10,20);
				            echo $re;


				            //可变参数的函数
				            function funArgs(){
				                echo &#x27;给函数传递了&#x27;.fun
				            }



				19、变量的作用域
				        就是有效范围
				        全局变量 ：  在函数内不能直接使用，我去； 若要用，函数内这样： global $x;
				        局部变量 :  函数外不能用
				        静态变量：  用static 属于整个函数的，函数每调用一次，记录上一次改变后的结果：
				                    function test(){
				                        $a = 10;
				                        $++;
				                        echo $a.&#x27;&lt;br&gt;&#x27;;
				                    }
				                    test()
				                    test()
				                    上面的输出是  10 10

				                    function test(){
				                        static $a = 10;
				                        $++;
				                        echo $a.&#x27;&lt;br&gt;&#x27;;
				                    }
				                    test()
				                    test()
				                    输入 ：  11 12


				20、 常用的数学函数
				        1)、 abs( $x );  ----- 绝对值
				        2)、 ceil();  ------ 进一  取整 无论大不大于5
				        3)、 floor();  ------ 退一 取整 无论大不大于5
				        4)、 round();   ------ 对浮点进行四舍五入
				        5)、 max();  ------找最大的 $arr = range(1,30);  echo max($arr);
				        6)、 min(); ---------  找最小的 min(1,34,-3,24)
				        7)、 rand(); ------  生成随机数  rand(5,10);  5-10产生随机数
				        8)、 pi() ----- 得到圆周率值
				        9)、 mt_rand();   ---- 生成更好的随机数 mt_rand(1,8)


				21、 文件包含
				    include() 用来包含指定目录下的文件
				    require() 用来包含指定目录下的文件
				    文件不存在， include 报错 不影响执行
				    文件不存在， require报致命错误， 程序终止 require安全性更高 推荐使用

				    include(&#x27;./xxx.php&#x27;);
				    require &#x27;./xxx.php&#x27;;
				    test();   ----- 调用xxx.php里的方法

				    require_once 也可以实现
				    而且用这个的好处是，如果文件中已经有了，它就不再去包含了
				    它有一个搜索排查的过程  效率比较低



				22、php预定义变量
				    超全局数组
				    在整个页面中的任意位置都可以使用，无论是在函数内，还是在函数外，都可以使用。
				    超牛逼的意思

				    1)、 $GLOBALS ----- 引用全局作用域中可用的全部变量，定义的全局变量会自动加到$GLOBALS这个数组中去，使用变量名称作为数组的下标。

				        $a = 12;  // 声明之后 自动就成为了$GLOBALS的属性了
				        $b = 10;
				        function test(){
				            $c = $GLOBALS[&#x27;a&#x27;]+$GLOBALS[&#x27;b&#x27;];   // 可以这样用
				            return $c;
				        }
				        echo &#x27;&lt;pre&gt;&#x27;;
				        var_dump( $GLOBALS )


				    2)、 $_SERVER  ---- 服务器和执行环境信息

				    3)、 $_GET   http get变量， 用于接收使用url传递参数信息或者使用get方式提交的表单数据
				         echo &#x27;用户名：&#x27;.$_GET[&#x27;uname&#x27;].&#x27;,密码：&#x27;.$_GET[&#x27;pass&#x27;].&#x27;&lt;br&gt;&#x27;;

				         http://localhost:60/test/myPhp.php?uname=jack&amp;pass=111


				    4)、$_POST

				        echo &#x27;&lt;pre&gt;&#x27;;
				        var_dump( $_POST );
				        echo &#x27;用户名：&#x27;.$_POST[&#x27;uname&#x27;].&#x27;&lt;br&gt;密码：&#x27;.$_POST[&#x27;pass&#x27;];
				        ?&gt;

				        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;
				            &lt;p&gt;
				                用户名： &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;
				            &lt;/p&gt;
				            &lt;p&gt;
				                密码： &lt;input type=&quot;password&quot; name=&quot;pass&quot;&gt;
				            &lt;/p&gt;
				            &lt;p&gt;
				                &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
				            &lt;/p&gt;
				        &lt;/form&gt;

				    5)、 $_REQUEST
				       无论使用get/post方法，都可以接收到



				23、 php系统常量
				        define();

				        1)、预定义常量
				            echo &#x27;当前php的版本为&#x27;.PHP_VERSION

				        2)、魔术常量
				            __LINE__ -------&gt;  获得php行的行号
				            __FILE__ -------&gt; 文件的完整路径和文件名
				            __DIR__  -------&gt; 文件所在的目录
				            __FUNCTION__  -----&gt; 函数名称
				                    function test(){
				                        echo __FUNCTION__;
				                    }
				            __CLASS__ ----&gt;  类名称



				    注意：  页面乱码？
				            header(&#x27;content-Type:text/html; charset=utf-8&#x27;);//设置页面显示的默认编码

				24、 常用的时期与时间函数
				        时间戳： 从1970年1月1日0时0分0秒到现在时间的总秒数

				        1)、 date()

				                echo &#x27;今天是 ：&#x27;.date(&#x27;Y-m-d H:i:s&#x27;).&#x27;&lt;br&gt;&#x27;;

				        2)、 如何设置当前的默认时区
				            date_default_timezone_set(&#x27;PRC&#x27;);

				        3)、 getdate
				            var_dump( getdate() )

				            echo&#x27;今天是：&#x27; .$date_arr[&#x27;year&#x27;].&#x27;年&#x27;.$date_arr[&#x27;mon&#x27;].&#x27;月&#x27;.$date_arr[&#x27;mday&#x27;].&#x27;日&lt;br&gt;&#x27;;



				        4)、 mktime   时间戳
				           echo mktime(12,12,12,12,12,2012);


				        5)、 strtotime  将任何英文文本的日期时间描述解析为unix时间戳
				            echo strtotime(&#x27;now&#x27;), &#x27;\n&#x27;;
				            echo strtotime(&#x27;10 September 2000&#x27;)
				            echo strtotime(&#x27;+1 week&#x27;)

				        6)、time()
				         返回系统当前的时间戳
				            echo time();


				25、 常用的字符串输入函数
				        1)、 echo  ---- 输出一个或者多个字符串  不是一个函数

				        2)、 print  ---- 输出字符串  只能

				        3)、 print_r ----- 打印多种数据类型 数组啊....

				        4)、exit ---- 输出一消息 并退出当前脚本
				                exit(&#x27;结束&#x27;)；  ====等同于  die()

				        5)、 printf ---- 输出格式化字符串

				        6)、 var_dump  ----- 打印变量相关信息


				26、字符串格式化函数
				        1)、 addslashes()  ----
				            防止sql注入
				            然而常用来防止sql注入，我们用 mysqli_real_escape_string()

				        2)、ord()
				            echo ord(&#x27;a&#x27;);  ---- 返回a 的编码号
				            echo chr(97); ----- 返回 97编码的字符

				        3)、htmlentities
				            字符转换成html

				        4)、 ltrim  删除字符串开头的空白字符
				            var_dump( ltrim(&#x27;  xx  &#x27;, &#x27; &#x27;) ); // 第二个参数没有，默认删空格  有，就删除指定的

				        5)、rtrim 删除字符串结尾的空白字符

				        6)、strtolower() 转小写

				        7)、strlen  字符串长度
				                echo strlen(&#x27;abc的&#x27;)； // 6个字节   注意中文 3个

				        8)、strpos 查找字符首次出现的位置

				        9)、strrpos 最后一次出现的位置

				        10)、implode 将一个数组值转化为字符串
				                $arr = range(1,18);
				                echo &#x27;&lt;br&gt;&#x27;. implode(&quot; &quot;,$arr);  //用空格进行拼接

				        11)、 explode  字符串分隔成数组
				                $str = &#x27;a,b,c,d,e&#x27;;
				                explode(&#x27;,&#x27;,$str);

				        12)、 substr 截取
				                substr($str,0,3)

				              截取的是中文 字节问题怎么办？

				              mb_substr
				              $str = &quot;实例&quot;;
				              mb_substr($str,0,3,&#x27;utf-8&#x27;); //不会乱码  记得要加上 header....


				27、 mysql数据库常用指令
				        关系型
				        表和表之间
				        没有任何图形操作界面的数据库 需要用命令完成 有第三方提供可视化的

				        非关系型
				        新的数据库 monngodb数据库

				        DB : database 数据库
				        DBA :  database admin... 数据库管理员
				        DBMS ： database management stystem 数据库管理系统

				        常用的命令：

				            1)、 数据库的连接命令：  mysql -u root -p   // 回车后输入密码 root
				                cmd  ---&gt; 输入这个
				                然后所有操作都在这里进行
				            2)、查看所有数据库列表： show databases;   // 注意这里要 ;号结束

				            3)、创建数据库： create database 数据库名；

				            4)、选择数据库： use 数据库名

				            5)、查看当前数据库中所有的表列表： show tables;

				            6)、查询创建某个表的语句：show create table 表名;

				            7)、 删除数据库：  drop database 数据库名;

				            8)、备份指定的数据库： mysqldump -u root -p mysql &gt; e:test/mysql.sql; 这个命令要在 退出mysql之后 输入
				                之后发现在 e下面 test文件在 备份了 数据库

				            9)、 退出mysql控制台： quit

				            10)、 恢复指定的数据库： mysql -u root -p test &lt; e:/test/mysql.sql;   // 这个也是在cmd下  而不是sql下   注意：在执行这个恢复命令之前，要在mysql中新建一个空的数据库


				28、 mysql中表的创建与删除
				        表的类型
				            myisam: 一般查询频率比较高时，使用此类型，速度更快， 支持全文索引
				            innodb: 频繁进行写操作的时候使用，支持事务；事务就是表在操作时会有多个步骤来完成，保证所有步骤都是成功的，这时整个事务才能提交。若出错，整个事务会进行回滚rollback,也就是整个事务失败了。


				            1)、 创建表的语句：
				                    create table 表名(
				                       字段名 数据类型 响应约束，
				                       ....
				                    )

				                    关键字：
				                        auto_increment 自动递增 一般我们会将表中的id字段添加此约束，就是我们插入数据时，可以不为此字段添加数据，此数据按照等差数列从一到指定的最大值进行递增。
				                        unsigned 无符号的  用于约束数值的类型 此字段只允许插入正数
				                        unique  唯一的  一般用于约束用户名
				                        default 默认值
				                        not null 不为空
				                        primary key 主键   主键就是表中能唯一标识表中的每一行数据的键值
				                        外键 ： 就是一个表中的主键，在另外一个表中出现了  用于链接这2个有关系的两张表的， 在另外一张表中 我们称这个键为外键


				                        查看表结构：
				                                desc 表名；


				                        create table stu_info(
				                            stu_id int(4) not null auto_increment primary key,
				                            std_name varchar(20) not null unique,
				                            stu_sex tinyint(1) default 1
				                        )engine = myisam default charset = utf8;


				            2)、 表结构的修改
				                    alter table 表名 action (修改操作)

				                    添加新列
				                            add 列名 数据类型 约束 (first/after)

				                            alter table stu_info add stu_tel int(11) not null;


				                    删掉列：
				                            drop 列名
				                            alter table stu_info drop id;

				                    添加主键：
				                        add primary key(字段名)
				                        alter table stu_course add primary key(id);

				                    删除主键：
				                        drop primary key;
				                        alter table  stu_course drop primary key;

				                    修改表名：
				                        rename as 新名称
				                        alter table stu-course rename as stu_courses;

				                    修改列的间隙：
				                        change 用于修改表中的某一个字段，同时修改了这个字段的名称时使用
				                        alter table stu_courses change id cid int(4) not null auto_increment

				                        modify 用于修改某一个字段的 出来字段名以外的其他的属性值 使用
				                        alter table stu_courses modify id int(4) not null auto_increment


				29、向mysql表中插入、删除、修改数据
				        1)、 插入数据
				                insert into 表名(字段) values(&#x27;值列&#x27;)
				                当我们向表中的所有列插入数据时，表名后的括号可以省略
				                insert into stu_info values(1,&#x27;jie&#x27;,&#x27;1,&#x27;北京&#x27;,&#x27;112333&#x27;)

				        2)、删除数据
				                delete from 表名 where 条件表达式
				                一定要加where条件，否则会删除所有，慎用。
				                delete  from stu_info where stu_id=4;

				        3)、修改数据
				                update 表名 set 字段名 = 新值， 字段名=新值... where 条件表达式;
				                一定要加where 条件 否则修改所有 慎用

				30、 查询mysql表中数据
				        1)、查询mysql表中数据


				        2)、查询表中所有数据
				              select * from stu_info;
				               乱码的话： set names gb2312;

				        3)、查询部分字段
				                select stu_id, stu_name from stu_info;


				        4)、查询单条数据
				                select * from stu_info where stu_id=14;

				        5)、查询指定的条数
				                select * from stu_info limit 0,5；
				                数字： 从哪一个行开始
				                数字： 返回多少行

				        6)、查询部分数据
				                select * from stu_info where stu_id&lt;10 and stu_id&gt;=5;
				                select * from stu_info where stu_id between 9 and 13;
				                select * from stu_info where stu_id in&lt;1,3,6&gt;；
				                select * from stu_info where stu_addr is null;


				                   关键字：
				                        and、 or 、 between and(2数之间)、 not between and(不再2数之间)
				                        in(值表) 、 not in(值表) 、 is null(空的那个) 、is not null


				        7)、 模糊查询
				                百度搜索，关键字跑出来，就是模糊匹配
				                _ 代表匹配一个字符
				                % 代表匹配任意字符

				                select * from stu_info where stu_name like &#x27;张%&#x27;;

				                select * from stu_info where stu_name like &#x27;张_&#x27;；

				        8)、集函数
				                count()  计算元素的个数
				                select count(stu_id) as num from stu_info;

				        9)、求和函数
				            select sum(score) 总分 from stu_score where stu_no=1;

				        10)、求平均值
				            select avg(score)平均分 from stu_score where stu_no=1;

				        11)、最大值：
				            select max(score) from stu_score where course_id=1;

				        12)、最小值
				            select min(score) from stu_score where course_id=1;


				        13)、 分组
				            求每个人的总分
				                select stu_no, sum(score) &#x27;总分&#x27; from stu_score group by stu_no;

				                select stu_no ,sum(score) &#x27;总分&#x27; from stu_score group by stu_no having 总分 &gt; 300

				        14)、排序
				            升序： select stu_no, sum(score) &#x27;总分&#x27; from stu_score group by stu_no order by 总分；
				            降序： select stu_no, sum(score) &#x27;总分&#x27; from stu_score group by stu_no order by 总分 desc；




				31、 php操作mysql-----查询

				        1)、 连接mysql数据库
				        conn.php:

				            $link = mysql_connect(&quot;localhost&quot;,&#x27;root&#x27;,&#x27;root&#x27;);
				            var_dump($link);
				            if( $link ){
				                echo&#x27;连接数据库成功&lt;br&gt;&#x27;;
				            }else{
				                echo&#x27;连接数据库失败&lt;br&gt;&#x27;;
				            }

				        2)、 选择mysql数据库
				            $db = mysql_select_db(&#x27;test02&#x27;,$link);
				            var_dump($db);
				            if( $db ){
				                echo&#x27;选择数据库成功&#x27;;
				            }else{
				                echo &#x27;选择数据库失败&#x27;;
				            }

				        3)、操作 mysql数据库----查询

				        select_db.php:

				            //包含连接数据库文件
				            require_once &#x27;conn.php&#x27;;

				            //设置查询显示编码
				            mysql_query(&#x27;set names utf8&#x27;);

				            //拼装sql语句
				            $sql = &#x27;select * from stu_info&#x27;;

				            //向mysql服务器发送 执行sql语句
				            $result = mysql_query( $sql );

				            //从结果集中获取数据

				             $data = mysql_fetch_assoc($result);   //获得关联数组 -次只能获取表中的一条数据
				            $data = mysql_fetch_assoc($result);  //下一行数据
				            $data = mysql_fetch_assoc($result);  //下一行
				            $data = mysql_fetch_assoc($result);  //没有了就false


				            //$data = mysql_fetch_array($result);   //获得索引 关联
				            //$data = mysql_fetch_field($rersult);   //得到表的结构

				            var_dump( $data );

				            //循环输出表单数据
				            while( $row = mysql_fetch_assoc( $result ) ){
				                echo $row[&#x27;stu_id&#x27;]. &#x27;,&#x27; . $row[&#x27;stu_name&#x27;].&#x27;,&#x27;. $row[&#x27;stu_addr&#x27;].&#x27;&lt;br&gt;&#x27;;
				            }

				            //关闭数据库连接  释放资源 内存消耗不会过大
				            mysql_close($link);


				        4)、操作 mysql数据库----插入、修改、删除
				                插入：
				                      insert.php:

				                      //连接
				                      require_once &#x27;conn.php&#x27;;

				                      mysql_query(&#x27;set names utf8&#x27;)

				                      //拼装
				                      $sql = &quot;insert into stu_info(stu_name, stu_sex, stu_addr, stu_tel) values(&#x27;book&#x27;,&#x27;1&#x27;,&#x27;guangzhou&#x27;,&#x27;123434&#x27;)&quot;;

				                      //执行
				                      $re = mysql_query($sql);

				                      //判断是否成功
				                      if( $re ){
				                          echo &#x27;插入成功，最后的索引ID值为：&#x27;.mysql_insert_id().&#x27;&lt;br&gt;&#x27;;
				                      }else{
				                          echo &#x27;插入数据失败&#x27;;
				                      }

				                      //关闭
				                      mysql_close();

				                删除：
				                       require_once &#x27;conn.php&#x27;;
				                       mysql_query(&#x27;set names utf8&#x27;);
				                       $sql = &#x27;delete from stu_info where stu_id=16 or stu_id=17&#x27;;
				                       $re = mysql_query( $sql );
				                       if( $re ){
				                            echo &#x27;删除数据成功，影响的函数&#x27;.mysql_affected_row().&#x27;&lt;br&gt;&#x27;;
				                       }else{
				                            echo &#x27;删除失败&#x27;；
				                       }

				                       mysql_close();



				                修改：
				                      require_once &#x27;conn.php&#x27;;
				                      mysql_query(&#x27;set names utf8&#x27;);
				                      $sql = &quot;update stu_info set su_name=&#x27;王五&#x27;where stu_id=12&quot;;

				                      $re = mysql_query($sql);
				                      if( $re ){
				                        echo &#x27;更新成功，影响的行数：&#x27;.mysql_affected_row().&#x27;&lt;br&gt;&#x27;;
				                      }else{
				                         echo&#x27;更新失败,原因&#x27;.mysql_error().&#x27;错误号：&#x27;.mysql_errno();
				                      }

				                      mysql_close();




				32、 学生管理系统开发
				        功能模块分析
				        用户登陆功能(管理员用户)
				        学生信息列表(包含分页的功能)
				        学生信息搜索(按学生姓名进行搜索)
				        添加学生
				        修改学生
				        删除学生


				        1)、 用户登陆功能
				            页面设计
				            判断用户名和密码同时正确才能登陆成功
				            用户和密码进行防止sql注入
				            密码要进行加密(md5)
				            登陆错误相应提示


				            dbconfig.php 数据库配置文件
				            以后项目移植，可以方便直接修改配置

				            新建一个数据库 students
				            用 command line
				            创建表：
				                use students;

				                create table admins(
				                    id int(4) auto_increment primary key,
				                    aname varchar(20) unique not null,
				                    apass char(32) not null,
				                    create_time int(10) default 0)
				                    ;
				                )


				                show tables;

				                看到有admins这个表了
				                现在我要插入 一个 自己设定的用户名和密码
				                因为密码我们是用md5密码， 我们要生成出来
				                时间戳也要生成出来：
				                    echo strtoupper( md5(123) ); // 自己设的是123的密码
				                    echo time();

				                回到command line:
				                  输入：   insert into admins(aname,apass,create_time) values(&#x27;jie&#x27;,生成的&#x27;，&#x27;生成的&#x27;);

				                然后查看一下：
				                    select * from admins;


				                然后再login上写：
				                        &lt;?php

				                            //判断表单是否提交了
				                            if( isset($_POST[&#x27;uname&#x27;]) ){
				                                //接受表单提交的数据
				                                $uname = mysql_real_escape_string( $_POST[&#x27;uname&#x27;] );  //过滤
				                                $upass = strtoupper( md5( mysql_real_escape_string( $_POST[&#x27;upass&#x27;] ) ) ) ;


				                                //包含连接数据库文件
				                                require_once &#x27;conn.php&#x27;;


				                                //查询用户和密码是否正确
				                                $sql = &quot;select * from admins where aname=&#x27;{$uname}&#x27;&quot;;
				                                $result = mysql_query( $sql );

				                                if( mysql_num_rows( $result ) &gt; 0 ){

				                                    $data = mysql_fetch_assoc( $result );

				                                    //判断密码
				                                    if( $upass == $data[&#x27;apass&#x27;] ){
				                                            header(&#x27;location:home.php&#x27;);
				                                    }else{
				                                        echo &#x27;&lt;script&gt; alert(&quot;密码不正确&quot;); &lt;/script&gt;&#x27;;
				                                    }


				                                }else{
				                                    echo &#x27;&lt;script&gt;alert(&quot;用户名不正确!&quot;);&lt;/script&gt;&#x27;;
				                                }
				                            }
				                        ?&gt;



				        2)、 学生列表显示

				             利用导航猫来管理数据



				        3)、 分页显示
				            1 确定总的数据量
				            2 确定每页显示的数据量
				            3 计算中的页码数 进一方式取得 ceil
				            4 按指定的页码数来查询数据

				        4)、搜索功能






				git命令:


				总结：
				    q 退出
				    mkdir learngit
				    pwd
				    git config --global user.name &quot;&quot;
				    git config --global user.email &quot;&quot;
				    git init
				    git add 01.txt
				    git commit -m &quot;step 01&quot;
				    git status
				    git diff
				    git reset --hard HEAD^
				    git reset HEAD 01.txt    // 
				    git reflog
				    git log
				    git reset --hard  123434
				    git checkout -- 01.txt
				    cat 01.txt
				    git log --pretty=oneline
				    git rm 03.txt
				    rm 03.txt
				    git remote add origin git@github.com:stupidWall/gitLearning.git
				    git push -u origin master
				    git push origin master
				    git clone git@github.com:stupidWall/gitskills.git
				    git branch
				    git branch dev
				    git checkout dev
				    git checkout -b dev
				    git checkout master
				    git merge dev
				    git branch -d dev
				    vi 03.txt
				    wq
				    git log  --graph --pretty=oneline --abbrev-commit
				    git merge --no-ff -m &quot;merge with no-ff&quot; dev
				    git stash
				    git stash list
				    git stash pop
				    git stash apply 
				    git stash drop
				    git branch -D 03.txt 丢弃一个没有被合并过的分支
				    git push origin dev01
				    git pull
				    git branch --set -upstream dev01 origin/dev01
				    git remote -v
				    git checkout -b dev01 origin/dev01
				    git tag v1.0
				    git tag
				    git log -- pretty=oneline --abbrev-commit
				    git tag v0.9 23243
				    git show v0.9
				    git tag -a v0.1 -m  &quot;version 0.1 released&quot; 32434
				    git tag -d v0.1
				    git push origin v0.1
				    git push origin --tags
				    git push origin : refs/tags/v0.9




				    开发一个新feature，最好新建一个分支 
				详细：




				集中式vs分布式

				阅读: 230018
				Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？

				先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。

				central-repo

				集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。

				那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。

				和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。

				在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。

				distributed-repo

				当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。

				CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。

				除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。

				微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。

				分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！




				在Windows上安装Git
				实话实说，Windows是最烂的开发平台，如果不是开发Windows游戏或者在IE里调试页面，一般不推荐用Windows。不过，既然已经上了微软的贼船，也是有办法安装Git的。
				Windows下要使用很多Linux/Unix的工具时，需要Cygwin这样的模拟环境，Git也一样。Cygwin的安装和配置都比较复杂，就不建议你折腾了。不过，有高人已经把模拟环境和Git都打包好了，名叫msysgit，只需要下载一个单独的exe安装程序，其他什么也不用装，绝对好用。
				msysgit是Windows版的Git，从http://msysgit.github.io/下载，然后按默认选项安装即可。
				安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！
				install-git-on-windows
				安装完成后，还需要最后一步设置，在命令行输入：
				$ git config --global user.name &quot;Your Name&quot;
				$ git config --global user.email &quot;email@example.com&quot;
				因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。
				注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。



				创建版本库

				阅读: 505585
				什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。

				所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：

				$ mkdir learngit
				$ cd learngit
				$ pwd
				/Users/michael/learngit
				pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。

				如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。

				第二步，通过git init命令把这个目录变成Git可以管理的仓库：

				$ git init
				Initialized empty Git repository in /Users/michael/learngit/.git/
				瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。

				如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。


				0:15

				 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。

				把文件添加到版本库

				首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。

				不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。

				因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。

				使用Windows的童鞋要特别注意：

				千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Notepad++代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：

				set-utf8-notepad++

				言归正传，现在我们编写一个readme.txt文件，内容如下：

				Git is a version control system.
				Git is free software.
				一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。

				和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。

				第一步，用命令git add告诉Git，把文件添加到仓库：

				$ git add readme.txt
				执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。

				第二步，用命令git commit告诉Git，把文件提交到仓库：

				$ git commit -m &quot;wrote a readme file&quot;
				[master (root-commit) cb926e7] wrote a readme file
				 1 file changed, 2 insertions(+)
				 create mode 100644 readme.txt

				0:16

				 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。

				嫌麻烦不想输入-m &quot;xxx&quot;行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。

				git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。

				为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：

				$ git add file1.txt
				$ git add file2.txt file3.txt
				$ git commit -m &quot;add 3 files.&quot;
				小结

				现在总结一下今天学的两点内容：

				初始化一个Git仓库，使用git init命令。

				添加文件到Git仓库，分两步：

				第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；

				第二步，使用命令git commit，完成。





				时光机穿梭

				阅读: 291701
				我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：

				Git is a distributed version control system.
				Git is free software.
				现在，运行git status命令看看结果：

				$ git status
				# On branch master
				# Changes not staged for commit:
				#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
				#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
				#
				#    modified:   readme.txt
				#
				no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
				git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。

				虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看：

				$ git diff readme.txt 
				diff --git a/readme.txt b/readme.txt
				index 46d49bf..9247db6 100644
				--- a/readme.txt
				+++ b/readme.txt
				@@ -1,2 +1,2 @@
				-Git is a version control system.
				+Git is a distributed version control system.
				 Git is free software.
				git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。

				知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：

				$ git add readme.txt
				同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态：

				$ git status
				# On branch master
				# Changes to be committed:
				#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
				#
				#       modified:   readme.txt
				#
				git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：

				$ git commit -m &quot;add distributed&quot;
				[master ea34578] add distributed
				 1 file changed, 1 insertion(+), 1 deletion(-)
				提交后，我们再用git status命令看看仓库的当前状态：

				$ git status
				# On branch master
				nothing to commit (working directory clean)
				Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working directory clean）的。


				0:35

				小结

				要随时掌握工作区的状态，使用git status命令。
				如果git status告诉你有文件被修改过，用git diff可以查看修改内容



				版本回退

				阅读: 322842
				现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：

				Git is a distributed version control system.
				Git is free software distributed under the GPL.
				然后尝试提交：

				$ git add readme.txt
				$ git commit -m &quot;append GPL&quot;
				[master 3628164] append GPL
				 1 file changed, 1 insertion(+), 1 deletion(-)
				像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。

				现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：

				版本1：wrote a readme file

				Git is a version control system.
				Git is free software.
				版本2：add distributed

				Git is a distributed version control system.
				Git is free software.
				版本3：append GPL

				Git is a distributed version control system.
				Git is free software distributed under the GPL.
				当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：

				$ git log
				commit 3628164fb26d48395383f8f31179f24e0882e1e0
				Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
				Date:   Tue Aug 20 15:11:49 2013 +0800

				    append GPL

				commit ea34578d5496d7dd233c827ed32a8cd576c5ee85
				Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
				Date:   Tue Aug 20 14:53:12 2013 +0800

				    add distributed

				commit cb926e7ea50ad11b8f9e909c05226233bf755030
				Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
				Date:   Mon Aug 19 17:51:55 2013 +0800

				    wrote a readme file
				git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。
				如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：

				$ git log --pretty=oneline
				3628164fb26d48395383f8f31179f24e0882e1e0 append GPL
				ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed
				cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file
				需要友情提示的是，你看到的一大串类似3628164...882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。

				每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：

				git-log-timeline

				好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？

				首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。

				现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：

				$ git reset --hard HEAD^
				HEAD is now at ea34578 add distributed
				--hard参数有啥意义？这个后面再讲，现在你先放心使用。

				看看readme.txt的内容是不是版本add distributed：

				$ cat readme.txt
				Git is a distributed version control system.
				Git is free software.
				果然。

				还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：

				$ git log
				commit ea34578d5496d7dd233c827ed32a8cd576c5ee85
				Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
				Date:   Tue Aug 20 14:53:12 2013 +0800

				    add distributed

				commit cb926e7ea50ad11b8f9e909c05226233bf755030
				Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
				Date:   Mon Aug 19 17:51:55 2013 +0800

				    wrote a readme file
				最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？

				办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164...，于是就可以指定回到未来的某个版本：

				$ git reset --hard 3628164
				HEAD is now at 3628164 append GPL
				版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。

				再小心翼翼地看看readme.txt的内容：

				$ cat readme.txt
				Git is a distributed version control system.
				Git is free software distributed under the GPL.
				果然，我胡汉三又回来了。

				Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL：

				git-head

				改为指向add distributed：

				git-head-move

				然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。


				0:16

				 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？

				在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：

				$ git reflog
				ea34578 HEAD@{0}: reset: moving to HEAD^
				3628164 HEAD@{1}: commit: append GPL
				ea34578 HEAD@{2}: commit: add distributed
				cb926e7 HEAD@{3}: commit (initial): wrote a readme file
				终于舒了口气，第二行显示append GPL的commit id是3628164，现在，你又可以乘坐时光机回到未来了。


				0:47

				小结

				现在总结一下：

				HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。
				穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
				要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。



				工作区（Working Directory）

				就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：

				working-dir

				版本库（Repository）

				工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。

				Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。

				git-repo

				分支和HEAD的概念我们以后再讲。

				前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：

				第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；

				第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。

				因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。

				你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。

				俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：

				Git is a distributed version control system.
				Git is free software distributed under the GPL.
				Git has a mutable index called stage.
				然后，在工作区新增一个LICENSE文本文件（内容随便写）。

				先用git status查看一下状态：

				$ git status
				# On branch master
				# Changes not staged for commit:
				#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
				#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
				#
				#       modified:   readme.txt
				#
				# Untracked files:
				#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
				#
				#       LICENSE
				no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
				Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。

				现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：

				$ git status
				# On branch master
				# Changes to be committed:
				#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
				#
				#       new file:   LICENSE
				#       modified:   readme.txt
				#
				现在，暂存区的状态就变成这样了：

				git-stage

				所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。

				$ git commit -m &quot;understand how stage works&quot;
				[master 27c9860] understand how stage works
				 2 files changed, 675 insertions(+)
				 create mode 100644 LICENSE
				一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：

				$ git status
				# On branch master
				nothing to commit (working directory clean)
				现在版本库变成了这样，暂存区就没有任何内容了：

				git-stage-after-commit

				小结

				暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。
				没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。




				管理修改

				阅读: 191121
				现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。

				你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。

				为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：

				$ cat readme.txt
				Git is a distributed version control system.
				Git is free software distributed under the GPL.
				Git has a mutable index called stage.
				Git tracks changes.
				然后，添加：

				$ git add readme.txt
				$ git status
				# On branch master
				# Changes to be committed:
				#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
				#
				#       modified:   readme.txt
				#
				然后，再修改readme.txt：

				$ cat readme.txt 
				Git is a distributed version control system.
				Git is free software distributed under the GPL.
				Git has a mutable index called stage.
				Git tracks changes of files.
				提交：

				$ git commit -m &quot;git tracks changes&quot;
				[master d4f25b6] git tracks changes
				 1 file changed, 1 insertion(+)
				提交后，再看看状态：

				$ git status
				# On branch master
				# Changes not staged for commit:
				#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
				#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
				#
				#       modified:   readme.txt
				#
				no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
				咦，怎么第二次的修改没有被提交？

				别激动，我们回顾一下操作过程：

				第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit

				你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。

				提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别：

				$ git diff HEAD -- readme.txt 
				diff --git a/readme.txt b/readme.txt
				index 76d770f..a9c5755 100644
				--- a/readme.txt
				+++ b/readme.txt
				@@ -1,4 +1,4 @@
				 Git is a distributed version control system.
				 Git is free software distributed under the GPL.
				 Git has a mutable index called stage.
				-Git tracks changes.
				+Git tracks changes of files.
				可见，第二次修改确实没有被提交。


				0:54

				 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：

				第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit

				好，现在，把第二次修改提交了，然后开始小结。

				小结

				现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中





				撤销修改
				    小结

				又到了小结时间。

				场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。
				场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。
				场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。






				删除文件

				阅读: 154152
				在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：

				$ git add test.txt
				$ git commit -m &quot;add test.txt&quot;
				[master 94cdc44] add test.txt
				 1 file changed, 1 insertion(+)
				 create mode 100644 test.txt
				一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：

				$ rm test.txt
				这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：

				$ git status
				# On branch master
				# Changes not staged for commit:
				#   (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)
				#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
				#
				#       deleted:    test.txt
				#
				no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
				现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：

				$ git rm test.txt
				rm &#x27;test.txt&#x27;
				$ git commit -m &quot;remove test.txt&quot;
				[master d17efd8] remove test.txt
				 1 file changed, 1 deletion(-)
				 delete mode 100644 test.txt
				现在，文件就从版本库中被删除了。

				另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：

				$ git checkout -- test.txt
				git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

				小结

				命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。




				SSH

				远程仓库

				阅读: 245085
				到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。

				可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。

				没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。

				Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。

				你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？

				其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。

				实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。

				完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。

				在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：

				第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：

				$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;
				你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。

				如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。

				第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：

				然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：

				github-addkey-1

				点“Add Key”，你就应该看到已经添加的Key：

				github-addkey-2

				为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。

				当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。

				最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。

				如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。

				确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。

				小结

				“有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机


				上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。

				现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。

				首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：

				github-init-repo

				我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：

				github-init-repo-2

				现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：

				$ git clone git@github.com:michaelliao/gitskills.git
				Cloning into &#x27;gitskills&#x27;...
				remote: Counting objects: 3, done.
				remote: Total 3 (delta 0), reused 0 (delta 0)
				Receiving objects: 100% (3/3), done.

				$ cd gitskills
				$ ls
				README.md
				注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。


				0:24

				 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。

				你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。

				使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。

				小结

				要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。

				Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。



				分支管理


				阅读: 124967
				分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。

				如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！

				learn-branches

				分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。

				现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。

				其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。

				但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。



				创建与合并分支

				阅读: 259730
				在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。

				一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：

				git-br-initial

				每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：


				0:19

				 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：

				git-br-create

				你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！

				不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：

				git-br-dev-fd

				假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：

				git-br-ff-merge

				所以Git合并分支也很快！就改改指针，工作区内容也不变！

				合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：

				git-br-rm

				真是太神奇了，你看得出来有些提交是通过分支完成的吗？


				0:33

				 下面开始实战。

				首先，我们创建dev分支，然后切换到dev分支：

				$ git checkout -b dev
				Switched to a new branch &#x27;dev&#x27;
				git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：

				$ git branch dev
				$ git checkout dev
				Switched to branch &#x27;dev&#x27;
				然后，用git branch命令查看当前分支：

				$ git branch
				* dev
				  master
				git branch命令会列出所有分支，当前分支前面会标一个*号。

				然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：

				Creating a new branch is quick.
				然后提交：

				$ git add readme.txt 
				$ git commit -m &quot;branch test&quot;
				[dev fec145a] branch test
				 1 file changed, 1 insertion(+)
				现在，dev分支的工作完成，我们就可以切换回master分支：

				$ git checkout master
				Switched to branch &#x27;master&#x27;
				切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：

				git-br-on-master

				现在，我们把dev分支的工作成果合并到master分支上：

				$ git merge dev
				Updating d17efd8..fec145a
				Fast-forward
				 readme.txt |    1 +
				 1 file changed, 1 insertion(+)
				git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。

				注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。

				当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。

				合并完成后，就可以放心地删除dev分支了：

				$ git branch -d dev
				Deleted branch dev (was fec145a).
				删除后，查看branch，就只剩下master分支了：

				$ git branch
				* master
				因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。


				1:05

				小结

				Git鼓励大量使用分支：

				查看分支：git branch

				创建分支：git branch &lt;name&gt;

				切换分支：git checkout &lt;name&gt;

				创建+切换分支：git checkout -b &lt;name&gt;

				合并某分支到当前分支：git merge &lt;name&gt;

				删除分支：git branch -d &lt;name&gt;





				解决冲突

				阅读: 156940
				人生不如意之事十之八九，合并分支往往也不是一帆风顺的。

				准备新的feature1分支，继续我们的新分支开发：

				$ git checkout -b feature1
				Switched to a new branch &#x27;feature1&#x27;
				修改readme.txt最后一行，改为：

				Creating a new branch is quick AND simple.
				在feature1分支上提交：

				$ git add readme.txt 
				$ git commit -m &quot;AND simple&quot;
				[feature1 75a857c] AND simple
				 1 file changed, 1 insertion(+), 1 deletion(-)
				切换到master分支：

				$ git checkout master
				Switched to branch &#x27;master&#x27;
				Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.
				Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。

				在master分支上把readme.txt文件的最后一行改为：

				Creating a new branch is quick &amp; simple.
				提交：

				$ git add readme.txt 
				$ git commit -m &quot;&amp; simple&quot;
				[master 400b400] &amp; simple
				 1 file changed, 1 insertion(+), 1 deletion(-)
				现在，master分支和feature1分支各自都分别有新的提交，变成了这样：

				git-br-feature1

				这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：

				$ git merge feature1
				Auto-merging readme.txt
				CONFLICT (content): Merge conflict in readme.txt
				Automatic merge failed; fix conflicts and then commit the result.
				果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件：

				$ git status
				# On branch master
				# Your branch is ahead of &#x27;origin/master&#x27; by 2 commits.
				#
				# Unmerged paths:
				#   (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)
				#
				#       both modified:      readme.txt
				#
				no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
				我们可以直接查看readme.txt的内容：

				Git is a distributed version control system.
				Git is free software distributed under the GPL.
				Git has a mutable index called stage.
				Git tracks changes of files.
				&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
				Creating a new branch is quick &amp; simple.
				=======
				Creating a new branch is quick AND simple.
				&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1
				Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存：

				Creating a new branch is quick and simple.
				再提交：

				$ git add readme.txt 
				$ git commit -m &quot;conflict fixed&quot;
				[master 59bc1cb] conflict fixed
				现在，master分支和feature1分支变成了下图所示：

				git-br-conflict-merged

				用带参数的git log也可以看到分支的合并情况：

				$ git log --graph --pretty=oneline --abbrev-commit
				*   59bc1cb conflict fixed
				|\
				| * 75a857c AND simple
				* | 400b400 &amp; simple
				|/
				* fec145a branch test
				...
				最后，删除feature1分支：

				$ git branch -d feature1
				Deleted branch feature1 (was 75a857c).
				工作完成。


				2:03

				小结

				当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。

				用git log --graph命令可以看到分支合并图。




				分支管理策略

				阅读: 129725
				通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。

				如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。

				下面我们实战一下--no-ff方式的git merge：

				首先，仍然创建并切换dev分支：

				$ git checkout -b dev
				Switched to a new branch &#x27;dev&#x27;
				修改readme.txt文件，并提交一个新的commit：

				$ git add readme.txt 
				$ git commit -m &quot;add merge&quot;
				[dev 6224937] add merge
				 1 file changed, 1 insertion(+)
				现在，我们切换回master：

				$ git checkout master
				Switched to branch &#x27;master&#x27;
				准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：

				$ git merge --no-ff -m &quot;merge with no-ff&quot; dev
				Merge made by the &#x27;recursive&#x27; strategy.
				 readme.txt |    1 +
				 1 file changed, 1 insertion(+)
				因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。

				合并后，我们用git log看看分支历史：

				$ git log --graph --pretty=oneline --abbrev-commit
				*   7825a50 merge with no-ff
				|\
				| * 6224937 add merge
				|/
				*   59bc1cb conflict fixed
				...
				可以看到，不使用Fast forward模式，merge后就像这样：

				git-no-ff-mode


				0:57

				分支策略

				在实际开发中，我们应该按照几个基本原则进行分支管理：

				首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

				那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；

				你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。

				所以，团队合作的分支看起来就像这样：

				git-br-policy

				小结

				Git分支十分强大，在团队开发中应该充分应用。

				合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。








				Bug分支

				阅读: 95701
				软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。

				当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：

				$ git status
				# On branch dev
				# Changes to be committed:
				#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
				#
				#       new file:   hello.py
				#
				# Changes not staged for commit:
				#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
				#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
				#
				#       modified:   readme.txt
				#
				并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？

				幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：

				$ git stash
				Saved working directory and index state WIP on dev: 6224937 add merge
				HEAD is now at 6224937 add merge
				现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。

				首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：

				$ git checkout master
				Switched to branch &#x27;master&#x27;
				Your branch is ahead of &#x27;origin/master&#x27; by 6 commits.
				$ git checkout -b issue-101
				Switched to a new branch &#x27;issue-101&#x27;
				现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：

				$ git add readme.txt 
				$ git commit -m &quot;fix bug 101&quot;
				[issue-101 cc17032] fix bug 101
				 1 file changed, 1 insertion(+), 1 deletion(-)
				修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：

				$ git checkout master
				Switched to branch &#x27;master&#x27;
				Your branch is ahead of &#x27;origin/master&#x27; by 2 commits.
				$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101
				Merge made by the &#x27;recursive&#x27; strategy.
				 readme.txt |    2 +-
				 1 file changed, 1 insertion(+), 1 deletion(-)
				$ git branch -d issue-101
				Deleted branch issue-101 (was cc17032).
				太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！

				$ git checkout dev
				Switched to branch &#x27;dev&#x27;
				$ git status
				# On branch dev
				nothing to commit (working directory clean)
				工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：

				$ git stash list
				stash@{0}: WIP on dev: 6224937 add merge
				工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：

				一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；

				另一种方式是用git stash pop，恢复的同时把stash内容也删了：

				$ git stash pop
				# On branch dev
				# Changes to be committed:
				#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
				#
				#       new file:   hello.py
				#
				# Changes not staged for commit:
				#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
				#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
				#
				#       modified:   readme.txt
				#
				Dropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)
				再用git stash list查看，就看不到任何stash内容了：

				$ git stash list
				你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：

				$ git stash apply stash@{0}

				1:23

				小结

				修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；

				当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。




				多人协作

				阅读: 139535
				当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。

				要查看远程库的信息，用git remote：

				$ git remote
				origin
				或者，用git remote -v显示更详细的信息：

				$ git remote -v
				origin  git@github.com:michaelliao/learngit.git (fetch)
				origin  git@github.com:michaelliao/learngit.git (push)
				上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。

				推送分支

				推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：

				$ git push origin master
				如果要推送其他分支，比如dev，就改成：

				$ git push origin dev
				但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？

				master分支是主分支，因此要时刻与远程同步；

				dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；

				bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；

				feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。

				总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！


				0:18

				抓取分支

				多人协作时，大家都会往master和dev分支上推送各自的修改。

				现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：

				$ git clone git@github.com:michaelliao/learngit.git
				Cloning into &#x27;learngit&#x27;...
				remote: Counting objects: 46, done.
				remote: Compressing objects: 100% (26/26), done.
				remote: Total 46 (delta 16), reused 45 (delta 15)
				Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.
				Resolving deltas: 100% (16/16), done.
				当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看：

				$ git branch
				* master
				现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支：

				$ git checkout -b dev origin/dev
				现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程：

				$ git commit -m &quot;add /usr/bin/env&quot;
				[dev 291bea8] add /usr/bin/env
				 1 file changed, 1 insertion(+)
				$ git push origin dev
				Counting objects: 5, done.
				Delta compression using up to 4 threads.
				Compressing objects: 100% (2/2), done.
				Writing objects: 100% (3/3), 349 bytes, done.
				Total 3 (delta 0), reused 0 (delta 0)
				To git@github.com:michaelliao/learngit.git
				   fc38031..291bea8  dev -&gt; dev

				1:44

				 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：

				$ git add hello.py 
				$ git commit -m &quot;add coding: utf-8&quot;
				[dev bd6ae48] add coding: utf-8
				 1 file changed, 1 insertion(+)
				$ git push origin dev
				To git@github.com:michaelliao/learngit.git
				 ! [rejected]        dev -&gt; dev (non-fast-forward)
				error: failed to push some refs to &#x27;git@github.com:michaelliao/learngit.git&#x27;
				hint: Updates were rejected because the tip of your current branch is behind
				hint: its remote counterpart. Merge the remote changes (e.g. &#x27;git pull&#x27;)
				hint: before pushing again.
				hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.
				推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：

				$ git pull
				remote: Counting objects: 5, done.
				remote: Compressing objects: 100% (2/2), done.
				remote: Total 3 (delta 0), reused 3 (delta 0)
				Unpacking objects: 100% (3/3), done.
				From github.com:michaelliao/learngit
				   fc38031..291bea8  dev        -&gt; origin/dev
				There is no tracking information for the current branch.
				Please specify which branch you want to merge with.
				See git-pull(1) for details

				    git pull &lt;remote&gt; &lt;branch&gt;

				If you wish to set tracking information for this branch you can do so with:

				    git branch --set-upstream dev origin/&lt;branch&gt;
				git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：

				$ git branch --set-upstream dev origin/dev
				Branch dev set up to track remote branch dev from origin.
				再pull：

				$ git pull
				Auto-merging hello.py
				CONFLICT (content): Merge conflict in hello.py
				Automatic merge failed; fix conflicts and then commit the result.
				这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：

				$ git commit -m &quot;merge &amp; fix hello.py&quot;
				[dev adca45d] merge &amp; fix hello.py
				$ git push origin dev
				Counting objects: 10, done.
				Delta compression using up to 4 threads.
				Compressing objects: 100% (5/5), done.
				Writing objects: 100% (6/6), 747 bytes, done.
				Total 6 (delta 0), reused 0 (delta 0)
				To git@github.com:michaelliao/learngit.git
				   291bea8..adca45d  dev -&gt; dev

				2:06

				 因此，多人协作的工作模式通常是这样：

				首先，可以试图用git push origin branch-name推送自己的修改；

				如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；

				如果合并有冲突，则解决冲突，并在本地提交；

				没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！

				如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。

				这就是多人协作的工作模式，一旦熟悉了，就非常简单。

				小结

				查看远程库信息，使用git remote -v；

				本地新建的分支如果不推送到远程，对其他人就是不可见的；

				从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；

				在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；

				建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；

				从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。




				我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。

				在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。

				但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。

				如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：

				git clone git@github.com:michaelliao/bootstrap.git
				一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。

				Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：

				github-repos

				如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。

				如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。

				如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：https://github.com/michaelliao/learngit，创建一个your-github-id.txt的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。

				小结

				在GitHub上，可以任意Fork开源仓库；

				自己拥有Fork后的仓库的读写权限；

				可以推送pull request给官方仓库来贡献代码。






				form表单：
				          &lt;form id=&quot;form1&quot; name=&quot;form1&quot; method=&quot;post&quot; action=&quot;&quot;&gt; 
				            &lt;table width=&quot;286&quot; border=&quot;0&quot; align=&quot;center&quot;&gt;
				              &lt;tbody&gt;
				                &lt;tr&gt;
				                  &lt;td width=&quot;72&quot;&gt;&lt;span class=&quot;01&quot;&gt;用户名:&lt;/span&gt;&lt;/td&gt;
				                  &lt;td width=&quot;204&quot;&gt;
				                    &lt;label&gt;
				                      &lt;input type=&quot;text&quot; name=&quot;text&quot;/&gt;
				                    &lt;/label&gt;
				                  &lt;/td&gt;
				                &lt;/tr&gt;
				                &lt;tr&gt;
				                  &lt;td&gt;&lt;span&gt;密码:&lt;/span&gt;&lt;/td&gt;
				                  &lt;td&gt;
				                    &lt;label&gt;
				                      &lt;input type=&quot;password&quot; name=&quot;text2&quot;/&gt;
				                    &lt;/label&gt;
				                  &lt;/td&gt;
				                &lt;/tr&gt;
				                &lt;tr&gt;
				                  &lt;td&gt;&lt;span&gt;性别:&lt;/span&gt;&lt;/td&gt;
				                  &lt;td&gt;
				                    &lt;label&gt;
				                      &lt;input name=&quot;radio&quot; type=&quot;radio&quot; checked&gt;
				                      &lt;span&gt;男&lt;/span&gt;
				                      &lt;input name=&quot;radio&quot; type=&quot;radio&quot; checked&gt;
				                      &lt;span&gt;女&lt;/span&gt;
				                    &lt;/label&gt;
				                  &lt;/td&gt;
				                &lt;/tr&gt;
				                &lt;tr&gt;
				                  &lt;td&gt;&lt;span&gt;学历：&lt;/span&gt;&lt;/td&gt;
				                  &lt;td&gt;
				                    &lt;select name=&quot;select&quot; id=&quot;select&quot;&gt;
				                    &lt;option&gt;本科&lt;/option&gt;
				                    &lt;option&gt;大专&lt;/option&gt;
				                    &lt;/select&gt;
				                  &lt;/td&gt;
				                  
				                &lt;/tr&gt;
				                &lt;tr&gt;
				                  &lt;td&gt;&lt;span&gt;爱好：&lt;/span&gt;&lt;/td&gt;
				                  &lt;td&gt;
				                    &lt;input name=&quot;select&quot;  type=&quot;checkbox&quot; checked value=&quot;打球&quot;&gt;
				                    &lt;/input&gt;
				                    &lt;span&gt;打球&lt;/span&gt;
				                    &lt;input name=&quot;select&quot;  type=&quot;checkbox&quot; checked value=&quot;看书&quot;&gt;
				                    &lt;/input&gt;
				                    &lt;span&gt;看书&lt;/span&gt;
				                    &lt;input name=&quot;select&quot;  type=&quot;checkbox&quot; checked value=&quot;听音乐&quot;&gt;
				                    &lt;/input&gt;
				                    &lt;span&gt;听音乐&lt;/span&gt;
				                  &lt;/td&gt;
				                  
				                &lt;/tr&gt;
				                &lt;tr&gt;
				                  &lt;td&gt;&lt;span&gt;个人简介：&lt;/span&gt;&lt;/td&gt;
				                  &lt;td&gt;
				                    &lt;textarea name=&quot;name&quot; rows=&quot;4&quot; cols=&quot;20&quot;&gt;
				                      程序员
				                    &lt;/textarea&gt;
				                  &lt;/td&gt;
				                &lt;/tr&gt;
				                &lt;tr&gt;
				                  &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;
				                    &lt;label&gt;
				                      &lt;input type=&quot;submit&quot; name=&quot;submit&quot; vlaue=&quot;提交&quot;/&gt;
				                    &lt;/label&gt;
				                    &lt;label&gt;
				                      &lt;input type=&quot;submit&quot; name=&quot;submit2&quot; vlaue=&quot;取消&quot;/&gt;
				                    &lt;/label&gt;
				                  &lt;/td&gt;
				                &lt;/tr&gt;
				              &lt;/tbody&gt;
				            &lt;/table&gt;
				          &lt;/form&gt;


				=================================
				react 是一个库  用来构建页面的  ui
				MVC的 V层

				网址
				reactjs.cn
				react-china.org
				ant.design

				react.js
				react-dom.js

				特点: 
				    1. 虚拟dom： 操作dom耗时间，有可能重流；而这里的，通过dom diff算法，在内存里完成，只会更新有差异化的部分，不用渲染整个页面，提高效率

				    2. 组件化
				        页面分成多个组件
				        方便页面拆分多个组件
				        组件只包含自身逻辑，更新组件的时候可以预测
				        重用

				    3.单向数据流
				         数据从顶层组件传递到字组件中
				         数据可控

				     JSX
				     javascript XML
				     js的扩展，html js混在一起

				     &lt;script src=&quot;react.js&quot;&gt;&lt;/script&gt;
				     &lt;script src=&quot;react-dom.js&quot;&gt;&lt;/script&gt;
				     &lt;script src=&quot;browser.min.js&quot;&gt;&lt;/script&gt;

				     &lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;
				     &lt;script type=&quot;text/babel&quot;&gt; // 这样才能解析html
				              ReactDOM.render( &lt;h1&gt;你好&lt;/h1&gt;, document.getElementById(&quot;demo&quot;), function(){
				                    console.log( &quot;页面渲染完成&quot; );
				              } );
				     &lt;/script&gt;


				      &lt;script type=&quot;text/babel&quot;&gt;
				            //定义一个组件   组件名 首字母必须大写
				            var FirstComponent =  React.createClass({
				                      render : function(){
				                              return (
				                              &lt;div&gt;
				                                   &lt;h2&gt;{ this.props.title }&lt;/h2&gt;
				                                    &lt;input type=&quot;text&quot; /&gt;
				                                    &lt;input type=&quot;button&quot; value={ this.props.sendName } /&gt;
				                              &lt;/div&gt;
				                              )
				                      }
				              });

				              var title = &quot;喝高了&quot;;
				              var sendName = &quot;提交&quot;;

				              var obj = { 
				                title : &quot;欢迎&quot;，
				                send :  &quot;提交&quot;
				              }

				              ReactDOM.render( 
				                      &lt;FirstComponent title= {obj.title} sendName={obj.send}&gt;&lt;/FirstComponent&gt;, 
				                      document.getElementById(&quot;demo&quot;), function(){
				                            console.log( &quot;页面渲染完成&quot; );
				                      } 
				              );
				     &lt;/script&gt;


				     ---------------------------------------------

				     var FirstComponent =  React.createClass({
				                      //组件状态
				                      getInitialState : function(){
				                                return {
				                                      mes :  &quot;this.props.value&quot;
				                                }
				                      },

				                      //双向绑定  
				                      render : function(){
				                              return (
				                              &lt;div&gt;
				                                   &lt;h2&gt;{ this.props.title }&lt;/h2&gt;
				                                    &lt;input type=&quot;text&quot; value={this.props.value} onChange={this.changeHandle()}/&gt;
				                                    &lt;input type=&quot;button&quot; value={ this.props.sendName } /&gt;
				                                    &lt;p&gt;{this.state.mes}&lt;/p&gt;
				                              &lt;/div&gt;
				                              )
				                      },
				                      changeHandle : function(ev){
				                              var target = ev.target;
				                              this.setState({mes:target.value});
				                      }
				              });

				              // props  组件初始要渲染的数据，不可改变
				              // state   组件状态改变， 会调用render方法重新渲染


				  ------------------------------------------------
				使用插件：  完成双向绑定

				            引入：
				            &lt;script src=&quot;react-with-addons.js&quot;&gt;&lt;/script&gt;

				            var FirstComponent =  React.createClass({
				                      //插件
				                      mixins  : [React.addons.LinkedStateMixin],

				                      //组件状态
				                      getInitialState : function(){
				                                return {
				                                      mes :  &quot;this.props.value&quot;
				                                }
				                      },

				                      //双向绑定  
				                      render : function(){
				                              return (
				                              &lt;div&gt;
				                                   &lt;h2&gt;{ this.props.title }&lt;/h2&gt;
				                                    &lt;input type=&quot;text&quot; valueLink={this.linkState(&#x27;mes&#x27;)} }/&gt;
				                                    &lt;input type=&quot;button&quot; value={ this.props.sendName } /&gt;
				                                    &lt;p&gt;{this.state.mes}&lt;/p&gt;
				                              &lt;/div&gt;
				                              )
				                      },
				                      changeHandle : function(ev){
				                              var target = ev.target;
				                              this.setState({mes:target.value});
				                      }
				              });

				react.min.js - React 的核心库
				react-dom.min.js - 提供与 DOM 相关的功能
				browser.min.js - 用于将 JSX 语法转为 JavaScript 语法

				npm安装：
				    第一步、安装全局包
				$ npm install babel -g
				$ npm install webpack -g
				$ npm install webpack-dev-server -g


				第二步、创建根目录
				创建一个根目录，目录名为：reactApp，再使用 npm init 初始化，生成 package.json 文件：
				$ mkdir reactApp
				$ cd reactApp/
				$ npm init
				name: (reactApp) runoob-react-test
				version: (1.0.0) 
				description: 菜鸟教程 react 测试
				entry point: (index.js) 
				test command: 
				git repository: 
				keywords: 
				author: 
				license: (ISC) 
				About to write to /Users/tianqixin/www/reactApp/package.json:

				{
				  &quot;name&quot;: &quot;runoob-react-test&quot;,
				  &quot;version&quot;: &quot;1.0.0&quot;,
				  &quot;description&quot;: &quot;菜鸟教程 react 测试&quot;,
				  &quot;main&quot;: &quot;index.js&quot;,
				  &quot;scripts&quot;: {
				    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
				  },
				  &quot;author&quot;: &quot;&quot;,
				  &quot;license&quot;: &quot;ISC&quot;
				}


				Is this ok? (yes)

				第三步、添加越来包及插件
				因为我们要使用 React, 所以我们需要先安装它，--save 命令用于将包添加至 package.json 文件。
				$ npm install react --save
				$ npm install react-dom --save
				同时我们也要安装一些 babel 插件
				$ npm install babel-core
				$ npm install babel-loader
				$ npm install babel-preset-react
				$ npm install babel-preset-es2015


				第四步、创建文件
				接下来我们创建一些必要文件：
				$ touch index.html
				$ touch App.jsx
				$ touch main.js
				$ touch webpack.config.js
				第五步、设置编译器，服务器，载入器
				打开 webpack.config.js 文件添加以下代码:
				 var config = {
				   entry: &#x27;./main.js&#x27;,
				  
				   output: {
				      path:&#x27;./&#x27;,
				      filename: &#x27;index.js&#x27;,
				   },
				  
				   devServer: {
				      inline: true,
				      port: 7777
				   },
				  
				   module: {
				      loaders: [ {
				         test: /\.jsx?$/,
				         exclude: /node_modules/,
				         loader: &#x27;babel&#x27;,
				      
				         query: {
				            presets: [&#x27;es2015&#x27;, &#x27;react&#x27;]
				         }
				      }]
				   }
				  
				}

				module.exports = config;
				entry: 指定打包的入口文件 main.js。
				output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称。
				devServer：设置服务器端口号为 7777，端口后你可以自己设定 。
				module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。
				现在打开 package.json 文件，找到 &quot;scripts&quot; 中的 &quot;test&quot; &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; 使用以下代码替换：
				&quot;start&quot;: &quot;webpack-dev-server --hot&quot;
				替换后的 package.json 文件 内容如下：
				$ cat package.json 
				{
				  &quot;name&quot;: &quot;runoob-react-test&quot;,
				  &quot;version&quot;: &quot;1.0.0&quot;,
				  &quot;description&quot;: &quot;菜鸟教程 react 测试&quot;,
				  &quot;main&quot;: &quot;index.js&quot;,
				  &quot;scripts&quot;: {
				  &quot;start&quot;: &quot;webpack-dev-server --hot&quot;
				  },
				  &quot;author&quot;: &quot;&quot;,
				  &quot;license&quot;: &quot;ISC&quot;,
				  &quot;dependencies&quot;: {
				    &quot;react&quot;: &quot;^0.14.7&quot;,
				    &quot;react-dom&quot;: &quot;^0.14.7&quot;
				  }
				}
				现在我们可以使用 npm start 命令来启动服务。--hot 命令会在文件变化后重新载入，这样我们就不需要在代码修改后重新刷新浏览器就能看到变化。

				第五步、设置编译器，服务器，载入器
				打开 webpack.config.js 文件添加以下代码:
				 var config = {
				   entry: &#x27;./main.js&#x27;,
				  
				   output: {
				      path:&#x27;./&#x27;,
				      filename: &#x27;index.js&#x27;,
				   },
				  
				   devServer: {
				      inline: true,
				      port: 7777
				   },
				  
				   module: {
				      loaders: [ {
				         test: /\.jsx?$/,
				         exclude: /node_modules/,
				         loader: &#x27;babel&#x27;,
				      
				         query: {
				            presets: [&#x27;es2015&#x27;, &#x27;react&#x27;]
				         }
				      }]
				   }
				  
				}

				module.exports = config;
				entry: 指定打包的入口文件 main.js。
				output：配置打包结果，path定义了输出的文件夹，filename则定义了打包结果文件的名称。
				devServer：设置服务器端口号为 7777，端口后你可以自己设定 。
				module：定义了对模块的处理逻辑，这里可以用loaders定义了一系列的加载器，以及一些正则。当需要加载的文件匹配test的正则时，就会调用后面的loader对文件进行处理，这正是webpack强大的原因。
				现在打开 package.json 文件，找到 &quot;scripts&quot; 中的 &quot;test&quot; &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; 使用以下代码替换：
				&quot;start&quot;: &quot;webpack-dev-server --hot&quot;
				替换后的 package.json 文件 内容如下：
				$ cat package.json 
				{
				  &quot;name&quot;: &quot;runoob-react-test&quot;,
				  &quot;version&quot;: &quot;1.0.0&quot;,
				  &quot;description&quot;: &quot;菜鸟教程 react 测试&quot;,
				  &quot;main&quot;: &quot;index.js&quot;,
				  &quot;scripts&quot;: {
				  &quot;start&quot;: &quot;webpack-dev-server --hot&quot;
				  },
				  &quot;author&quot;: &quot;&quot;,
				  &quot;license&quot;: &quot;ISC&quot;,
				  &quot;dependencies&quot;: {
				    &quot;react&quot;: &quot;^0.14.7&quot;,
				    &quot;react-dom&quot;: &quot;^0.14.7&quot;
				  }
				}
				现在我们可以使用 npm start 命令来启动服务。--hot 命令会在文件变化后重新载入，这样我们就不需要在代码修改后重新刷新浏览器就能看到变化。
				第六步、index.html
				设置 div id = &quot;app&quot; 为我们应用的根元素，并引入 index.js 脚本文件。
				&lt;!DOCTYPE html&gt;
				&lt;html&gt;

				   &lt;head&gt;
				      &lt;meta charset = &quot;UTF-8&quot;&gt;
				      &lt;title&gt;React App - 菜鸟教程(runoob.com)&lt;/title&gt;
				   &lt;/head&gt;

				   &lt;body&gt;
				      &lt;div id = &quot;app&quot;&gt;&lt;/div&gt;
				      &lt;script src = &quot;index.js&quot;&gt;&lt;/script&gt;
				   &lt;/body&gt;

				&lt;/html&gt;
				第七步、App.jsx 和 main.js
				这是第一个 react 组件。后面的章节我们会详细介绍 React 组件。这个组件将输出 Hello World!!!。
				App.jsx 文件代码
				import React from &#x27;react&#x27;;

				class App extends React.Component {
				   render() {
				      return (
				         &lt;div&gt;
				            Hello World!!!&lt;br /&gt;
				            欢迎来到菜鸟教程学习！！！
				         &lt;/div&gt;
				      );
				   }
				}

				export default App;
				我们需要引入组件并将其渲染到根元素 App 上，这样我们才可以在浏览器上看到它。
				main.js 文件代码
				import React from &#x27;react&#x27;;
				import ReactDOM from &#x27;react-dom&#x27;;

				import App from &#x27;./App.jsx&#x27;;

				ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;app&#x27;))
				注意：
				如果想要组件可以在任何的应用中使用，需要在创建后使用 export 将其导出，在使用组件的文件使用 import 将其导入。
				第八步、运行服务
				完成以上配置后，我们即可运行该服务：




				React JSX
				React 使用 JSX 来替代常规的 JavaScript。
				JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。
				我们不需要一定使用 JSX，但它有以下优点：
				JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。
				它是类型安全的，在编译过程中就能发现错误。
				使用 JSX 编写模板更加简单快速。


				你的 React JSX 代码可以放在一个独立文件上，例如我们创建一个 helloworld_react.js 文件
				然后在 HTML 文件中引入该 JS 文件：
				&lt;script type=&quot;text/babel&quot; src=&quot;helloworld_react.js&quot;&gt;&lt;/script&gt;

				我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。实例如下：

				  在 JSX 中不能使用 if else 语句，单可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.
				  ReactDOM.render(
				  &lt;div&gt;
				    &lt;h1&gt;{i = 1 ? &#x27;True!&#x27; : &#x27;False&#x27;}&lt;/h1&gt;
				  &lt;/div&gt;
				  ,
				  document.getElementById(&#x27;example&#x27;)
				);


				React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px 
				var myStyle = {
				  fontSize: 100,
				  color: &#x27;#FF0000&#x27;
				};
				ReactDOM.render(
				  &lt;h1 style = {myStyle}&gt;菜鸟教程&lt;/h1&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);


				注释需要写在花括号中，实例如下：
				ReactDOM.render(
				  &lt;div&gt;
				    &lt;h1&gt;菜鸟教程&lt;/h1&gt;
				    {/*注释...*/}
				  &lt;/div&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);

				JSX 允许在模板中插入数组，数组会自动展开所有成员：
				var arr = [
				  &lt;h1&gt;菜鸟教程&lt;/h1&gt;,
				  &lt;h2&gt;学的不仅是技术，更是梦想！&lt;/h2&gt;,
				];
				ReactDOM.render(
				  &lt;div&gt;{arr}&lt;/div&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);


				React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。
				要渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名。
				var myDivElement = &lt;div className=&quot;foo&quot; /&gt;;
				ReactDOM.render(myDivElement, document.getElementById(&#x27;example&#x27;));
				要渲染 React 组件，只需创建一个大写字母开头的本地变量。
				var MyComponent = React.createClass({/*...*/});
				var myElement = &lt;MyComponent someProperty={true} /&gt;;
				ReactDOM.render(myElement, document.getElementById(&#x27;example&#x27;));
				React 的 JSX 使用大、小写的约定来区分本地组件的类和 HTML 标签。


				React 组件
				var HelloMessage = React.createClass({
				  render: function() {
				    return &lt;h1&gt;Hello World！&lt;/h1&gt;;
				  }
				});

				ReactDOM.render(
				  &lt;HelloMessage /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);

				React.createClass 方法用于生成一个组件类 HelloMessage。
				&lt;HelloMessage /&gt; 实例组件类并输出信息。
				注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。

				如果我们需要向组件传递参数，可以使用 this.props 对象,实例如下：
				var HelloMessage = React.createClass({
				  render: function() {
				    return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
				  }
				});

				ReactDOM.render(
				  &lt;HelloMessage name=&quot;Runoob&quot; /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);


				注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。

				复合组件
				们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。
				var WebSite = React.createClass({
				  render: function() {
				    return (
				      &lt;div&gt;
				        &lt;Name name={this.props.name} /&gt;
				        &lt;Link site={this.props.site} /&gt;
				      &lt;/div&gt;
				    );
				  }
				});

				var Name = React.createClass({
				  render: function() {
				    return (
				      &lt;h1&gt;{this.props.name}&lt;/h1&gt;
				    );
				  }
				});

				var Link = React.createClass({
				  render: function() {
				    return (
				      &lt;a href={this.props.site}&gt;
				        {this.props.site}
				      &lt;/a&gt;
				    );
				  }
				});

				React.render(
				  &lt;WebSite name=&quot;菜鸟教程&quot; site=&quot; http://www.runoob.com&quot; /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);

				React State(状态)
				React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。
				React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。

				getInitialState 方法用于定义初始状态，也就是一个对象，这个对象可以通过 this.state 属性读取。当用户点击组件，导致状态变化，this.setState 方法就修改状态值，每次修改以后，自动调用 this.render 方法，再次渲染组件。
				var LikeButton = React.createClass({
				  getInitialState: function() {
				    return {liked: false};
				  },
				  handleClick: function(event) {
				    this.setState({liked: !this.state.liked});
				  },
				  render: function() {
				    var text = this.state.liked ? &#x27;喜欢&#x27; : &#x27;不喜欢&#x27;;
				    return (
				      &lt;p onClick={this.handleClick}&gt;
				        你&lt;b&gt;{text}&lt;/b&gt;我。点我切换状态。
				      &lt;/p&gt;
				    );
				  }
				});

				React.render(
				  &lt;LikeButton /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);


				React Props
				state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 state 来传递数据。

				使用 Props
				var HelloMessage = React.createClass({
				  render: function() {
				    return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
				  }
				});

				ReactDOM.render(
				  &lt;HelloMessage name=&quot;Runoob&quot; /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);
				默认 Props
				你可以通过 getDefaultProps() 方法为 props 设置默认值，实例如下：
				var HelloMessage = React.createClass({
				  getDefaultProps: function() {
				    return {
				      name: &#x27;Runoob&#x27;
				    };
				  },
				  render: function() {
				    return &lt;h1&gt;Hello {this.props.name}&lt;/h1&gt;;
				  }
				});

				ReactDOM.render(
				  &lt;HelloMessage /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);


				State 和 Props
				以下实例演示了如何在应用中组合使用 state 和 props 。我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。
				var WebSite = React.createClass({
				  getInitialState: function() {
				    return {
				      name: &quot;菜鸟教程&quot;,
				      site: &quot;http://www.runoob.com&quot;
				    };
				  },
				 
				  render: function() {
				    return (
				      &lt;div&gt;
				        &lt;Name name={this.state.name} /&gt;
				        &lt;Link site={this.state.site} /&gt;
				      &lt;/div&gt;
				    );
				  }
				});

				var Name = React.createClass({
				  render: function() {
				    return (
				      &lt;h1&gt;{this.props.name}&lt;/h1&gt;
				    );
				  }
				});

				var Link = React.createClass({
				  render: function() {
				    return (
				      &lt;a href={this.props.site}&gt;
				        {this.props.site}
				      &lt;/a&gt;
				    );
				  }
				});

				React.render(
				  &lt;WebSite /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);



				Props 验证
				Props 验证使用 propTypes，它可以保证我们的应用组件被正确使用，React.PropTypes 提供很多验证器 (validator) 来验证传入数据是否有效。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。
				var title = &quot;菜鸟教程&quot;;
				// var title = 123;
				var MyTitle = React.createClass({
				  propTypes: {
				    title: React.PropTypes.string.isRequired,
				  },

				  render: function() {
				     return &lt;h1&gt; {this.props.title} &lt;/h1&gt;;
				   }
				});
				ReactDOM.render(
				    &lt;MyTitle title={title} /&gt;,
				    document.getElementById(&#x27;example&#x27;)
				);



				React.createClass({
				  propTypes: {
				    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的
				   optionalArray: React.PropTypes.array,
				    optionalBool: React.PropTypes.bool,
				    optionalFunc: React.PropTypes.func,
				    optionalNumber: React.PropTypes.number,
				    optionalObject: React.PropTypes.object,
				    optionalString: React.PropTypes.string,

				    // 可以被渲染的对象 numbers, strings, elements 或 array
				    optionalNode: React.PropTypes.node,

				    //  React 元素
				    optionalElement: React.PropTypes.element,

				    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。
				    optionalMessage: React.PropTypes.instanceOf(Message),

				    // 用 enum 来限制 prop 只接受指定的值。
				    optionalEnum: React.PropTypes.oneOf([&#x27;News&#x27;, &#x27;Photos&#x27;]),

				    // 可以是多个对象类型中的一个
				    optionalUnion: React.PropTypes.oneOfType([
				      React.PropTypes.string,
				      React.PropTypes.number,
				      React.PropTypes.instanceOf(Message)
				    ]),

				    // 指定类型组成的数组
				    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),

				    // 指定类型的属性构成的对象
				    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),

				    // 特定 shape 参数的对象
				    optionalObjectWithShape: React.PropTypes.shape({
				      color: React.PropTypes.string,
				      fontSize: React.PropTypes.number
				    }),

				    // 任意类型加上 &#x60;isRequired&#x60; 来使 prop 不可空。
				    requiredFunc: React.PropTypes.func.isRequired,

				    // 不可空的任意类型
				    requiredAny: React.PropTypes.any.isRequired,

				    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 &#x60;console.warn&#x60; 或抛异常，因为这样 &#x60;oneOfType&#x60; 会失效。
				    customProp: function(props, propName, componentName) {
				      if (!/matchme/.test(props[propName])) {
				        return new Error(&#x27;Validation failed!&#x27;);
				      }
				    }
				  },
				  /* ... */
				});



				设置状态:setState
				var Counter = React.createClass({
				  getInitialState: function () {
				    return { clickCount: 0 };
				  },
				  handleClick: function () {
				    this.setState(function(state) {
				      return {clickCount: state.clickCount + 1};
				    });
				  },
				  render: function () {
				    return (&lt;h2 onClick={this.handleClick}&gt;点我！点击次数为: {this.state.clickCount}&lt;/h2&gt;);
				  }
				});
				ReactDOM.render(
				  &lt;Counter /&gt;,
				  document.getElementById(&#x27;message&#x27;)
				);
				不能在组件内部通过this.state修改状态，因为该状态会在调用setState()后被替换。
				setState()并不会立即改变this.state，而是创建一个即将处理的state。setState()并不一定是同步的，为了提升性能React会批量执行state和DOM渲染。
				setState()总是会触发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。


				替换状态：replaceState
				设置属性：setProps
				替换属性：replaceProps
				强制更新：forceUpdate
				获取DOM节点：getDOMNode


				React 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据库可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI。
				当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求。

				var UserGist = React.createClass({
				  getInitialState: function() {
				    return {
				      username: &#x27;&#x27;,
				      lastGistUrl: &#x27;&#x27;
				    };
				  },

				  componentDidMount: function() {
				    this.serverRequest = $.get(this.props.source, function (result) {
				      var lastGist = result[0];
				      this.setState({
				        username: lastGist.owner.login,
				        lastGistUrl: lastGist.html_url
				      });
				    }.bind(this));
				  },

				  componentWillUnmount: function() {
				    this.serverRequest.abort();
				  },

				  render: function() {
				    return (
				      &lt;div&gt;
				        {this.state.username} 用户最新的 Gist 共享地址：
				        &lt;a href={this.state.lastGistUrl}&gt;{this.state.lastGistUrl}&lt;/a&gt;
				      &lt;/div&gt;
				    );
				  }
				});

				ReactDOM.render(
				  &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot; /&gt;,
				  mountNode
				);


				表单：
				var HelloMessage = React.createClass({
				  getInitialState: function() {
				    return {value: &#x27;Hello Runoob!&#x27;};
				  },
				  handleChange: function(event) {
				    this.setState({value: event.target.value});
				  },
				  render: function() {
				    var value = this.state.value;
				    return &lt;div&gt;
				            &lt;input type=&quot;text&quot; value={value} onChange={this.handleChange} /&gt; 
				            &lt;h4&gt;{value}&lt;/h4&gt;
				           &lt;/div&gt;;
				  }
				});
				ReactDOM.render(
				  &lt;HelloMessage /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);


				子组件 父组件  情况下怎么使用表单
				var Content = React.createClass({
				  render: function() {
				    return  &lt;div&gt;
				            &lt;input type=&quot;text&quot; value={this.props.myDataProp} onChange={this.props.updateStateProp} /&gt; 
				            &lt;h4&gt;{this.props.myDataProp}&lt;/h4&gt;
				            &lt;/div&gt;;
				  }
				});
				var HelloMessage = React.createClass({
				  getInitialState: function() {
				    return {value: &#x27;Hello Runoob!&#x27;};
				  },
				  handleChange: function(event) {
				    this.setState({value: event.target.value});
				  },
				  render: function() {
				    var value = this.state.value;
				    return &lt;div&gt;
				            &lt;Content myDataProp = {value} 
				              updateStateProp = {this.handleChange}&gt;&lt;/Content&gt;
				           &lt;/div&gt;;
				  }
				});
				ReactDOM.render(
				  &lt;HelloMessage /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);


				点击修改：
				var HelloMessage = React.createClass({
				  getInitialState: function() {
				    return {value: &#x27;Hello Runoob!&#x27;};
				  },
				  handleChange: function(event) {
				    this.setState({value: &#x27;菜鸟教程&#x27;})
				  },
				  render: function() {
				    var value = this.state.value;
				    return &lt;div&gt;
				            &lt;button onClick={this.handleChange}&gt;点我&lt;/button&gt;
				            &lt;h4&gt;{value}&lt;/h4&gt;
				           &lt;/div&gt;;
				  }
				});
				ReactDOM.render(
				  &lt;HelloMessage /&gt;,
				  document.getElementById(&#x27;example&#x27;)
				);



				CommonJS和AMD是用于JavaScript模块管理的两大规范，前者定义的是模块的同步加载，主要用于NodeJS；而后者则是异步加载，通过requirejs等工具适用于前端。随着npm成为主流的JavaScript组件发布平台，越来越多的前端项目也依赖于npm上的项目，或者自身就会发布到npm平台。因此，让前端项目更方便的使用npm上的资源成为一大需求。于是诞生了类似browserify这样的工具，代码中可以使用require函数直接以同步语法形式引入npm模块，打包后再由浏览器执行。

				Webpack其实有点类似browserify，出自Facebook的Instagram团队，但功能比browserify更为强大。其主要特性如下：

				同时支持CommonJS和AMD模块（对于新项目，推荐直接使用CommonJS）；
				串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持；
				可以基于配置或者智能分析打包成多个文件，实现公共模块或者按需加载；
				支持对CSS，图片等资源进行打包，从而无需借助Grunt或Gulp；
				开发时在内存中完成打包，性能更快，完全可以支持开发过程的实时打包需求；
				对sourcemap有很好的支持，易于调试。


				npm install -g webpack
				之后便有了全局的webpack命令


				一个最简单的Webpack配置文件webpack.config.js如下所示：

				module.exports = {
				  entry:[
				    &#x27;./app/main.js&#x27;
				  ],
				  output: {
				    path: __dirname + &#x27;/assets/&#x27;,
				    publicPath: &quot;/assets/&quot;,
				    filename: &#x27;bundle.js&#x27;
				  }
				};


				其中entry参数定义了打包后的入口文件，数组中的所有文件会按顺序打包。每个文件进行依赖的递归查找，直到所有相关模块都被打包。output参数定义了输出文件的位置，其中常用的参数包括：

				path: 打包文件存放的绝对路径
				publicPath: 网站运行时的访问路径
				filename: 打包后的文件名



				在实际项目中，代码以模块进行组织，AMD是在CommonJS的基础上考虑了浏览器的异步加载特性而产生的，可以让模块异步加载并保证执行顺序。而CommonJS的require函数则是同步加载。在Webpack中笔者更加推荐CommonJS方式去加载模块，这种方式语法更加简洁直观。即使在开发时，我们也是加载Webpack打包后的文件，通过sourcemap去进行调试。

				除了项目本身的模块，我们也需要依赖第三方的模块，现在比较常用的第三方模块基本都通过npm进行发布，使用它们已经无需单独下载管理，需要时执行npm install即可。例如，我们需要依赖jQuery，只需执行：

				npm install jquery —save-dev

				更多情况下我们是在项目的package.json中进行依赖管理，然后通过直接执行npm install来安装所有依赖。这样在项目的代码仓库中并不需要存储实际的第三方依赖库的代码。

				安装之后，在需要使用jquery的模块中需要在头部进行引入：

				var $ = require(&#x27;jquery&#x27;);
				$(&#x27;body&#x27;).html(&#x27;Hello Webpack!&#x27;);


				可以看到，这种以CommonJS的同步形式去引入其它模块的方式代码更加简洁。浏览器并不会实际的去同步加载这个模块，require的处理是由Webpack进行解析和打包的，浏览器只需要执行打包后的代码。Webpack自身已经可以完全处理JavaScript模块的加载，但是对于React中的JSX语法，这就需要使用Webpack的扩展加载器来处理了。







				==========================================
				函数节流：
				      var count = 0;
				function myFunc() {
				    count++;
				    console.log(count);
				}
				var func = throttle(myFunc,100);
				window.onresize = function(){
				   func();
				}       
				 
				 function throttle(fn, delay){
				     var timer = null;
				     return function(){
				         var context = this, 
				             args = arguments;
				         clearTimeout(timer);
				         timer = setTimeout(function(){
				             fn.apply(context, args);
				         }, delay);
				     };
				};



				正则：
				 匹配中文字符的正则表达式： [u4e00-u9fa5]   
				　　评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 
				　　匹配双字节字符(包括汉字在内)：[^x00-xff] 
				　　评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 
				　　匹配空白行的正则表达式：ns*r 
				　　评注：可以用来删除空白行 
				　　匹配HTML标记的正则表达式：&lt;(S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; 
				　　评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 
				　　匹配首尾空白字符的正则表达式：^s*|s*$ 
				　　评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 
				　　匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 
				　　评注：表单验证时很实用 
				　　匹配网址URL的正则表达式：[a-zA-z]+://[^s]* 
				　　评注：网上流传的版本功能很有限，上面这个基本可以满足需求 
				　　匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 
				　　评注：表单验证时很实用 
				　　匹配国内电话号码：d{3}-d{8}|d{4}-d{7} 
				　　评注：匹配形式如 0511-4405222 或 021-87888822 
				　　匹配腾讯QQ号：[1-9][0-9]{4,} 
				　　评注：腾讯QQ号从10000开始 
				　　匹配中国邮政编码：[1-9]d{5}(?!d) 
				　　评注：中国邮政编码为6位数字 
				　　匹配身份证：d{15}|d{18} 
				　　评注：中国的身份证为15位或18位 
				　　匹配ip地址：d+.d+.d+.d+ 
				　　评注：提取ip地址时有用 
				　　匹配特定数字： 
				　　^[1-9]d*$　 　 //匹配正整数 
				　　^-[1-9]d*$ 　 //匹配负整数 
				　　^-?[1-9]d*$　　 //匹配整数 
				　　^[1-9]d*|0$　 //匹配非负整数（正整数 + 0） 
				　　^-[1-9]d*|0$　　 //匹配非正整数（负整数 + 0） 
				　　^[1-9]d*.d*|0.d*[1-9]d*$　　 //匹配正浮点数 
				　　^-([1-9]d*.d*|0.d*[1-9]d*)$　 //匹配负浮点数 
				　　^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　 //匹配浮点数 
				　　^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0） 
				　　^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0） 
				　　评注：处理大量数据时有用，具体应用时注意修正 
				　　匹配特定字符串： 
				　　^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串 
				　　^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串 
				　　^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串 
				　　^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串 
				　　^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串 
				　　在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下: 
				　　只能输入数字：“^[0-9]*$” 
				　　只能输入n位的数字：“^d{n}$” 
				　　只能输入至少n位数字：“^d{n,}$” 
				　　只能输入m-n位的数字：“^d{m,n}$” 
				　　只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$” 
				　　只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$” 
				　　只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$” 
				　　只能输入非零的正整数：“^+?[1-9][0-9]*$” 
				　　只能输入非零的负整数：“^-[1-9][0-9]*$” 
				　　只能输入长度为3的字符：“^.{3}$” 
				　　只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$” 
				　　只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$” 
				　　只能输入由26个小写英文字母组成的字符串：“^[a-z]+$” 
				　　只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$” 
				　　只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$” 
				　　验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间， 
				　　只能包含字符、数字和下划线。 
				　　验证是否含有^%&amp;&#x27;&#x27;,;=?$&quot;等字符：“[^%&amp;&#x27;&#x27;,;=?$x22]+” 
				　　只能输入汉字：“^[u4e00-u9fa5],{0,}$” 
				　　验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$” 
				　　验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$” 
				　　验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$” 
				　　正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”， 
				　　“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。 
				　　验证身份证号（15位或18位数字）：“^d{15}|d{}18$” 
				　　验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12” 
				　　验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$” 
				　　正确格式为：“01”“09”和“1”“31”。 
				　　匹配中文字符的正则表达式： [u4e00-u9fa5] 
				　　匹配双字节字符(包括汉字在内)：[^x00-xff] 
				　　匹配空行的正则表达式：n[s| ]*r 
				　　匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*|&lt;(.*) /&gt;/ 
				　　匹配首尾空格的正则表达式：(^s*)|(s*$) 
				　　匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 
				　　匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)? 
				　　(1)应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 
				　　String.prototype.len=function(){return this.replace([^x00-xff]/g,&quot;aa&quot;).length;} 
				　　(2)应用：JavaScript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现 
				　　String.prototype.trim = function() 
				　　{ 
				　　return this.replace(/(^s*)|(s*$)/g, &quot;&quot;); 
				　　} 
				　　(3)应用：利用正则表达式分解和转换IP地址 
				　　function IP2V(ip) //IP地址转换成对应数值 
				　　{ 
				　　re=/(d+).(d+).(d+).(d+)/g //匹配IP地址的正则表达式 
				　　if(re.test(ip)) 
				　　{ 
				　　return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1 
				　　} 
				　　else 
				　　{ 
				　　throw new Error(&quot;Not a valid IP address!&quot;) 
				　　} 
				　　} 
				　　(4)应用：从URL地址中提取文件名的javascript程序 
				　　s=&quot;http://www.9499.net/page1.htm&quot;; 
				　　s=s.replace(/(.*/){0,}([^.]+).*/ig,&quot;$2&quot;) ;//Page1.htm 
				　　(5)应用：利用正则表达式限制网页表单里的文本框输入内容 
				　　用正则表达式限制只能输入中文：onkeyup=&quot;value=value.replace(/[^u4E00-u9FA5]/g,&#x27;&#x27;) &quot;onbeforepaste=&quot;clipboardData.setData(&#x27;&#x27;text&#x27;&#x27;,clipboardData.getData(&#x27;&#x27;text&#x27;&#x27;).replace(/[^u4E00-u9FA5]/g,&#x27;&#x27;))&quot; 
				　　用正则表达式限制只能输入全角字符： onkeyup=&quot;value=value.replace(/[^uFF00-uFFFF]/g,&#x27;&#x27;) &quot;onbeforepaste=&quot;clipboardData.setData(&#x27;&#x27;text&#x27;&#x27;,clipboardData.getData(&#x27;&#x27;text&#x27;&#x27;).replace(/[^uFF00-uFFFF]/g,&#x27;&#x27;))&quot; 
				　　用正则表达式限制只能输入数字：onkeyup=&quot;value=value.replace(/[^d]/g,&#x27;&#x27;) &quot;onbeforepaste= &quot;clipboardData.setData(&#x27;&#x27;text&#x27;&#x27;,clipboardData.getData(&#x27;&#x27;text&#x27;&#x27;).replace(/[^d]/g,&#x27;&#x27;))&quot; 
				　　用正则表达式限制只能输入数字和英文：onkeyup=&quot;value=value.replace(/[W]/g,&#x27;&#x27;) &quot;onbeforepaste=&quot;clipboardData.setData(&#x27;&#x27;text&#x27;&#x27;,clipboardData.getData(&#x27;&#x27;text&#x27;&#x27;).replace(/[^d]/g,&#x27;&#x27;




				正则语法：
				    1.正则表达式基本语法
				两个特殊的符号&#x27;^&#x27;和&#x27;$&#x27;。他们的作用是分别指出一个字符串的开始和结束。例子如下：
				&quot;^The&quot;：表示所有以&quot;The&quot;开始的字符串（&quot;There&quot;，&quot;The cat&quot;等）；
				&quot;of despair$&quot;：表示所以以&quot;of despair&quot;结尾的字符串；
				&quot;^abc$&quot;：表示开始和结尾都是&quot;abc&quot;的字符串——呵呵，只有&quot;abc&quot;自己了；
				&quot;notice&quot;：表示任何包含&quot;notice&quot;的字符串。
				象最后那个例子，如果你不使用两个特殊字符，你就在表示要查找的串在被查找串的任意部分——你并
				不把它定位在某一个顶端。
				其它还有&#x27;*&#x27;，&#x27;+&#x27;和&#x27;?&#x27;这三个符号，表示一个或一序列字符重复出现的次数。它们分别表示“没有或
				更多”，“一次或更多”还有“没有或一次”。下面是几个例子：
				&quot;ab*&quot;：表示一个字符串有一个a后面跟着零个或若干个b。（&quot;a&quot;, &quot;ab&quot;, &quot;abbb&quot;,……）；
				&quot;ab+&quot;：表示一个字符串有一个a后面跟着至少一个b或者更多；
				&quot;ab?&quot;：表示一个字符串有一个a后面跟着零个或者一个b；
				&quot;a?b+$&quot;：表示在字符串的末尾有零个或一个a跟着一个或几个b。
				你也可以使用范围，用大括号括起，用以表示重复次数的范围。
				&quot;ab{2}&quot;：表示一个字符串有一个a跟着2个b（&quot;abb&quot;）；
				&quot;ab{2,}&quot;：表示一个字符串有一个a跟着至少2个b；
				&quot;ab{3,5}&quot;：表示一个字符串有一个a跟着3到5个b。
				请注意，你必须指定范围的下限（如：&quot;{0,2}&quot;而不是&quot;{,2}&quot;）。还有，你可能注意到了，&#x27;*&#x27;，&#x27;+&#x27;和
				&#x27;?&#x27;相当于&quot;{0,}&quot;，&quot;{1,}&quot;和&quot;{0,1}&quot;。
				还有一个&#x27;¦&#x27;，表示“或”操作：
				&quot;hi¦hello&quot;：表示一个字符串里有&quot;hi&quot;或者&quot;hello&quot;；
				&quot;(b¦cd)ef&quot;：表示&quot;bef&quot;或&quot;cdef&quot;；
				&quot;(a¦b)*c&quot;：表示一串&quot;a&quot;&quot;b&quot;混合的字符串后面跟一个&quot;c&quot;；
				&#x27;.&#x27;可以替代任何字符：
				&quot;a.[0-9]&quot;：表示一个字符串有一个&quot;a&quot;后面跟着一个任意字符和一个数字；
				&quot;^.{3}$&quot;：表示有任意三个字符的字符串（长度为3个字符）；
				方括号表示某些字符允许在一个字符串中的某一特定位置出现：
				&quot;[ab]&quot;：表示一个字符串有一个&quot;a&quot;或&quot;b&quot;（相当于&quot;a¦b&quot;）；
				&quot;[a-d]&quot;：表示一个字符串包含小写的&#x27;a&#x27;到&#x27;d&#x27;中的一个（相当于&quot;a¦b¦c¦d&quot;或者&quot;[abcd]&quot;）；
				&quot;^[a-zA-Z]&quot;：表示一个以字母开头的字符串；
				&quot;[0-9]%&quot;：表示一个百分号前有一位的数字；
				&quot;,[a-zA-Z0-9]$&quot;：表示一个字符串以一个逗号后面跟着一个字母或数字结束。
				你也可以在方括号里用&#x27;^&#x27;表示不希望出现的字符，&#x27;^&#x27;应在方括号里的第一位。（如：&quot;%[^a-zA-Z]%&quot;表
				示两个百分号中不应该出现字母）。
				为了逐字表达，你必须在&quot;^.$()¦*+?{\&quot;这些字符前加上转移字符&#x27;\&#x27;。
				请注意在方括号中，不需要转义字符。
				2.正则表达式验证控制文本框的输入字符类型
				1.只能输入数字和英文的：
				&lt;input onkeyup=&quot;value=value.replace(/[\W]/g,&#x27;&#x27;) &quot; onbeforepaste=&quot;clipboardData.setData(&#x27;text&#x27;,clipboardData.getData(&#x27;text&#x27;).replace(/[^\d]/g,&#x27;&#x27;))&quot; ID=&quot;Text1&quot; NAME=&quot;Text1&quot;&gt;
				2.只能输入数字的：
				&lt;input onkeyup=&quot;value=value.replace(/[^\d]/g,&#x27;&#x27;) &quot; onbeforepaste=&quot;clipboardData.setData(&#x27;text&#x27;,clipboardData.getData(&#x27;text&#x27;).replace(/[^\d]/g,&#x27;&#x27;))&quot; ID=&quot;Text2&quot; NAME=&quot;Text2&quot;&gt;
				3.只能输入全角的：
				&lt;input onkeyup=&quot;value=value.replace(/[^\uFF00-\uFFFF]/g,&#x27;&#x27;)&quot; onbeforepaste=&quot;clipboardData.setData(&#x27;text&#x27;,clipboardData.getData(&#x27;text&#x27;).replace(/[^\uFF00-\uFFFF]/g,&#x27;&#x27;))&quot; ID=&quot;Text3&quot; NAME=&quot;Text3&quot;&gt;
				4.只能输入汉字的：
				&lt;input onkeyup=&quot;value=value.replace(/[^\u4E00-\u9FA5]/g,&#x27;&#x27;)&quot; onbeforepaste=&quot;clipboardData.setData(&#x27;text&#x27;,clipboardData.getData(&#x27;text&#x27;).replace(/[^\u4E00-\u9FA5]/g,&#x27;&#x27;))&quot; ID=&quot;Text4&quot; NAME=&quot;Text4&quot;&gt;
				3.正则表达式的应用实例通俗说明
				*******************************************************************************
				//校验是否全由数字组成
				/^[0-9]{1,20}$/
				^ 表示打头的字符要匹配紧跟^后面的规则
				$ 表示打头的字符要匹配紧靠$前面的规则
				[ ] 中的内容是可选字符集
				[0-9] 表示要求字符范围在0-9之间
				{1,20}表示数字字符串长度合法为1到20，即为[0-9]中的字符出现次数的范围是1到20次。
				/^ 和 $/成对使用应该是表示要求整个字符串完全匹配定义的规则，而不是只匹配字符串中的一个子串。
				*******************************************************************************
				//校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串
				/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/
				^[a-zA-Z]{1} 表示第一个字符要求是字母。
				([a-zA-Z0-9]|[._]){4,19} 表示从第二位开始（因为它紧跟在上个表达式后面）的一个长度为4到9位的字符串，它要求是由大小写字母、数字或者特殊字符集[._]组成。
				*******************************************************************************
				//校验用户姓名：只能输入1-30个以字母开头的字串
				/^[a-zA-Z]{1,30}$/
				*******************************************************************************
				//校验密码：只能输入6-20个字母、数字、下划线
				/^(\w){6,20}$/
				\w：用于匹配字母，数字或下划线字符
				*******************************************************************************
				//校验普通电话、传真号码：可以“+”或数字开头，可含有“-” 和 “ ”
				/^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/
				\d：用于匹配从0到9的数字；
				“?”元字符规定其前导对象必须在目标对象中连续出现零次或一次
				可以匹配的字符串如：+123 -999 999 ； +123-999 999 ；123 999 999 ；+123 999999等
				*******************************************************************************
				//校验URL
				/^http[s]{0,1}:\/\/.+$/ 或 /^http[s]{0,1}:\/\/.{1,n}$/ (表示url串的长度为length(“https://”) + n )
				\ / ：表示字符“/”。
				. 表示所有字符的集
				+ 等同于{1,}，就是1到正无穷吧。
				*********************************************************************
				//校验纯中文字符
				/^[\u4E00-\u9FA5]+$/
				[\u4E00-\u9FA5] ：估计是中文字符集的范围吧
				以上表达式均在下面的javascript中测试通过
				&lt;html&gt;
				&lt;script language=&quot;JavaScript&quot;&gt;
				&lt;!--
				function regx(r,s)
				{
				    if (r == null || r == &quot;&quot;){
				       return false;
				    }
				    var patrn= new RegExp(r);
				    if (patrn.exec(s))
				       return true
				    return false
				}
				--&gt;
				&lt;/script&gt;
				&lt;body&gt;
				&lt;form&gt;
				    规则表达式 ： &lt;input type=&quot;input&quot; name=&quot;regxStr&quot; value=&quot;&quot; &gt; (填写/ /之间的表达式)
				&lt;br&gt;
				    校验字符串 ： &lt;input type=&quot;input&quot; name=&quot;str&quot; value=&quot;&quot; &gt;
				    &lt;input type=&quot;button&quot; name=&quot;match&quot; value=&quot;匹配&quot; onClick=&quot;alert(regx(regxStr.value,str.value));&quot;&gt;
				&lt;/form&gt;
				&lt;/body&gt;
				&lt;/html&gt;
				4.正則表達式應用
				&quot;^\d+$&quot;　　//非负整数（正整数 + 0） 
				&quot;^[0-9]*[1-9][0-9]*$&quot;　　//正整数 
				&quot;^((-\d+)|(0+))$&quot;　　//非正整数（负整数 + 0） 
				&quot;^-[0-9]*[1-9][0-9]*$&quot;　　//负整数 
				&quot;^-?\d+$&quot;　　　　//整数 
				&quot;^\d+(\.\d+)?$&quot;　　//非负浮点数（正浮点数 + 0） 
				&quot;^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$&quot;　　//正浮点数 
				&quot;^((-\d+(\.\d+)?)|(0+(\.0+)?))$&quot;　　//非正浮点数（负浮点数 + 0） 
				&quot;^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$&quot;　　//负浮点数 
				&quot;^(-?\d+)(\.\d+)?$&quot;　　//浮点数 
				&quot;^[A-Za-z]+$&quot;　　//由26个英文字母组成的字符串 
				&quot;^[A-Z]+$&quot;　　//由26个英文字母的大写组成的字符串 
				&quot;^[a-z]+$&quot;　　//由26个英文字母的小写组成的字符串 
				&quot;^[A-Za-z0-9]+$&quot;　　//由数字和26个英文字母组成的字符串 
				&quot;^\w+$&quot;　　//由数字、26个英文字母或者下划线组成的字符串 
				&quot;^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$&quot;　　　　//email地址 
				&quot;^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$&quot;　　//url
				/^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$/   //  年-月-日
				/^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$/   // 月/日/年
				&quot;^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$&quot;   //Emil
				&quot;(d+-)?(d{4}-?d{7}|d{3}-?d{8}|^d{7,8})(-d+)?&quot;     //电话号码
				&quot;^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$&quot;   //IP地址
				^([0-9A-F]{2})(-[0-9A-F]{2}){5}$   //MAC地址的正则表达式
				^[-+]?\d+(\.\d+)?$  //值类型正则表达式
				5.javascript正则表达式检验
				//校验是否全由数字组成
				function isDigit(s)
				{
				var patrn=/^[0-9]{1,20}$/;
				if (!patrn.exec(s)) return false
				return true
				}
				//校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字串
				function isRegisterUserName(s)
				{
				var patrn=/^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/;
				if (!patrn.exec(s)) return false
				return true
				}
				//校验用户姓名：只能输入1-30个以字母开头的字串
				function isTrueName(s)
				{
				var patrn=/^[a-zA-Z]{1,30}$/;
				if (!patrn.exec(s)) return false
				return true
				}
				//校验密码：只能输入6-20个字母、数字、下划线
				function isPasswd(s)
				{
				var patrn=/^(\w){6,20}$/;
				if (!patrn.exec(s)) return false
				return true
				}
				//校验普通电话、传真号码：可以“+”开头，除数字外，可含有“-”
				function isTel(s)
				{
				//var patrn=/^[+]{0,1}(\d){1,3}[ ]?([-]?(\d){1,12})+$/;
				var patrn=/^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/;
				if (!patrn.exec(s)) return false
				return true
				}
				//校验手机号码：必须以数字开头，除数字外，可含有“-”
				function isMobil(s)
				{
				var patrn=/^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/;
				if (!patrn.exec(s)) return false
				return true
				}
				//校验邮政编码
				function isPostalCode(s)
				{
				//var patrn=/^[a-zA-Z0-9]{3,12}$/;
				var patrn=/^[a-zA-Z0-9 ]{3,12}$/;
				if (!patrn.exec(s)) return false
				return true
				}
				//校验搜索关键字
				function isSearch(s)
				{
				var patrn=/^[^&#x60;~!@#$%^&amp;*()+=|\\\][\]\{\}:;\&#x27;\,.&lt;&gt;/?]{1}[^&#x60;~!@$%^&amp;()+=|\\\][\]\{\}:;\&#x27;\,.&lt;&gt;?]{0,19}$/;
				if (!patrn.exec(s)) return false
				return true
				}
				function isIP(s) //by zergling
				{
				var patrn=/^[0-9.]{1,20}$/;
				if (!patrn.exec(s)) return false
				return true
				}
				/*********************************************************************************
				* FUNCTION: isBetween
				* PARAMETERS: val AS any value
				* lo AS Lower limit to check
				* hi AS Higher limit to check
				* CALLS: NOTHING
				* RETURNS: TRUE if val is between lo and hi both inclusive, otherwise false.
				**********************************************************************************/
				function isBetween (val, lo, hi) {
				if ((val &lt; lo) || (val &gt; hi)) { return(false); }
				else { return(true); }
				}
				/*********************************************************************************
				* FUNCTION: isDate checks a valid date
				* PARAMETERS: theStr AS String
				* CALLS: isBetween, isInt
				* RETURNS: TRUE if theStr is a valid date otherwise false.
				**********************************************************************************/
				function isDate (theStr) {
				var the1st = theStr.indexOf(&#x27;-&#x27;);
				var the2nd = theStr.lastIndexOf(&#x27;-&#x27;);
				if (the1st == the2nd) { return(false); }
				else {
				var y = theStr.substring(0,the1st);
				var m = theStr.substring(the1st+1,the2nd);
				var d = theStr.substring(the2nd+1,theStr.length);
				var maxDays = 31;
				if (isInt(m)==false || isInt(d)==false || isInt(y)==false) {
				return(false); }
				else if (y.length &lt; 4) { return(false); }
				else if (!isBetween (m, 1, 12)) { return(false); }
				else if (m==4 || m==6 || m==9 || m==11) maxDays = 30;
				else if (m==2) {
				if (y % 4 &gt; 0) maxDays = 28;
				else if (y % 100 == 0 &amp;&amp; y % 400 &gt; 0) maxDays = 28;
				else maxDays = 29;
				}
				if (isBetween(d, 1, maxDays) == false) { return(false); }
				else { return(true); }
				}
				}
				/*********************************************************************************
				* FUNCTION: isEuDate checks a valid date in British format
				* PARAMETERS: theStr AS String
				* CALLS: isBetween, isInt
				* RETURNS: TRUE if theStr is a valid date otherwise false.
				**********************************************************************************/
				function isEuDate (theStr) {
				if (isBetween(theStr.length, 8, 10) == false) { return(false); }
				else {
				var the1st = theStr.indexOf(&#x27;/&#x27;);
				var the2nd = theStr.lastIndexOf(&#x27;/&#x27;);
				if (the1st == the2nd) { return(false); }
				else {
				var m = theStr.substring(the1st+1,the2nd);
				var d = theStr.substring(0,the1st);
				var y = theStr.substring(the2nd+1,theStr.length);
				var maxDays = 31;
				if (isInt(m)==false || isInt(d)==false || isInt(y)==false) {
				return(false); }
				else if (y.length &lt; 4) { return(false); }
				else if (isBetween (m, 1, 12) == false) { return(false); }
				else if (m==4 || m==6 || m==9 || m==11) maxDays = 30;
				else if (m==2) {
				if (y % 4 &gt; 0) maxDays = 28;
				else if (y % 100 == 0 &amp;&amp; y % 400 &gt; 0) maxDays = 28;
				else maxDays = 29;
				}
				if (isBetween(d, 1, maxDays) == false) { return(false); }
				else { return(true); }
				}
				}
				}
				/********************************************************************************
				* FUNCTION: Compare Date! Which is the latest!
				* PARAMETERS: lessDate,moreDate AS String
				* CALLS: isDate,isBetween
				* RETURNS: TRUE if lessDate&lt;moreDate
				*********************************************************************************/
				function isComdate (lessDate , moreDate)
				{
				if (!isDate(lessDate)) { return(false);}
				if (!isDate(moreDate)) { return(false);}
				var less1st = lessDate.indexOf(&#x27;-&#x27;);
				var less2nd = lessDate.lastIndexOf(&#x27;-&#x27;);
				var more1st = moreDate.indexOf(&#x27;-&#x27;);
				var more2nd = moreDate.lastIndexOf(&#x27;-&#x27;);
				var lessy = lessDate.substring(0,less1st);
				var lessm = lessDate.substring(less1st+1,less2nd);
				var lessd = lessDate.substring(less2nd+1,lessDate.length);
				var morey = moreDate.substring(0,more1st);
				var morem = moreDate.substring(more1st+1,more2nd);
				var mored = moreDate.substring(more2nd+1,moreDate.length);
				var Date1 = new Date(lessy,lessm,lessd); 
				var Date2 = new Date(morey,morem,mored); 
				if (Date1&gt;Date2) { return(false);}
				return(true);
				}
				/*********************************************************************************
				* FUNCTION isEmpty checks if the parameter is empty or null
				* PARAMETER str AS String
				**********************************************************************************/
				function isEmpty (str) {
				if ((str==null)||(str.length==0)) return true;
				else return(false);
				}
				/*********************************************************************************
				* FUNCTION: isInt
				* PARAMETER: theStr AS String 
				* RETURNS: TRUE if the passed parameter is an integer, otherwise FALSE
				* CALLS: isDigit
				**********************************************************************************/
				function isInt (theStr) {
				var flag = true;
				if (isEmpty(theStr)) { flag=false; }
				else
				{ for (var i=0; i&lt;theStr.length; i++) {
				if (isDigit(theStr.substring(i,i+1)) == false) {
				flag = false; break;
				}
				}
				}
				return(flag);
				}
				/*********************************************************************************
				* FUNCTION: isReal
				* PARAMETER: heStr AS String 
				decLen AS Integer (how many digits after period)
				* RETURNS: TRUE if theStr is a float, otherwise FALSE
				* CALLS: isInt
				**********************************************************************************/
				function isReal (theStr, decLen) {
				var dot1st = theStr.indexOf(&#x27;.&#x27;);
				var dot2nd = theStr.lastIndexOf(&#x27;.&#x27;);
				var OK = true;
				if (isEmpty(theStr)) return false;
				if (dot1st == -1) {
				if (!isInt(theStr)) return(false);
				else return(true);
				}
				else if (dot1st != dot2nd) return (false);
				else if (dot1st==0) return (false);
				else {
				var intPart = theStr.substring(0, dot1st);
				var decPart = theStr.substring(dot2nd+1);
				if (decPart.length &gt; decLen) return(false);
				else if (!isInt(intPart) || !isInt(decPart)) return (false);
				else if (isEmpty(decPart)) return (false);
				else return(true);
				}
				}
				/*********************************************************************************
				* FUNCTION: isEmail
				* PARAMETER: String (Email Address)
				* RETURNS: TRUE if the String is a valid Email address
				* FALSE if the passed string is not a valid Email Address
				* EMAIL FORMAT: AnyName@EmailServer e.g; webmaster@hotmail.com
				* @ sign can appear only once in the email address.
				*********************************************************************************/
				function isEmail (theStr) {
				var atIndex = theStr.indexOf(&#x27;@&#x27;);
				var dotIndex = theStr.indexOf(&#x27;.&#x27;, atIndex);
				var flag = true;
				theSub = theStr.substring(0, dotIndex+1)
				if ((atIndex &lt; 1)||(atIndex != theStr.lastIndexOf(&#x27;@&#x27;))||(dotIndex &lt; atIndex + 2)||(theStr.length &lt;= theSub.length)) 
				{ return(false); }
				else { return(true); }
				}
				/*********************************************************************************
				* FUNCTION: newWindow
				* PARAMETERS: doc -&gt; Document to open in the new window
				hite -&gt; Height of the new window
				wide -&gt; Width of the new window
				bars -&gt; 1-Scroll bars = YES 0-Scroll Bars = NO
				resize -&gt; 1-Resizable = YES 0-Resizable = NO
				* CALLS: NONE
				* RETURNS: New window instance
				**********************************************************************************/
				function newWindow (doc, hite, wide, bars, resize) {
				var winNew=&quot;_blank&quot;;
				var opt=&quot;toolbar=0,location=0,directories=0,status=0,menubar=0,&quot;;
				opt+=(&quot;scrollbars=&quot;+bars+&quot;,&quot;);
				opt+=(&quot;resizable=&quot;+resize+&quot;,&quot;);
				opt+=(&quot;width=&quot;+wide+&quot;,&quot;);
				opt+=(&quot;height=&quot;+hite);
				winHandle=window.open(doc,winNew,opt);
				return;
				}
				/*********************************************************************************
				* FUNCTION: DecimalFormat
				* PARAMETERS: paramValue -&gt; Field value
				* CALLS: NONE
				* RETURNS: Formated string
				**********************************************************************************/
				function DecimalFormat (paramValue) {
				var intPart = parseInt(paramValue);
				var decPart =parseFloat(paramValue) - intPart;
				str = &quot;&quot;;
				if ((decPart == 0) || (decPart == null)) str += (intPart + &quot;.00&quot;);
				else str += (intPart + decPart);
				return (str);
				}
				&quot;^\\d+$&quot;　　//非负整数（正整数 + 0） 
				&quot;^[0-9]*[1-9][0-9]*$&quot;　　//正整数 
				&quot;^((-\\d+)|(0+))$&quot;　　//非正整数（负整数 + 0） 
				&quot;^-[0-9]*[1-9][0-9]*$&quot;　　//负整数 
				&quot;^-?\\d+$&quot;　　　　//整数 
				&quot;^\\d+(\\.\\d+)?$&quot;　　//非负浮点数（正浮点数 + 0） 
				&quot;^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$&quot;　　//正浮点数 
				&quot;^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$&quot;　　//非正浮点数（负浮点数 + 0） 
				&quot;^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$&quot;　　//负浮点数 
				&quot;^(-?\\d+)(\\.\\d+)?$&quot;　　//浮点数 
				&quot;^[A-Za-z]+$&quot;　　//由26个英文字母组成的字符串 
				&quot;^[A-Z]+$&quot;　　//由26个英文字母的大写组成的字符串 
				&quot;^[a-z]+$&quot;　　//由26个英文字母的小写组成的字符串 
				&quot;^[A-Za-z0-9]+$&quot;　　//由数字和26个英文字母组成的字符串 
				&quot;^\\w+$&quot;　　//由数字、26个英文字母或者下划线组成的字符串 
				&quot;^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$&quot;　　　　//email地址 
				&quot;^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$&quot;　　//url
				以上是本文的全部内容，希望大家喜欢。


				=============================
				webpack:

				webpack ./entry.js bundle.js
				生成捆绑文件
				会去检查entry.js里面的依赖模块

				处理可以处理Js依赖，还可以处理其他，比如css引用， 压缩等问题

				npm install css-loader style-loader
				!style!css!  这样的形式， 来指定loader的传输管道，经过处理后，变成js组件

				entry.js改为：
				require(&#x27;!style!css!./style.css&#x27;);

				重新编译： 
				webpack ./entry.js bundle.js


				我们把require(&#x27;!style!css!./style.css&#x27;);
				这一段代码整合到配置文件里去：

				webpack.config.js:

				module.exports = {
				  entry: &quot;./entry.js&quot;,
				  output: {
				      path: __dirname,
				      filename: &quot;bundle.js&quot;
				  },
				  module: {
				      loaders: [
				          { test: /\.css$/, loader: &quot;style!css&quot; }
				      ]
				  }
				};

				这个时候输入webpack就可以得到一样的结果
				看代码，我们发现，css会嵌套进去，而且没有只是加载了一个js文件，神器！


				1、React下的一个方法： render()

				2、输入的参数，通过render,传入组件，存储在this.props

				3、 var Hello = React.createClass({
				    render : function(){
				      return &lt;div { this.props.name }&gt;Hello&lt;/div&gt;
				    }
				  })
				  React.render(
				    &lt;Hello name=&quot;jake&quot;/&gt;,
				    document.getById(&quot;x&quot;);
				  )

				4、Emmet语法介绍
				  1)、输入：  p#fo   section.className    
				  2)、 输入   h1{Hello}    按Tab      
				  3)、 输入   a[href=#]   按Tab   img[src=.xx.js]
				  4)、 输入 ul&gt;li&gt;a&gt;h1+span+img  按Tab
				  5)、 输入  div&gt;p&gt;span^p{hello}  按Tab
				  6)、输入  (.className&gt;h1)+(.className&gt;h1)  按Tab
				  7)、输入  ul&gt;(li&gt;a)*5   Tab
				  8)、输入  ul&gt;li.className*3
				  9)、 css 里：  输入： w10 Tab   
				            h100p  Tab
				            db  Tab
				            poa Tab
				            l10
				            t.2rem
				            w10+t10  Tab
				            l10+t10  Tab
				            -wm-trf
				            lg(left, #fff 10%, #000 100%)；
				            bgc-#f60   Tab

				5)、   &lt;script src=&quot;react-0.13.0/build/react.js&quot;&gt;&lt;/script&gt;
				  &lt;script src=&quot;react-0.13.0/build/JSXTransformer.js&quot;&gt;&lt;/script&gt;
				  &lt;script type=&quot;text/jsx&quot;&gt;
				    var Hello = React.createClass({
				      render : function(){
				        return &lt;h1&gt;Hello World&lt;/h1&gt;
				      }
				    });
				    React.render(
				      &lt;Hello /&gt;,
				      document.body
				    );
				  &lt;/script&gt;


				6)、 JSX
				  1、是什么？
				    a、 javascript XML   基于新特性
				    b、树结构的语法
				    c、 不是 XML  不是 HTML
				    d、不是限制，也可以用Js来写
				    e、类xml语法更容易接受
				    f、增加语义
				    g、结构取清晰
				    h、 抽象程度高--》跨平台
				    I、代码模块化

				  2、怎么用？
				    a、直接支持html标签
				    b、 每个组建有属性 存在props
				    c、节点属性从标签里传入进去，理解为函数，穿进去的参数
				    d、首字母大写 ------&gt; 自定义的组件
				    e、 首字母小写 -----&gt;  DOM中的组件 div....
				    f、嵌套；
				    g、求值表达式； 使用if 之类的语句的时候要注意
				    h、 驼峰命名
				    I、 htmlFor  className  别名替换 html  class


				    css用法：
				      &lt;script type=&quot;text/jsx&quot;&gt;
				        var style = {
				          backgroundColor : &quot;red&quot;,
				          color: &quot;#fff&quot;,
				          textAlign : &quot;center&quot;
				        }
				        var HelloWorld = React.createClass({
				          render : function(){
				            return &lt;p&gt; Hello, World &lt;/p&gt;
				          }
				        })
				        React.render(
				          &lt;div style={style}&gt;&lt;HelloWorld /&gt;&lt;/div&gt;,
				          document.body
				        );
				      &lt;/script&gt;

				    if语句使用：
				      方法1
				        Hello {this.props.name ? this.props.name : &#x27;World&#x27;}
				        &lt;Hello name=&quot;Jacky&quot;/&gt;

				      方法2：
				        getName : function(){
				          if(this.props.name)
				          return this.props.name
				          else
				          return &quot;World&quot;
				        },
				        render : function(){
				                  var name = this.getName();
				                  return &lt;p&gt;Hello, {name}&lt;/p&gt;
				                    &lt;Hello name=&quot;Jacky&quot;/&gt;
				         }

				      方法3：
				        { this.props.name || &quot;world&quot; }

				    
				    万能函数表达式：
				      render ：function(){
				        return &lt;p&gt; Hello,  {
				            (function( obj ){
				              if(obj.props.name)
				                return obj.props.name
				              else
				                return &quot;World&quot;
				            })( this )
				          } &lt;/p&gt;  
				        }

				  3、 非DOM属性介绍
				     dangerouslySetInnerHTML :　在ＪＳＸ中直接插入html代码； 动态写入代码；
				     ref  父组件引用子组件  
				     key  提高渲染性能

				     它是通过 diff算法完成的， key的作用，方便算法里的比较。

				     使用：
				     dangerouslySetInnerHTML:

				      var rawHTML = {
				        __html : &quot;&lt;h1&gt;I am SupperMan&lt;/h1&gt;&quot;
				      }
				      React.render(
				        &lt;div style={style} dangerouslySetInnerHTML={rawHTML}&gt;&lt;/div&gt;,
				        document.body
				      );


				    ref:
				      this.refs.childp.....
				      render : function(){
				        return &lt;p ref=&quot;childp&quot;&gt;Hello world&lt;/p&gt;
				      }

				    key:


				  4、  源代码阅读：
				    a、 从执行顺序入手
				    b、适当忽略细节
				    c、重视烂笔头
				    d、反复阅读


				7)、 组件生命周期
				  1、 属性props是有父传给子的
				  2、 状态是 子组件内部维护的一些数据，状态发生变化会更新，一个state，对应一个render
				  3、组件的状态组合起来构成了生命周期
				  4、 初始化-----运行中-----销毁
				  5、  初始化： 
				      getDefaultProps   初始化属性 
				      getInitialState 初始化状态
				      componentWillMount   组件即将被渲染
				      render   虚拟节点  转化为真正的节点
				      componentDidMount  组件已经渲染到页面

				  6、 运行中：
				      componentWillReceiveProrps   可能要更新
				      shouldComponentUpdate   是否要更新
				      componentWillUpdate 将更新
				      render   
				      componentDidUpdate   渲染
				  7、 销毁： 
				      componentWillUnmount

				8)、初始化阶段函数介绍：
				  getDefaultProps : 只调用一次，实例之间共享引用
				  getInitialState ： 初始化每个实例特有的状态
				  componentWillMount ： render 之前最后一次修改状态的机会
				  render ：  只能访问this.props  this.state；  只有一个顶层组件，不允许修改状态和dom输出
				  componentDidMount  成功 render 并且渲染完成真实dom之后触发，可以修改dom

				  var Hello = React.createClass({
				      getDefaultProps : function(){
				        console.log(&#x27;default&#x27;);
				      },
				      getInitialState : function(){
				        console.log(&#x27;initialState&#x27;);
				        return null;
				      },
				      componentWillMount : function(){
				        console.log(&#x27;com_will_M&#x27;);
				      },

				      render :  function(){
				        console.log(&#x27;render&#x27;);
				        return &lt;p&gt;Hi,{
				          (function( obj ){
				            if(obj.props.name)
				              return obj.props.name
				            else
				              return &quot;GuangZhou&quot;
				          })( this )
				        }&lt;/p&gt;
				      },
				      componentDidMount : function(){
				        console.log(&#x27;Did&#x27;);
				      }
				    });



				  $(document).ready(function(){
				        var count = 0;
				        var style = {
				          backgroundColor : &quot;red&quot;,
				          color: &quot;#fff&quot;,
				          textAlign : &quot;center&quot;
				        }

				        var Hello = React.createClass({
				          getDefaultProps : function(){
				            return { name : &quot;Jack&quot; }
				          },
				          getInitialState : function(){
				            return {myCount:count++,  ready : false}
				          },
				          componentWillMount : function(){
				            this.setState( {ready : true} );    //设置
				          },

				          render :  function(){
				            return &lt;p ref=&quot;childpb&quot;&gt;Hello,{ this.props.name ? this.props.name : &quot;React&quot; }&lt;br/&gt;{this.state.ready}{this.state.myCount}&lt;/p&gt;
				          },
				          componentDidMount : function(){
				            $(React.findDOMNode(this)).append(&quot;Wellcom&quot;);
				          }
				        });
				        React.render(
				          &lt;div style={style}&gt;&lt;Hello name=&quot;React_&quot;/&gt;&lt;/div&gt;,
				          document.body
				        );
				    })



				9)、运行中阶段函数介绍：
				    componentWillReceiveProrps   父组件修改了子组件的属性， 在接收到新属性前触发，可以修改新属性，修改状态
				    shouldComponentUpdate    决定组件是否更新
				    componentWillUpdate 不能修改属性和状态
				    render    跟初始化的一样
				    componentDidUpdate  修改DOM

				    例子： 父组件改变子组件的属性

				    $(document).ready(function(){
				        var count = 0;
				        var style = {
				          backgroundColor : &quot;red&quot;,
				          color: &quot;#fff&quot;,
				          textAlign : &quot;center&quot;
				        }
				        
				        var ChildClass = React.createClass({
				          componentWillReceiveProps : function(newProps){
				            console.log(newProps);  //新的属性
				          },
				          shouldComponentUpdate : function(){return true},
				          componentWillUpdate :　function(){ },
				          render : function(){
				            return &lt;p&gt;
				              Hello, { this.props.name? this.props.name : &quot;World&quot; }
				              &lt;/p&gt;
				          },
				          componentDidUpdate : function(){}

				        });

				        var ParentClass = React.createClass({
				          getInitialState : function(){
				            return { name :  &quot;&quot; }
				          },
				          handleChange : function( event ){
				            this.setState({
				              name : event.target.value
				            });
				          },
				          render : function(){
				            return &lt;div&gt;
				              &lt;ChildClass name={ this.state.name } /&gt;
				              &lt;input type=&quot;text&quot; onChange={this.handleChange} /&gt;
				              &lt;/div&gt;
				          }
				        });

				        React.render(
				          &lt;div style={style}&gt;&lt;ParentClass /&gt;&lt;/div&gt;,
				          document.body
				        );
				    })



				10)、销毁阶段函数介绍：
				  componentWillUnmount : 删除组件之前进行清理操作，比如计时器，事件监听器


				****
				  A:   属性： props   = properties
				    &lt;Hello  name=&quot;属性&quot;/&gt;   &quot;str&quot;、 {123} 、 {[1,3,4]} 、 {变量} 
				    
				    var props = {
				      one : &quot;133&quot;,
				      two : 223
				    }
				    &lt;Hello {...props}/&gt;

				    1、  父组件： name={this.state.name}
				           子组件： this.props.name  获取属性

				    2、 
				    父组件：  
				        getInitialState : function(){
				          return{
				            name1 : &quot;ddd&quot;,
				            name2 : &quot;sdf&quot;
				          }
				        },
				        render : function(){
				          return &lt;div&gt;
				            &lt;Hello {...this.state}/&gt;
				            &lt;/div&gt;
				        }

				    子组件：&lt;p&gt;Hello, {this.props.name1 + &quot;  &quot; + this.props.name2}&lt;/p&gt; 


				  B: 状态的含义、用法
				    state : 

				    setState ----&gt; diff算法

				  例子：
				    var Content = React.createClass({
				      getInitialState : function(){
				        return {
				          inputText : &quot;&quot;
				        }
				      },
				      handleChange : function(ev){
				        this.setState({
				          inputText : ev.target.value
				        });
				      },
				      handleSubmit : function(){
				        console.log(&quot;reply To:&quot; + this.props.selectName + &#x27;\n&#x27;+ this.state.inputText);
				      },
				      render : function(){
				        return &lt;div&gt;
				            &lt;textarea onChange={this.handleChange}&gt;&lt;/textarea&gt;
				            &lt;button onClick={this.handleSubmit}&gt;提交&lt;/button&gt;
				          &lt;/div&gt;
				      }
				    });


				    var Comment = React.createClass({
				      getInitialState : function(){
				        return {
				          names : [&quot;sdfk&quot;,&quot;ddsf&quot;,&quot;sdf&quot;],
				          selectName :　&quot;&quot;
				        }
				      },
				      handleSelect : function(ev){
				        this.setState({
				          selectName : ev.target.value
				        })
				      },
				      render : function(){
				        var options = [];
				        for(var option in this.state.names){
				          options.push(
				            &lt;option value={this.state.names[option]}&gt;{this.state.names[option]}&lt;/option&gt;
				          )
				        }
				        return &lt;div&gt;
				            &lt;select onChange={this.handleSelect}&gt;
				              {options}
				            &lt;/select&gt;
				            &lt;Content selectName={this.state.selectName}&gt;&lt;/Content&gt;
				          &lt;/div&gt;
				      }
				    });

				    React.render(
				      &lt;Comment&gt;&lt;/Comment&gt;,
				      document.body 
				    );


				=========================
				  事件的处理：
				    编写事件处理函数
				      React自有方法  render ..
				      用户定义方法  handleClick...

				    绑定：
				      onClick = {this.handleClick}
				      onTouchCancel
				      onTouchEnd
				      onTouchMove
				      onTouchStart
				      onKeyDown
				      onKeyPress
				      onKeyUp
				      onCopy
				      onCut
				      onPaste
				      onChange
				      onInput
				      onSubmit
				      onFocus
				      onBlur
				      onScroll
				      onWheel
				      onClick
				      onContextMenu
				      onDoubleClick
				      onMouseDown
				      onMouseEnter
				      onMouseLeave
				      onMouseMove
				      onMouseOut
				      onMouseOver
				      onMouseUp
				      .......

				    事件对象介绍：
				      event.target
				      这个event是react已经通过封装了的


				    事件和状态关联：
				    handleChange : function(){
				      this.setState({
				          ......
				      })
				    }
				      

				组件的协同使用：
				  1、 什么是组件的协同使用：
				    就是一种组织管理的方法

				  2、为了：
				    让目的逻辑清晰
				    代码模块化
				    封装细节
				    代码复用

				  3、
				  方法1：组件嵌套
				    就是父子关系
				    父组件 -----&gt;通过属性-----&gt;可以跟子组件通信
				    子组件----&gt;通过事件处理函数-----&gt;触发父组件处理 实现通信的目的   间接的  叫做委托
				    优点： 容易理解，清晰逻辑； 模块化同步开发； 封装细节，开发者只需要关注组件的功能，不用关系组件的细节；
				    缺点： 编写难度高。


				    var Child = React.createClass({
				      render : function(){
				        return &lt;select onChange={this.props.handleSelect}&gt;  /*子组件通过事件处理函数委托给父组件  这样达到了父组件获取数据的目的*/
				            &lt;option value=&quot;0&quot;&gt;男&lt;/option&gt;
				            &lt;option value=&quot;0&quot;&gt;女&lt;/option&gt;
				          &lt;/select&gt;
				      }
				    });
				    var  Parent = React.createClass({
				      gitInitialState :　function(){
				        return {
				          name : &#x27;&#x27;,
				          password : &#x27;&#x27;,
				          gender : &#x27;&#x27;
				        }
				      },
				      handleSelect : function(ev){
				        this.setState({
				          gender : ev.target.value
				        });
				      },
				      handleChange : function(name,event){
				        var newState = {};
				        newState[name] = event.target.value;
				        this.setState( newState );
				      }
				      render : function(){
				        return &lt;form&gt;
				            &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; onChange={this.handleChange.bind(this, &#x27;name&#x27;)}/&gt;
				            &lt;input type=&quot;text&quot; placeholder=&quot;请输入密码&quot; onChange={this.handleChange.bind(this, &#x27;passsword&#x27;)}/&gt;
				            &lt;Child handleSelect={this.handleSelect}&gt;&lt;/Child&gt;    /*父组件通过属性跟子组件通信*/
				          &lt;/form&gt;
				      }
				    });


				   方法2: Mixin混入：
				    就是一组方法
				    目的是横向抽离出组件的相似代码

				    优点： 代码复用
				      即插即用
				      适应性强

				    var BindingMixin = {    //这个可以复用的， 就跟less的混入一个意思
				      handleChange : function(key){
				        var that =this;
				        return function( evevt ){
				          var newState = {};
				          newState[key] = event.target.value;
				          that.setState( newSate );
				        }
				      }
				    }

				    var Demo = React.createClass({
				      mixins : [BindingMixin],
				      getInitialState :  function(){
				        return {
				          test :　&quot;&quot;,
				          comment: &#x27;&#x27;
				        }
				      },
				      render : function(){
				        return &lt;div&gt;
				            &lt;input type=&quot;text&quot;  placeholder=&quot;请输入内容&quot;  onChange={this.handleChange(&#x27;text&#x27;)}/&gt;
				            &lt;textarea onChange={this.handleChange(&#x27;comment&#x27;)}&gt;&lt;/textarea&gt;
				          &lt;/div&gt;
				      }
				    });

				    React.render(
				      &lt;Demo /&gt;,
				      document.body
				    );



				React表单组件：
				    1、什么是不可控组件
				    &lt;input type=&quot;text&quot; defaultValue = &quot;Hello World&quot;/&gt; 写死的
				    defaultValue属性的属性值，对于react的状态而言，是不可控的，怎么获取到这个属性? 可以实现，不方便

				    2、可控组件：
				     &lt;input type=&quot;text&quot; defaultValue = {}Hello World}/&gt; 表达式

				    3、为什么组件要可控？
				        符合react的数据流， 它本身就是一个函数。
				        方便使用
				        方便进行处理



				    4、 不可控组件的例子：
				          var MyForm = React.createClass({
				            submitHandler : function(event){
				                    event.preventDefault();
				                    var helloTo = React.findDOMNode(this.ref.helloTo).value;
				                    alert(helloTo);
				            },

				              render : function(){
				                  return &lt;form onSubmit ={this.submitHandler}&gt;
				                                    &lt;input type=&quot;text&quot; ref=&quot;hellTo&quot; defaultValue=&quot;Hello World!&quot;/&gt;&lt;br/&gt;
				                                    &lt;button type=&quot;submit&quot;&gt;Speak&lt;/button&gt;
				                              &lt;/form&gt;
				              }
				          });

				          React.render(
				              &lt;MyForm&gt;&lt;/MyForm&gt;,
				              document.body
				          )


				          5、可控组件：
				              var MyForm = React.createClass({
				                    getInitialState :　function(){
				                          return {
				                                hellTo : &quot;Hello World&quot;
				                          }
				                    },
				                    handleChange : function(event){
				                            this.setState({
				                                    helloTo : event.target.value
				                            });
				                    },
				                    submitHandler : function(event){
				                          event.preventDefault();
				                          alert( this.state.helloTo );
				                    }
				                    render : function(){
				                        return &lt;form onSubmit = {this.submitHandler}&gt;
				                                      &lt;input type=&quot;text&quot; value={this.state.helloTo} onChange={this.handleChange}/&gt;
				                                      &lt;button type=&quot;submit&quot;&gt;Speak&lt;/button&gt;
				                                   &lt;/form&gt;
				                    }
				              })
				               React.render(
				                  &lt;MyForm&gt;&lt;/MyForm&gt;,
				                  document.body
				              )


				          6、如何在React中使用不同的表单元素：
				                 1)、表单元素：
				                        &lt;label htmlFor=&quot;name&quot;&gt;Name&lt;/label&gt;
				                        &lt;input type=&quot;checkbox&quot; value=&quot;A&quot; checked={this.state.checked} onChange={this.handleChange}/&gt;
				                        .....

				                        例子：
				                              var MyForm = React.createClass({
				                                      getInitialState : function(){
				                                            return :　{
				                                              username : &quot;&quot;,
				                                              getder : &quot;man&quot;,
				                                              checked : true
				                                            }
				                                      },
				                                      handleUsernameChange : function(event){
				                                          this.setState({
				                                                  username : event.target.value
				                                          })
				                                      },
				                                      handleGenderChange : function(event){
				                                          this.setState({
				                                            getder  :  event.target.value
				                                          })
				                                      },
				                                      handleCheckboxChange : function(event){
				                                          this.setState({
				                                                checked : event.target.checked
				                                          });
				                                      },
				                                      submitHandler :　function(event){
				                                              event.preventDefault();
				                                              console.log( this.state )
				                                      },
				                                      render : function(){
				                                            return    
				                                                      &lt;form onSubmit={this.submitHandler}&gt;
				                                                            &lt;label htmlFor=&quot;username&quot;&gt;请输入用户名:&lt;/label&gt;
				                                                            &lt;input id=&quot;username&quot; type=&quot;text&quot; value={this.state.username} onChange={this.handleUsernameChange}/&gt;
				                                                            &lt;br/&gt;
				                                                            &lt;select value={this.state.gender} onChange={this.handleGenderChange}&gt;
				                                                                &lt;option value=&quot;男&quot;&gt;男&lt;/option&gt;
				                                                                &lt;option value=&quot;女&quot;&gt;女&lt;/option&gt;
				                                                            &lt;/select&gt;
				                                                            &lt;br/&gt;
				                                                             &lt;label htmlFor=&quot;checkbox&quot;&gt;同意用户协议:&lt;/label&gt;
				                                                            &lt;input id=&quot;checkobx&quot; type=&quot;checkbox&quot; value=&quot;同意用户协议&quot; checked ={this.state.chacked} onChange={this.handleCheckboxChange} /&gt;
				                                                            &lt;button type=&quot;submit&quot;&gt;注册&lt;/button&gt;
				                                                      &lt;/form&gt;
				                                      }
				                              });


				          7、 复用事件处理函数
				                  1)、 为什么复用？
				                          onChange={this.handleChange1}
				                          onChange={this.handleChange2}
				                          onChange={this.handleChange3}
				                          onChange={this.handleChange4}
				                          这样写  不好

				                          只写一个！怎么做到
				                          方法1：
				                          handleChange : function(name, event){
				                              .....
				                          }
				                          this.handleChange.bind(this, &#x27;input1&#x27;);

				                          方法2：
				                          handleChange : function(event){
				                              var name = event.target.name;
				                          }
				                          this.handleChange


				                          例子：

				                                  handleChange : function(name, event){
				                                        var newState = {};
				                                        newState[name] =  name == &#x27;checkbox&#x27;? event.target.checked : event.target.value;
				                                        this.setState(newState);
				                                  },
				                                  render : function(){
				                                      return 
				                                                &lt;input id=&quot;username&quot; type=&quot;text&quot; value={this.state.username} onChange={this.handleChange.bind(this,&#x27;username&#x27;)} /&gt;
				                                  }




				            8、  自定义表单组件
				                  1)、为什么要自定义？
				                        表单本身的具备特殊性，样式统一，行为固定;
				                        本质上是组件嵌套，组织和管理组件的方式

				                  2)、




				sublime:

				破解：
				  http://9iphp.com/web/html/sublime-text-3-license-key.html


				使用方法：
				  下一行    ctrl+shift+enter
				  同时编辑  ctrl shift L
				  横向摆放   ctrl j
				  查找   选中  f3
				  多个关键字同时完成替换   选中  alt+f3
				  搜索   ctrl f
				  替换   ctrl  h
				  多文件搜索替换   ctrl shift f
				  跳转到文件  ctrl p
				    找函数   ctrl R
				    跳转到哪一行  ctrl G
				    文件夹  open-floder
				    创建新窗口 ctrl shift N
				    创建窗口  ctrl N
				    关掉窗口 ctrl w
				    左右分屏  Alt + Shift + 2
				    全屏  shift f11
				    注释  ctrl  /
				    注释 ctrl shift /
				    撤销 ctrl  z
				    恢复撤销 ctrl  Y
				    折叠代码  shift ctrl [
				    展开代码  shift ctrl ]
				    复制一行  ctrl shift D
				      
				==================================================================
				nodeJS
				什么是nodeJS
				javascript:
				三部分组成： Dom  Bom（操作浏览器的方法）  ecmascript(定义了语言的基础 一些对象)
				nodeJS 也是在ecmascript基础上 延伸出来的操作非浏览器的方法：
				底层一样的，基础是一样的
				做的事情不一样
				nodeJs是用来操作系统，网络，数据这些东西

				nodeJs  和 Javascript 的差异：
				语法 内置的对象


				1、nodeJs----webstorm
				  提高效率，调试速度
				  右键运行，
				  一开始需要配置环境
				  设置---搜  node ----node.js and NPM  设置好目录  加载核心模块  也可以线上临时下载 还要设置以下自动提示  点击ok
				  右键运行
				  会打印出运行js的结果

				2、  module的使用
				  1)、 一个文件，就是一个模块，每一个模块，都有自己的作用域
				  2)、 我们使用var申明一个变量，它并不是全局的，而是属于当前模块下的。
				  3)、 怎么定义全局的变量： glocbal.a = 200;
				  4)、 _filename 当前模块下的绝对路径 模块下的变量
				  5)、 加载一个模块： require(&quot;./2.js&quot;)       相对路径： 要带  ./   不加的话，  会去加载核心模块  
				    绝对路径：
				    文件名来查找-----&gt;加js查找------&gt;加.json查找----&gt; .node查找
				  6)、 


				3、     module  &amp;&amp;  exports
				  1)、 一个模块下var定义的变量，其他模块访问不了；如果想要访问，1：可以把变量定义为全局的属性，不推荐。 2：module对象下有一个exports对象，让它来实现，某些变量提供访问：  module.exports.a = 0; 其实 require(&quot;./b.js&quot;) 的返回值就是module.exports；  注意，还有一个内置的模块对象exports，他其实就是module.exports;    console.log( module.exports === exports )  ---&gt; true     因此module.exports.a = a;  可以写成  exports.a = a;   注意： module.exports = [1,2,3] 这样子导致，module.exports 与 exports 指向关系已经断开了   不要这样写；   exprots = [1,2,3];  也不要这样写

				4、   global对象
				  1)、 全局对象、new Date() 、  new Array(1,2,3)


				5、    process进程对象
				  1)、 全局对象、控制程序的进程
				  2)、 console.log( precess.argv );  程序信息
				  3)、 输入输出流：  process.stdout.write(&quot;hello&quot;)
				    用于监听用户输入的数据
				    exprocess.stdin.on(&quot;data&quot;,fuction(chunk){
				      console.log(&quot;用户输入了&quot;+chunk);
				    })
				    默认情况下，输入流是关闭的，要监听，首先要开启输入流：
				    process.stdin.resume();

				    ============================
				    var a, b;
				    process.stdout.write(&quot;请输入a的值&quot;)；
				    preocess.stdin.on(&quot;data&quot;,function( chunk ){
				      if( !a ){
				        a = Number( chunk );
				        proecess.stdout.write(&quot;请输入b的值&quot;);
				      }else{
				        b = Number( chunk );
				        proecess.stdout.write(&quot;结果是：&quot;+(a + b));
				      }
				    })

				6、    buffer 更好的操作二进制数据的类
				  1)、 我们在操作文件或者网络数据的时候，其实操作的就是二进制数据流，而node为我们提供了一个更加方便的操作这种数据流的全局的类 buffer;
				  2)、 创建一个buffer对象，为它分配空间大小，长度就固定了：
				    方法1)、
				    var bf = new Buffer( 5 );  // 存5组数据 16进制
				    如果这时加一个数据  bf[1] = 10;   
				    没改动效果的。

				    方法2)、
				    var bf = new Buffer([1,2,3]);
				    长度也是固定了，改不了了。

				    方法3)、
				    var bf = new Buffer(&quot;miaov&quot;,&quot;utf-8&quot;);
				    查看：
				    for(var i=0;i&lt;bf.length; i++){
				      console.log( String.formCharCode( bf[i] ) );
				    }

				  3)、 write方法  字符串写入buffer中
				    var str = &quot;miaov&quot;;
				    var bf = new Buffer(3);
				    bf.write( str );
				    ==============
				    bf.write(str,1); --------从bf第一位写入str
				    bf.write( str,1,3 );   ------写入3位

				  4) 、 toString()    bf转为str
				    var bf = new Buffer(&quot;miaov&quot;);
				    console.log( bf.toString() );
				    =========================
				    bf.toString(&quot;utf-8&quot;,1,3);

				  5)、  toJSON()  bf转为json
				    bf.toJSON();

				  6)、  slice()   截取 bf
				    var bf2 = bf.slice(2); ------从bf2的第二位开始截取
				    注意这个时候会涉及到引用的问题。

				  7)、 copy()  拷贝 bf
				     bf.copy( bf2 );
				     这个拷贝肯定是不会相互受到影响的

				  8)、 Buffer.isBuffer()  检测是不是bf
				    var arr = [1,2,3];
				    var bf = new Buffer(10);
				    console.log( Buffer.isBuffer( arr ) );  ---- false
				    console.log( Buffer.isBuffer( bf ) );  -----true

				  9)、 Buffer.byteLength();  获取字符的字节长度
				    var str1 = &#x27;速度&#x27;;
				    console.log( str1.length );  -------2
				    console.log( Buffer.byteLength(str1) );  ----- 6

				  10)、 Buffer.concat();   串起来 
				    var list = [new Buffer(“sdf”), new Buffer(&quot;的萨芬&quot;)]
				    var bf = Buffer.concat(list)

				  11)、express下的输入下的chunk， 也是buffer

				7、 FileSystem  文件方面
				  1)、 引入fs模块：   var fs = require(&quot;fs&quot;);
				  2)、 打开文件： 
				    fs.open(&quot;1.txt&quot;,r,function( err,fd ){
				      if( err ){
				        console.log(&quot;文件打开失败&quot;);
				      }else{
				        console.log(&quot;文件打开成功&quot;);
				      }
				    });
				    r : 读取的方式打开文件
				    fd ： 打开文件的标识 可以判断打开的是哪一个文件
				    异步的方式  

				    同步的方式：
				    var fd = fs.openSync(&quot;1.txt&quot;,&quot;r&quot;)
				    console.log(fd);
				    因为它的同步的，就是阻塞，因此直接下面console.log(fd)，不会报错，这样写容易看懂。如果是异步的话，是会报错的，因此通常在回调里面执行。 

				  3)、 打开文件进行读取：异步
				    var  fs = require(&quot;fs&quot;);
				    fs.open(&quot;1.txt&quot;,&quot;r&quot;,function(err,fd){
				      if( err ){
				        console.log(&quot;文件打开失败&quot;)
				      }else{
				        var bf = new Buffer(10); //等一下装进去
				        fs.read(fd,bf,0,4,null,function(err,newBf){
				          console.log(bf)----- 从fd文件里的第0位开始，读4位，添加到这个bf

				          console.log(newBf)----- 跟bf一样
				        });
				      }
				    })

				  4)、 打开之后，进行添加内容,注意要换成 r+ 写的方式
				    var fs = require(&quot;fs&quot;);
				    fs.open(&quot;1.txt&quot;,&quot;r+&quot;,function(err,fd){
				       if(err){
				        console.log(&quot;打开文件失败&quot;);
				       }else{
				        var bf = new Buffer(&quot;123&quot;);
				        fs.write(fd,bf, 0, 3, 0,function(){

				        });
				        //从bf 第0个开始读取  读取到第3个， 放到fd文件的第0个开始插入

				        =========================
				        第二种方式：
				        fs.write(fd,&quot;1234&quot;,5,&quot;utf-8&quot;);

				        fs.close(fd,function(){  //关闭文件

				        });
				       }
				    });


				  5)、更好用的写入文件内容的方法
				    向一个指定的文件，写入数据，如果文件不存在--新建；存在---覆盖
				    var fs = require(&quot;fs&quot;);
				    fs.writeFile(&quot;2.txt&quot;,&quot;hello&quot;,function(){
				      console.log( arguments );
				    });

				    //异步的把内容追加到文件的后面
				    fs.appendFile(filename,&quot;leo&quot;,function(){
				      console.log(arguments);
				    });

				    //判断文件存不存在   异步：
				    fs.exists(&quot;2.txt&quot;,function(isExists){
				      if( !isExists ){
				        fs.appendFile(&quot;2.txt&quot;,&quot;miaov&quot;,function(err){
				          if(err){
				            console.log(&quot;出错了&quot;);
				          }else{
				            console.log(&quot;创建新文件成功&quot;);
				          } 
				        });
				      }else{
				        fs.appendFile(filename,&quot;-leo&quot;,function(err){
				          if( err ){
				            console.log(&quot;新的内容追加失败&quot;);
				          }else{
				            console.log(&quot;新内容追加成功&quot;);
				          }
				        });
				      }
				    })

				    ==================================================
				    同步：
				    if( !fs.existsSync(&quot;3.txt&quot;) ){
				      fs.writeFileSync(&quot;3.txt&quot;,&quot;miaov&quot;);
				      console.log(&quot;新文件创建成功&quot;);
				    }else{
				      fs.appendFileSync(&quot;3.txt&quot;,&quot;-leo&quot;);
				      console.log(&quot;新内容追加成功&quot;);
				    }


				  6)、 更好用的文件读取方法：
				    var fs = require(&quot;fs&quot;);
				    fs.readFile(&quot;2.txt&quot;,function(err,data){
				      if(err){
				        console.log(&quot;文件读取失败&quot;);
				      }else{
				        console.log( data.toString() );
				      }
				    });

				    ======================================
				    删除文件：
				    fs.unlink(&quot;2.txt&quot;,function( err ){
				      if( err ){
				        console.log(&quot;删除失败&quot;);
				      }else{
				        console.log(&quot;删除成功&quot;);
				      }
				    });

				    =====================================
				    重命名：
				    fs.rename(&quot;2.txt&quot;,&quot;2.new.txt&quot;,function(){
				      console.log(arguments);
				    });


				    ====================================
				    状态：
				    fs.stat(&quot;2.new.txt&quot;,function(){
				      console.log(arguments);
				    })


				  7)、 操作文件夹
				    var fs = require(&quot;fs&quot;);
				    新建：
				    fs.mkdir(&quot;./1&quot;,function(){

				    });

				    删除：
				    fs.rmdir(&quot;./&quot;,function(){

				    });

				    读取：
				    fs.readdir(&quot;./&quot;,function(err,fileList){
				      console.log( fileList );
				      fileList.forEach(function( f ){
				        fs.sta(f,function(err,info){
				          switch(info.mode){
				            case 16822:
				            console.log(&quot;[文件夹]&quot;+f);
				            break; 

				            case 33206:
				            console.log(&quot;[文件]&quot;+f);
				            break;

				            default :
				            console.log(&quot;[其他类型]&quot;+f);
				            break;
				          }
				        })
				      })
				    })


				8、 自动化项目构建
				    帮我们自动创建好需要的目录
				    var projectData = {
				      &quot;name&quot; : &quot;miaov&quot;,
				      &quot;fileData&quot; : [
				        {
				          &quot;name&quot; : &quot;css&quot;,
				          &quot;type&quot; : &quot;dir&quot;
				        },
				        {
				          &quot;name&quot; : &quot;js&quot;,
				          &quot;type&quot; : &quot;dir&quot;
				        },
				        {
				          &quot;name&quot; : &quot;images&quot;,
				          &quot;type&quot; : &quot;dir&quot;
				        },
				        {
				          &quot;name&quot; : &quot;index.html&quot;,
				          &quot;type&quot; : &quot;file&quot;,
				          &quot;content&quot; : &quot;&lt;html&gt;\n\t&lt;head&gt;\n\&lt;title&gt;test&lt;/title&gt;......&quot;
				        }
				      ]
				    }

				    var fs = require(&quot;fs&quot;);
				    if( projectData.name ){
				      fs.mkdirSync(projectData.name);

				      var fileData = projectData.fileData;

				      if( fileData &amp;&amp; fileData.forEach ){
				        fileData.forEach(function( f ){
				          f.path = projectData.name + &quot;/&quot; + f.name;  
				          f.content = f.content || &quot;&quot;;
				          switch(f.type ){
				            case &quot;dir&quot; : 
				              fs.mkdirSync(f.path);
				            break;

				            case &quot;file&quot; : 
				              fs.writeFileSync(f.path, f.content);
				            break;

				            default :

				            break;
				          }
				        })
				      }
				    }


				9、自动合并
				  新建文件sorce
				  监听它：
				  var fs = require(&quot;fs&quot;);
				  var filedir = &quot;./miaov/source&quot;;
				  fs.watch(filedir,function(ev,file){
				    // console.log(ev+&quot;/&quot; +file); 不要这样写，一旦file被删掉了，那这个file没有被传进来会出错

				    只要有一个文件发生变化，我们就需要对这个文件夹下的所有文件进行读取，然后合并
				    
				    fs.readdir(filedir,function( dataList ){
				      var arr = [];
				      dataList.forEach(function(f){
				        if(f){
				          var info = f.statSync(filedir + &quot;/&quot; +f);
				          console.log(info);

				          if( info.mode === 33206 ){
				            arr.push(filedir + &quot;/&quot; + f);
				          }
				        }
				        

				        //读取数数组中的文件内容，并且合并
				        var content = &quot;&quot;;
				        arr.forEach(function(f){
				          var c = fs.readFileSync(f);
				          console.log(c);
				          content += c.toString() + &quot;\n&quot;;
				        })
				        //保存到一个地方：
				        fs.writeFile(&quot;./miaov/js/index.js&quot;,content);
				      })
				    })
				  })

				10、 进行web开发
				  1)、 用户通过浏览器发送一个http请求到指定的主机
				  2)、 服务器接受到请求，对请求进行分析和处理
				  3)、 服务器处理完成之后，返回对应的数据到用户端
				  4)、 浏览器接受服务器返回的数据，进行分析和处理

				  http模块搭建服务器，处理用户发送的http请求
				  var http = require(&quot;http&quot;);

				  http下的createServer方法
				  var server = http.createServer();

				  server.on(&quot;error&quot;,function(err){
				    console.log(err);
				  })
				  server.on(&quot;listening&quot;,function(){
				    console.log(&quot;listening...&quot;);
				  })

				  server.on(&quot;request&quot;,function(){
				    console.log(&quot;有客户端请求了&quot;);
				  })

				  //监听
				  server.listen(8080,&quot;localhost&quot;);


				  5)、  request对象
				    server.on(&quot;request&quot;,function(req,res){
				      console.log(req);
				    })

				  6)、  response对象
				    server.on(&quot;request&quot;,function(req,res){

				      res.writeHead(200,&quot;miaov&quot;,{
				        &quot;content-type&quot; : &quot;text/html;charset=utf-8&quot;
				      });
				      res.write(&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;);
				      res.end();
				    })

				  7)、 url处理
				    var http = require(&quot;http&quot;);
				    var url = require(&quot;url&quot;);
				    var server = http.createServer();
				    server.on(&quot;request&quot;,function(req,res){
				      var ulr = req.url;
				      //要截取--&gt;要用到url模块
				      var urlStr = url.prese( req.url );
				      console.log(urlStr);

				      switch( urlStr.pathname ){
				        case &quot;/&quot; : 
				        //首页
				        res.writeHead(200,{
				          &quot;content-type&quot; : &quot;text/html;charset=utf-8&quot;
				        })
				        res.end(&quot;&lt;h1&gt;这是首页&lt;/h1&gt;&quot;);
				        break;

				        case &quot;user&quot; : 
				        //用户首页
				        res.writeHead(200,{
				          &quot;content-type&quot; : &quot;text/html;charset=utf-8&quot;
				        })
				        res.end(&quot;&lt;h1&gt;这是个人中心&lt;/h1&gt;&quot;);
				        break;

				        default:
				        //处理其他情况
				        res.writeHead(404,{
				          &quot;content-type&quot; : &quot;text/html;charset=utf-8&quot;
				        })
				        res.end(&quot;&lt;h1&gt;页面不存在&lt;/h1&gt;&quot;);
				        break;
				      }
				    })
				    server.listen(8088,&quot;localhost&quot;);


				  8)、  使用fs模块实现行为表现分离
				    var http = require(&quot;http&quot;);
				    var ulr = require(&quot;url&quot;);
				    var fs = require(&quot;fs&quot;);
				    var server = http.createServer();
				    var HtmlDir = _dirname + &quot;/html/&quot;;
				    server.on(&quot;request&quot;,function(req,res){
				      var  urlStr = url.parse(req.url);
				      switcht(urlStr.pathname){
				        case &quot;/&quot; : 
				        //首页
				        sendData( HtmlDir + &quot;index.html&quot; ,req,res)
				        break;

				        case &quot;/user&quot;:
				        //用户首页
				        sendData( HtmlDir + &quot;index.html&quot;,req,res)
				        break;

				        default:
				        //其他情况  
				        sendData( HtmlDir + &quot;err.html&quot;,req,res)
				        break;
				      }
				    })
				    function sendData( file,req,res ){
				      fs.readFile( file,function(err,data){
				        if(err){
				          res.writeHead(404,{
				            &quot;content-type&quot; : &quot;text/html;charset=utf-8&quot;
				          })
				          res.end(&quot;&lt;h1&gt;页面没有&lt;/h1&gt;&quot;);
				        }else{
				          res.writeHead(200,{
				            &quot;content-type&quot; : &quot;text/html;charset=utf-8&quot;
				          })
				          res.end(data);
				        }
				      } );
				    }
				    server.listen(8088,&quot;localhost&quot;);

				  9)、使用querystring模块方法对get和post提交的数据进行处理

				    var http = require(&quot;http&quot;);
				    var ulr = require(&quot;url&quot;);
				    var fs = require(&quot;fs&quot;);
				    var querystring = require(&quot;querystring&quot;);
				    var server = http.createServer();
				    var HtmlDir = _dirname + &quot;/html/&quot;;
				    server.on(&quot;request&quot;,function(req,res){
				      var  urlStr = url.parse(req.url);
				      switcht(urlStr.pathname){
				        case &quot;/&quot; : 
				        //首页
				        sendData( HtmlDir + &quot;index.html&quot; ,req,res)
				        break;

				        case &quot;/user&quot;:
				        //用户首页
				        sendData( HtmlDir + &quot;index.html&quot;,req,res)
				        break;

				        case &quot;/user&quot;:
				        //用户登陆
				        sendData( HtmlDir + &quot;login.html&quot;,req,res)
				        break;

				        case &quot;/login/check&quot;
				          //console.log(req.method);
				          //console.log( urlStr.query ); // 拆字符串，Node有提供专门的模块
				          //querystring.parse( urlStr.query ) // 转换成对象

				          if( req.method.toUpperCase() == &quot;POST&quot; ){
				            var str = &quot;&quot;;
				            req.on(&quot;data&quot;,function(chunk){
				              str += chunk
				            })
				            req.on(&quot;end&quot;,function(){
				              console.log(str)
				              console.log( querystring.parse(str) )
				            })
				          }


				        break;

				        default:
				        //其他情况  
				        sendData( HtmlDir + &quot;err.html&quot;,req,res)
				        break;
				      }
				    })
				    function sendData( file,req,res ){
				      fs.readFile( file,function(err,data){
				        if(err){
				          res.writeHead(404,{
				            &quot;content-type&quot; : &quot;text/html;charset=utf-8&quot;
				          })
				          res.end(&quot;&lt;h1&gt;页面没有&lt;/h1&gt;&quot;);
				        }else{
				          res.writeHead(200,{
				            &quot;content-type&quot; : &quot;text/html;charset=utf-8&quot;
				          })
				          res.end(data);
				        }
				      } );
				    }
				    server.listen(8088,&quot;localhost&quot;);


				  login.html
				    &lt;form action=&quot;/login/check&quot; method=&quot;get&quot;&gt; 
				      &lt;input type=&quot;text&quot; name=&quot;usename&quot;/&gt;
				      &lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;
				      &lt;input type=&quot;button&quot; name = &quot;提交&quot;/&gt;
				    &lt;/form&gt;
					

				=========================================================================================================
				=========================================================================================================
				NodeJs &amp;&amp; Express web开发
				1、 前端工程师跃进服务器编程的领域。

				2、 Express
					很棒的Nodejs Web程序框架。

				3、	Node的开发带动了新式的数据存储方式。叫做&quot;NoSQL数据库&quot;，准确说说&quot;文档数据库&quot;----MongoDB最好。

				4、构建一个功能性网站需要用到很多技术，很多人用&quot;技术栈”,来描述。 而有一个： MEAN  指的是 Mongo、Express、Angular、Node

				5、什么叫做 &quot;JavaScript技术栈&quot;：  JavaScript把很多技术结合起来，兼容并包。这里指的是：	Node、Express、MongoDB

				6、//路由
					var http = require(&#x27;http&#x27;);
					http
					.createServer(function( req, res ){
						//规范url
						var path = req.url.replace(/\/?(?:\?.*)?$/).toLowerCase();
						switch( path ){
							case &quot;&quot;:
								res.writeHead({&quot;Content-type&quot;: &quot;text/plain&quot;});
								res.end(&quot;主页&quot;);
								break;
							case &quot;/about&quot;:
								res.writeHead({&quot;Content-type&quot;: &quot;text/plain&quot;});
								res.end(&quot;关于&quot;);
								break;
							default :
								res.writeHead(404,{&quot;Content-type&quot;: &quot;text/plain&quot;});
								res.end(&quot;找不到&quot;);
								break;
						}
					}).listen(3000);
					console.log(&#x27;server working....&#x27;);

					
				7、静态资源服务
					有了路由，我们提供一些HTML和logo图片。
					Node必须打开这些静态资源，也就是读取它，然后把数据返回给浏览器。
					我们在项目里创建一个public文件
					然后修改server.js
					var http = require(&quot;http&quot;);
					var fs = require(&quot;fs&quot;);
					
					http.createServer(function(req, res){
						var path = req.url.replace(/\/?(?:\?.*)?$/).toLowerCase();
						switch( path ){
							case &quot;&quot;:
								serverStaticFile(res, &quot;/public/home.html&quot;, &quot;text/html&quot; );
							break;
							case &quot;about&quot;:
								serverStaticFiel(res, &quot;/public/about.html&quot; , &quot;text/html&quot;);
							break;
							default:
								serverStaticFiel(res, &quot;/publick/404.html&quot;,&quot;text/html&quot;, 404);
							break;
						}
					});
					function serverStaticFile(res, path, contentType, responseCode){
						responseCode = (responseCode == false)?200:responseCode;
						fs.readFile(__dirname + path, function(err,data){
							if( err ){
								res.writeHead(500,{&quot;Content-type&quot;:&quot;text/plain&quot;});
								res.end(&quot;500没找到&quot;);	
							}else{
								res.writeHead(responseCode, {&quot;Content-type&quot;:&quot;text/plain&quot;});
								res.end(data);
							}
						});
					}		

				8、Express的脚手架
					大多数的项目，都会有&quot;套路化&quot;代码，通过创建通用的项目骨架，就是一个模版。
					http://www.bootcss.com/p/html5boilerplate/
					最流行的web开发前端模版
					
					


				=========================================================================================================
				=========================================================================================================
				配置 config.properties 
				1、文件在controller里的---Dev----config.properties
				2、修改里面的
					OPENAPIUrl = https://192.168.87.46:8383/openapi/rest
					APPID = 600930070



				1、开始时间
				结束时间
				它的处理方式是这样的：
				                                var dayTime=60*60*24*1000*30;
				                         var afterdayTime=60*60*24*1000*1;
				                         var backTime=new Date().getTime()-dayTime;
				                         var afterTime = new Date().getTime()+afterdayTime;
				                        $rootScope.formData={pagenum:1,pagesize:25,sort: null,
				                            screatedtime:new Date(backTime).format(&quot;yyyy-MM-dd&quot;),
				                            ecreatedtime:new Date(afterTime).format(&quot;yyyy-MM-dd&quot;)
				                        };

				===========================================================================================================
				===========================================================================================================


				2、当resize变化的时候，表格的高度的处理是这样的：
				                    $(window).resize(function(){
				                            $(&quot;.grid&quot;).css(&quot;height&quot;,$(document).height()-$(&quot;.grid&quot;).offset().top-30)

				                        })

				===========================================================================================================
				===========================================================================================================

				3、表格里的  按钮不能点击 他是这么处理的
				        ng-disabled=&quot;row.entity.paystate2!=4 || row.entity.paystate1!=1&quot;


				===========================================================================================================
				===========================================================================================================

				4、ng-option 他是这么处理的：
				    ng-options=&quot;station.stationid as station.stationname for station in stations.data.rows&quot;

				===========================================================================================================
				===========================================================================================================

				5、获取登录公司站点信息 他是这么处理的：
				                        $http({
				                            method : &#x27;POST&#x27;,
				                            url : $rootScope.urlname+&quot;/station/list.do&quot;
				                        }).success(function(data) {
				                            if(data.data != null){
				                                $rootScope.stations = data;
				                            }
				                        })
				   stations放在select下的option

				===========================================================================================================
				===========================================================================================================

				6、在comboxtable 下面有很多发货人的信息， 要查询发货人的信息的时候，在输入框输入然后进行查询，他是这么处理的：
				    on-change=&quot;queryEnterprise()&quot;
				        $rootScope.queryEnterprise = function(){
				                    if(angular.isUndefined($rootScope.queryFormData.enterpriseKeyword)){
				                        $rootScope.queryFormData.enterpriseKeyword = &quot;&quot;;
				                    }
				                    $rootScope.queryEnterpriseFormData.condition = $rootScope.queryFormData.enterpriseKeyword;
				                    $http({
				                        method : &#x27;POST&#x27;,
				                        url : $rootScope.urlname+&quot;/enterprise/deliverygoods/queryContractorinfo.do&quot;,
				                        data:$.param($scope.queryEnterpriseFormData),
				                        headers : {
				                            &#x27;Content-Type&#x27; : &#x27;application/x-www-form-urlencoded&#x27;
				                        }
				                    }).success(function(data) {
				                        $rootScope.enterprises = data;
				                        if($rootScope.enterprises != null&amp;&amp;$rootScope.enterprises.data != null&amp;&amp;$rootScope.enterprises.data.rows != null){
				                            angular.forEach($rootScope.enterprises.data.rows,function(enterprise){
				                                var pca = checkNull(enterprise.provincename)+checkNull(enterprise.cityname)+checkNull(enterprise.areaname);
				                                var address = checkNull(enterprise.address);
				                                enterprise.address = pca;
				                                if(pca != &#x27;&#x27;&amp;&amp;address != &#x27;&#x27;){
				                                    enterprise.address = pca+&quot;-&quot;+address;
				                                }
				                                if(pca == &#x27;&#x27;||address == &#x27;&#x27;){
				                                    enterprise.address = pca+address;
				                                }
				                            });
				                        }
				                    });
				                };
				    

				===========================================================================================================
				===========================================================================================================

				7、查询的时候，需要传递数据过去，怎么获取我这边的数据，他是这么处理的：
				    
				    $rootScope.queryEnterpriseFormData = {scenetypeid:3};
				    在comboxtable参数里：
				                pagenum=&quot;queryEnterpriseFormData.pageNum&quot; 
				                  pagesize=&quot;queryEnterpriseFormData.pageSize&quot;
				$rootScope.queryEnterpriseFormData.condition = $rootScope.queryFormData.enterpriseKeyword;
				    
				    最后在ajax里传递的是：
				            data:$.param($scope.queryEnterpriseFormData),

				===========================================================================================================
				===========================================================================================================    

				8、comboxtable里查询，获取到数据之后，他是这么赋值的：
				        $rootScope.enterprises = data;

				===========================================================================================================
				===========================================================================================================

				9、导出数据到Excel的时候，他是这么干的：
				            $rootScope.exportToExcel=function(){
				                var params=&quot;screatedtime=&quot;+checkNull($scope.formData.screatedtime)
				                    +&quot;&amp;ecreatedtime=&quot;+checkNull($scope.formData.ecreatedtime);
				                    +&quot;&amp;loadstationid=&quot;+checkNull($scope.formData.loadstationid)
				                    +&quot;&amp;unloadstationid=&quot;+checkNull($scope.formData.unloadstationid)
				                    +&quot;&amp;enterpriseid=&quot;+checkNull($scope.formData.enterpriseid)
				                    +&quot;&amp;enlinkername=&quot;+encodeURIComponent(encodeURIComponent(checkNull($scope.formData.enlinkername)))
				                    +&quot;&amp;recvcompanyid=&quot;+checkNull($scope.formData.recvcompanyid)
				                    +&quot;&amp;receiverid=&quot;+checkNull($scope.formData.receiverid)
				                    +&quot;&amp;state=&quot;+checkNull($scope.formData.state)
				                    +&quot;&amp;receiptflag=&quot;+checkNull($scope.formData.receiptflag)
				                    +&quot;&amp;consignnotenum=&quot;+checkNull($scope.formData.consignnotenum)
				                window.location.href=$rootScope.urlname+&quot;/logistic/confeedback/exportToExcel.do?&quot;+params;
				            };

				===========================================================================================================
				===========================================================================================================

				10、点击查询的时候 他是这么干的
				        $rootScope.queryForm=function(){
				                $http({
				                    method : &#x27;POST&#x27;,
				                    url :$rootScope.urlname+&quot;/logistic/moneyManangement/list.do&quot;,
				                    data : &quot;data=&quot;+JSON.stringify($scope.formData),     //formData就是最外层的数据层
				                    headers : {
				                        &#x27;Content-Type&#x27; : &#x27;application/x-www-form-urlencoded&#x27;
				                    }
				                }).success(function(data) {

				                    console.log(JSON.stringify(data))
				                    if(data.ret==0){
				                     for(var i=0;i&lt;data.data.rows.length;i++){
				                         for(var j=0;j&lt;data.data.rows[i].detail.length;j++){
				                             if(data.data.rows[i].detail[j].paystate2==4 &amp;&amp; data.data.rows[i].detail[j].paystate1==1){
				                                 //可以发放
				                                 data.data.rows[i].ff=true
				                             }
				                             if(data.data.rows[i].detail[j].paystate2==4 &amp;&amp; data.data.rows[i].detail[j].paystate1==1 &amp;&amp; data.data.rows[i].detail[j].incomepaystate==1){
				                                 //可以扣费
				                                  data.data.rows[i].kf=true;
				                                  break;
				                             }

				                         }
				                     }    
				                     formatData(data.data.rows); //又重新渲染表格数据
				                    $rootScope.consignnotes=data.data;
				                     $scope.gridOptions.totalItems=data.data.total  //这个体现在哪？
				                    }
				                });

				            };
				+

				===========================================================================================================
				===========================================================================================================

				11、 grid表格下的这三个属性的作用？？？
				        enableScrollbars:false,
				        expandableRowTemplate: &#x27;tpls/subgrid.tpl.html&#x27;,
				        expandableRowHeight: 200,

				===========================================================================================================
				===========================================================================================================

				12、| limitTo:19 是过滤什么的？
				    如果过滤的是字符串，那19意味着选取前19位
				    如果是数组对象，是前19个

				===========================================================================================================
				===========================================================================================================

				13、打印是这么处理的
				        $scope.privewToPdf=function(){
				        var params=&quot;agentflag=2&quot;
				            +&quot;&amp;membername=&quot;+encodeURIComponent(encodeURIComponent(checkNull($scope.formData.membername)))
				            +&quot;&amp;consignnotenum=&quot;+checkNull($scope.formData.consignnotenum)
				            +&quot;&amp;terminalnumber=&quot;+checkNull($scope.formData.terminalnumber)
				            +&quot;&amp;businesstimebegin=&quot;+checkNull($scope.formData.businesstimebegin)
				            +&quot;&amp;businesstimeend=&quot;+checkNull($scope.formData.businesstimeend)
				            +&quot;&amp;paymenttype=&quot;+checkNull($scope.formData.paymenttype);

				        window.open($rootScope.urlname+&quot;/logistic/paymentjournal/report.do?&quot;+params);
				    };

				    var checkNull = function(v){
				        if(angular.isUndefined(v)||v == null){
				            v = &quot;&quot;;
				        }
				        return v;
				    };
				    
				===========================================================================================================
				===========================================================================================================

				14、table里的class 都是干嘛的 
				        table table-bordered table-hover table-striped table-condensed


				===========================================================================================================
				===========================================================================================================


				15、 $http get方式
				            $http
				                .get($rootScope.urlname+&quot;/vehicleType/gettype.do?data={}&quot;)
				                .success(function (data) {
				                    $scope.vehicleTypes = data;
				                });

				            //获取角色类型
				            $http
				                .get($rootScope.urlname+&quot;/base/companystaff/getcompanyroletype.do&quot;)
				                .success(function (data) {
				                    $scope.contactsRoletype = data.data.rows;
				                });

				            //获取session
				            $http
				                .get($rootScope.urlname+&quot;/base/getSession.do&quot;)
				                .success(function (data) {
				                    $scope.session = data;
				                });

				===========================================================================================================
				===========================================================================================================

				16、重新加载 
				    $timeout(function () {
				        $window.location.reload();
				    }, 1500);



				===========================================================================================================
				===========================================================================================================
				17、 时间处理
				    var dayTime = 60 * 60 * 24 * 1000 * 7;
				        var afterdayTime = 60 * 60 * 24 * 1000 * 1;
				        var backTime = new Date().getTime() - dayTime;
				        var afterTime = new Date().getTime() + afterdayTime;
				        $scope.formData_ds = {
				            state: 1,
				            pageNum: 1,
				            pageSize: 5,
				            screatedtime: new Date(backTime).format(&quot;yyyy-MM-dd&quot;),
				            ecreatedtime: new Date(afterTime).format(&quot;yyyy-MM-dd&quot;)
				        };


				    $scope.queryDataSourse = function () {
				            $http({
				                method: &#x27;POST&#x27;,
				                url: $rootScope.urlname+&quot;/logistic/deliveryorder/queryDataSourse.do&quot;,
				                data: $.param($scope.formData_ds),
				                headers: {
				                    &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;
				                }

				            }).success(function (data) {
				                angular.forEach(data.data.rows,function(item){
				                    item.createdtime = item.createdtime.replace(&#x27;T&#x27;,&#x27; &#x27;);
				                })
				                $scope.consignnotedata = data;
				            });
				        };    


				===========================================================================================================
				===========================================================================================================
				 18、 这个？ $alert
				            $alert({
				                title: &#x27;提示：&#x27;,
				                content: &quot;送货单 &quot; + order.consignnotenum + &quot; 受理成功!&quot;,
				                placement: &#x27;masget-top&#x27;,
				                duration: 1.5,
				                type: &#x27;info&#x27;,
				                show: true
				            });

				===========================================================================================================
				===========================================================================================================
				19、 utils 服务来请求
				            var data = {};
				            data.data = JSON.stringify(obj);
				            var url = $rootScope.urlname+&quot;/logistic/PeopleController/get.do&quot;;
				            utils.query(url, {method: &#x27;POST&#x27;, data: data}).then(function (resp) {
				                if (resp.ret == 0) {
				                    $scope.drivers = resp;
				                }
				            });




				=========================================================================================================
				=========================================================================================================
				20、配置 config.properties
				    1、文件在controller里的---Dev----config.properties
				    2、修改里面的
				        OPENAPIUrl = https://192.168.87.46:8383/openapi/rest
				        APPID = 600930070


				=========================================================================================================
				=========================================================================================================
				21、 判断是不是数组/json对象
				    if(x instanceof Array){

				    }else if(x instanceof Object){

				    }


				=========================================================================================================
				=========================================================================================================
				22、点击之后更换内容
				    &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot; ng-click=&quot;hide = !hide&quot;&gt;
				        {{ hide &amp;&amp; &#x27;show&#x27; || &#x27;hide&#x27; }} box
				    &lt;/button&gt;
				    &lt;div ng-hide=&quot;hide&quot;&gt;
				    &lt;/div&gt;

				=========================================================================================================
				=========================================================================================================
				23、地址拼接起来
				    $scope.A += &quot;&quot; + $scope.B == undefined? &#x27;&#x27; : &#x27;-&#x27; + $scope.B;


				=========================================================================================================
				=========================================================================================================
				24、 删除掉数组之后 i-- 
				    for(var i=0; i&lt; $scope.orders.orderlist.length; i++){
				        if($scope.orders.orderlist[i].goodsid == undefined){
				            $scope.orders.orderlist.splice(i, 1);
				            i--;
				        }
				    }

				=========================================================================================================
				=========================================================================================================
				25、textarea文字数量限制
				    $scope.checkText = function(){
				        if( $scope.textareaModel.length != null ){
				            if( $scope.textareaModel.length &gt; 500 ){
				                $scope.textareaModel = $scope.textareaModel.substr(0,500);
				                $scope.text = 500 - $scope.textareaModel.length;
				            }else{
				                $scope.text = 500 - $scope.textareamodel.length;
				            }
				        }else{
				            $scope.text = 500;
				        }
				    }

				=========================================================================================================
				=========================================================================================================
				26、upload
				        
				    $scope.$watch(&#x27;files&#x27;, function () {
				            $scope.upload($scope.files);
				    });

				    $scope.upload = function (files) {
				        //console.log(files);
				        if (files &amp;&amp; files.length) {
				            for (var i = 0; i &lt; files.length; i++) {
				                var file = files[i];
				                Upload.upload({
				                    url :$rootScope.urlname+&#x27;/base/fileUpload.do&#x27;,
				                    fields: {&#x27;username&#x27;: $scope.username},
				                    file: file
				                }).progress(function (evt) {
				                    var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
				                    console.log(&#x27;progress: &#x27; + progressPercentage + &#x27;% &#x27; + evt.config.file.name);
				                }).success(function (data, status, headers, config) {
				                    if(data.ret == 0){
				                        console.log(data);
				                        $scope.editCompany.icon = data.data.file;
				                        console.log(&#x27;file &#x27; + config.file.name + &#x27;uploaded. Response: &#x27; + data);
				                        $scope.file = true;
				                    }
				                }).error(function(){
				                    console.log(&quot;error&quot;);
				                });
				            }
				        }
				    };


				=========================================================================================================
				=========================================================================================================
				27、监听数据：
					if( $scope.arrData ){
						angular.forEach( $scope.arrData, function(item){
							$scope.$watch(
								function(){
									return item.name;
								},function(newVal){
									var text = parseFloat( checkNull($scope.text) );
								}
							);
						} );
					}

					监听目的站点
					$scope.$watch( 
						function(){
							return $scope.station;
						},
						function(newVal){
							if( newVal ){
								$scope.form.companyid = newVal.companyid;
								$scope.form.stationid = newVal.stationid;
								$scope.form.companyname = newVal.companyname;
								$scope.form.stationname = newVal.stationname;
								$scope.targetChange( newVal.stationid );
							}
						}
					 );
					 $scope.targetChange = function( id ){
					 	if( id ){
					 		var obj = {
					 			loadstationis : $scopa.form.loadstationid,
					 			unloadstationid : id
					 		}
					 	}
					 }

				=========================================================================================================
				=========================================================================================================
				28、  //在datas中查找key为value的对象
					function findObj( datas, key, value ){
						if( datas.length ){
							for( var i=0; i&lt;datas.length; i++ ){
								if( datas[i][key] == value ){
									return datas[i];
								}
							}
						}
						return null;
					}


				=========================================================================================================
				=========================================================================================================
				29、定义一个服务来获取常用的接口查询
				angular.module(&#x27;app&#x27;,[])
					.factory(&#x27;myTool&#x27;,[&#x27;$http&#x27;,&#x27;$rootScope&#x27;,&#x27;utils&#x27;,function($http,$rootScope,utils){
							var factory = {};
							factory.getGroup = function(){
								return utils.query($roootScope.urlname+&#x27;/contacts.do?type=group.get&#x27;)
									.then(function( resp ){
										return resp.rows;
									});
							}

							factory.getAll = function(){
								return utils.query($rootScope,urlname+&quot;/contacts.do?type=getall&quot;)
									.then(function(resp){
										return resp.rows;
									})
							}

							factory.getSession = function(){
								return utils.query(rootScope.urlname+&#x27;/base/getSession.do&#x27;)
									.then(function(resp){
										return resp;
									})
							}

							factory.getPca = function(){
								return utils.query($rootScope.urlname+&#x27;/commonUtils.do?type=district_NOS&#x27;)
									.then(function(resp){
										return [{provincename : &#x27;未选择&#x27;}].concat(resp.data.rows)
									})
							}

							factory.getStationtype = function () {
					            return utils.query($rootScope.urlname+&#x27;/base/stationdatum/stationtype.do&#x27;)
						            .then(function (resp) {
						                return resp.result.rows;
						            });
				        	};
					}]);	



				=========================================================================================================
				=========================================================================================================
				30、解决ie下不支持placeholder属性插件
				(function($)){
					$.fn.placeholder = function(options){
						var opts = $.extend({}, $.fn.placeholder.defaults,options);
						var isIE = document.all ? true :false;
						return this.each(function(){
							var _This = this;
							placeholderValue = _Ths.getAttribute(&#x27;placeholder&#x27;);
							if( isIE ){
								_This.setAttribute(&quot;value&quot;,placeholderValue);
								_This.onfocus = function(){
									$.trim( _This.value ) == placeholderValue ? _This.value = &#x27;&#x27; : &#x27;&#x27;;
								}
								_This.onblur = function(){
									$.trim( _This.value ) == &#x27;&#x27;? _This.value = placeholderValue : &#x27;&#x27;;
								}
							}
						})
					}
				}(jQuery)

				//使用：
				$(&#x27;input&#x27;).placeholder();


				=========================================================================================================
				=========================================================================================================
				31、jquery-easyui
				    Combogrid 组合网格
				    1)、取得选中行数据
				        http://www.jeasyui.net/tutorial/23.html
				        console.log(&#x27;selectedData&#x27;,$(&quot;#buyerid&quot;).combogrid(&quot;grid&quot;).datagrid(&#x27;getSelected&#x27;))
				    
				    2)、获取到组合树当前选中的数据
				        $(&quot;#supplierstationid&quot;).combotree(&quot;tree&quot;).tree(&#x27;getSelected&#x27;)
				    
				    3)、使用EasyUI之前，必须声明UI控件
				        &lt;div class=&quot;easyui-dialog&quot;
				             data-options=&quot;title:&#x27;helloWorld&#x27;,collapsible:true,iconCls:&#x27;icon-ok&#x27;,onOpen:function(){}&quot;&gt;
				        &lt;/div&gt;
				    
				    4)、可以创建不需要js代码的DataGrid
				        主要是url=&quot;get_users.php&quot;

				    5)、创建可以编辑的 数据网格
				        http://www.jeasyui.net/tutorial/148.html
				        http://www.jeasyui.net/tutorial/36.html

				    6)、展开一行显示明细
				        http://www.jeasyui.net/tutorial/4.html

				    7)、复杂的表头
				        http://www.jeasyui.net/tutorial/20.html
				        http://www.jeasyui.net/tutorial/33.html

				    8)、添加分页组件
				        http://www.jeasyui.net/tutorial/21.html
				        http://www.jeasyui.net/tutorial/35.html

				    9)、添加查询功能
				        http://www.jeasyui.net/tutorial/22.html

				    10)、添加工具栏
				        http://www.jeasyui.net/tutorial/24.html
				        http://www.jeasyui.net/tutorial/25.html

				    11)、设置冻结列
				        http://www.jeasyui.net/tutorial/26.html

				    12)、动态改变列
				        http://www.jeasyui.net/tutorial/27.html

				    13)、数字小于多少时字体颜色变化
				        http://www.jeasyui.net/tutorial/28.html

				    14)、点击排序
				        http://www.jeasyui.net/tutorial/29.html
				        http://www.jeasyui.net/tutorial/32.html

				    15)、复选框
				        http://www.jeasyui.net/tutorial/34.html

				    16)、列运算
				        http://www.jeasyui.net/tutorial/38.html

				    ........
				    添加数据
				    $(&#x27;#sale-list&#x27;).datagrid(&#x27;appendRow&#x27;, this);

				    算合计
				    footerObj[0][&quot;goodsqty&quot;] = number;
				    footerObj[0][&quot;totalmoney&quot;] = total.toFixed(2);
				    $(&#x27;#sale-list&#x27;).datagrid(&quot;reloadFooter&quot;, footerObj);

				    获取到表格分页数据
				    $(&#x27;#goods-list&#x27;).datagrid(&#x27;getPager&#x27;).pagination(&quot;options&quot;);

				    删除一行
				    var index = $(&#x27;#sale-list&#x27;).datagrid(&#x27;getRowIndex&#x27;, custlocalid);
				    $(&#x27;#sale-list&#x27;).datagrid(&#x27;deleteRow&#x27;, index);
				    reloadFooter();

				    可编辑表格 输入后更新
				    $(&#x27;#sale-list&#x27;).datagrid(&quot;updateRow&quot;, {
				        index: index,
				        row: {
				            goodsalesprice: $(obj).val()
				        }
				    });
				    $(obj).focus();

				    选中当前行，更新当前行的标识状态
				    $(&#x27;#goods-list&#x27;).datagrid(&quot;updateRow&quot;, {
				        index: index,
				        row: {
				            giftflag: 1
				        }
				    });


				    选中一行
				    $(&#x27;#goods-list&#x27;).datagrid(&quot;selectRow&quot;, index);

				    表格配置属性： 
				        singleSelect ： 设置为 true，则只允许选中一行
				        fitColumns  ：  使列自动展开/折叠以适应数据网格（datagrid）的宽度
				        rownumbers  ： 设置为 true，则显示带有行号的列。


				=========================================================================================================
				=========================================================================================================
				32、打开页面：
				    document.location.href = &#x27;xxx.html&#x27;;


				=========================================================================================================
				=========================================================================================================
				33、下载模版
				    window.open(&quot;/wholesaleweb/enterprise/orders/downloadfile.do?data={}&quot;);

				=========================================================================================================
				=========================================================================================================
				34、jquery.window.js的使用
				    http://www.cnblogs.com/Philoo/archive/2011/11/09/jeasyui_api_window.html

				=========================================================================================================
				=========================================================================================================
				35、select、textarea元素
				    当输入域发生变化时触发
				    $(&quot;#select&quot;).change(function(){
				        xxxxxx
				    })


				=========================================================================================================
				=========================================================================================================
				36、获取到checkbox到选中状态
				    $(obj).prop(&quot;checked&quot;)


				=========================================================================================================
				=========================================================================================================
				37、unescape()
				    &lt;script type=&quot;text/javascript&quot;&gt;
				        var test1=&quot;Visit W3School!&quot;

				        test1=escape(test1)
				        document.write (test1 + &quot;&lt;br /&gt;&quot;)

				        test1=unescape(test1)
				        document.write(test1 + &quot;&lt;br /&gt;&quot;)
				    &lt;/script&gt;

				    输出：
				    Visit%20W3School%21
				    Visit W3School!


				=========================================================================================================
				=========================================================================================================
				38、监测出session没有的时候，2种情况
				    if(!!window.parent){
				        window.parent.location.href = rootPath.projectName+&quot;/app/login/login.html&quot;;
				    }else{
				        window.location.href = rootPath.projectName+&quot;/app/login/login.html&quot;;
				    }


				=========================================================================================================
				=========================================================================================================
				39、获取到表单数据
				    jquery-form-json.js
				    var obj = $(&quot;#myForm&quot;).serializeJson();  //要设置name
					 
					  &lt;form id=&quot;my-profile&quot;&gt;
						  &lt;!-- simple attribute --&gt;
						  &lt;input type=&quot;text&quot; name=&quot;fullName&quot;              value=&quot;Mario Izquierdo&quot; /&gt;

						  &lt;!-- nested attributes --&gt;
						  &lt;input type=&quot;text&quot; name=&quot;address[city]&quot;         value=&quot;San Francisco&quot; /&gt;
						  &lt;input type=&quot;text&quot; name=&quot;address[state][name]&quot;  value=&quot;California&quot; /&gt;
						  &lt;input type=&quot;text&quot; name=&quot;address[state][abbr]&quot;  value=&quot;CA&quot; /&gt;

						  &lt;!-- array --&gt;
						  &lt;input type=&quot;text&quot; name=&quot;jobbies[]&quot;             value=&quot;code&quot; /&gt;
						  &lt;input type=&quot;text&quot; name=&quot;jobbies[]&quot;             value=&quot;climbing&quot; /&gt;

						  &lt;!-- and more ... --&gt;
						  &lt;textarea              name=&quot;projects[0][name]&quot;&gt;serializeJSON&lt;/textarea&gt;
						  &lt;textarea              name=&quot;projects[0][language]&quot;&gt;javascript&lt;/textarea&gt;
						  &lt;input type=&quot;hidden&quot;   name=&quot;projects[0][popular]&quot; value=&quot;0&quot; /&gt;
						  &lt;input type=&quot;checkbox&quot; name=&quot;projects[0][popular]&quot; value=&quot;1&quot; checked=&quot;checked&quot;/&gt;

						  &lt;textarea              name=&quot;projects[1][name]&quot;&gt;tinytest.js&lt;/textarea&gt;
						  &lt;textarea              name=&quot;projects[1][language]&quot;&gt;javascript&lt;/textarea&gt;
						  &lt;input type=&quot;hidden&quot;   name=&quot;projects[1][popular]&quot; value=&quot;0&quot; /&gt;
						  &lt;input type=&quot;checkbox&quot; name=&quot;projects[1][popular]&quot; value=&quot;1&quot;/&gt;
						&lt;/form&gt;

						JavaScript:

						$('#my-profile').serializeJSON();
						// returns =>
						{
						  fullName: "Mario Izquierdo",

						  address: {
						    city: "San Francisco",
						    state: {
						      name: "California",
						      abbr: "CA"
						    }
						  },

						  jobbies: ["code", "climbing"],

						  projects: {
						    '0': { name: "serializeJSON", language: "javascript", popular: "1" },
						    '1': { name: "tinytest.js",   language: "javascript", popular: "0" }
						  }
						}

				=========================================================================================================
				=========================================================================================================
				40、js删除对象的属性值
				    delete queryData.warehouseoutnum;


				=========================================================================================================
				=========================================================================================================
				41、date-utils.js
				    使用：
				        console.log( new Date().format(&quot;yyyy-MM-dd hh:mm:ss&quot;) );
				       
				        获取当前月的第一天
				        getCurMonthFirstDay()

				        日期范围的工具


				=========================================================================================================
				=========================================================================================================
				42、jqalert.js

				      $.jqtimeralert(&#x27;hello&#x27;,&#x27;world&#x27;,function(){
				        alert(&#x27;关闭完成&#x27;);
				      },2)

				      $.jqconfirm(&#x27;hi&#x27;,&#x27;gril&#x27;,function(){
				        alert(&#x27;yes&#x27;)
				      },function(){
				        alert(&#x27;no&#x27;);
				      })


				=========================================================================================================
				=========================================================================================================
				43、Combo 组合
				    http://www.jeasyui.net/plugins/168.html

				    Combobox 组合框
				    http://www.jeasyui.net/plugins/169.html

				    Combogrid 组合网格
				    http://www.jeasyui.net/plugins/171.html

				    Combotree 组合树   
				    http://www.jeasyui.net/plugins/170.html

				=========================================================================================================
				=========================================================================================================
				44、Droppable 可放置
				    http://www.jeasyui.net/plugins/153.html

				    fileupload.js
				    http://www.jq22.com/jquery-info230



				=========================================================================================================
				=========================================================================================================
				45、
				    jquery.formautofill.js
				    表单自动填充，写的jquery扩展插件


				=========================================================================================================
				=========================================================================================================
				46、
				    打印
				    jquery.jqprint-0.3.js
				    http://www.jq22.com/jquery-info347


				    linkbutton.js
				    链接按钮（linkbutton）用于创建一个超链接按钮
				    http://www.runoob.com/jeasyui/plugins-mb-linkbutton.html



				=========================================================================================================
				=========================================================================================================
				47、font-awesome.css
				    完美的图标字体
				    只为Bootstrap设计
				    http://www.bootcss.com/p/font-awesome/




				=========================================================================================================
				=========================================================================================================
				48、pickadate  选择日期插件
				    http://www.manonggu.com/jq/148



				=========================================================================================================
				=========================================================================================================
				49、jquery.textbox.js
				 	HTML 的 textare 元素的增强。HTML 的 textarea 不支持通过 HTML 的 maxlength 属性，设置最大可输入字符数
					http://www.jsbug.com/lab/samples/textbox/

				=========================================================================================================
				=========================================================================================================
				50、jquery-ui部件库   实用工具
					jQuery.widget( name [, base ], prototype ) 
					http://www.runoob.com/jqueryui/api-jQuery-widget.html#method-_create


				=========================================================================================================
				=========================================================================================================
				51、省市县

					&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/wholesaleweb/framework/jqueryui/js/jquery-ui/jquery-ui.min.css&quot; /&gt;
					&lt;script type=&quot;text/javascript&quot; src=&quot;/wholesaleweb/framework/jqueryui/js/jquery/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;
					&lt;script type=&quot;text/javascript&quot; src=&quot;/wholesaleweb/framework/jqueryui/js/jquery-ui/jquery-ui.min.js&quot;&gt;&lt;/script&gt;
					&lt;script type=&quot;text/javascript&quot; src=&quot;/wholesaleweb/framework/common/js/utils/common.js&quot;&gt;&lt;/script&gt;

					通过jquery-ui小部件的方式来处理：

					$(document).ready(function(){

							//把自定义的小部件激活
							$(&#x27;#provinceid&#x27;).test();

							//发起一个请求，获取省数据
						 	CommonUtils.post(&quot;/wholesaleweb/commonUtils.do?type=district_NOS&quot;, {rt: new Date().getTime(), data: JSON.stringify({})} , function(result){
								console.log(&#x27;result&#x27;,result)
								if(result.ret == 0) {
									$(&quot;#provinceid&quot;).empty();
									$(&quot;#provinceid&quot;).append(&quot;&lt;option value=&#x27;&#x27;&gt;--请选择--&lt;/option&gt;&quot;);
									$.each(result.data.rows, function(index, item) {
										$(&quot;#provinceid&quot;).append(&quot;&lt;option value=&#x27;&quot; + item.provinceid + &quot;&#x27;&gt;&quot; + item.provincename + &quot;&lt;/option&gt;&quot;);
									});
									$(&quot;#provinceid&quot;).trigger(&quot;change&quot;);
								}
							});
					 })

					 省市区小部件实现写法：
					 	(function($) {
								var version = &quot;0.1&quot;;
								$.widget(&quot;ui.test&quot;, {
									version: version,
									_create : function() {
										var self = this, opt = self.options, $el = self.element;
										if(opt.province) {
											$(&quot;#&quot; + opt.provinceElId).val(opt.province);
										}
										if(opt.city) {
											$(&quot;#&quot; + opt.cityElId).val(opt.city);
										}
										if(opt.area) {
											$(&quot;#&quot; + opt.areaElId).val(opt.area);
										}
										if(opt.address) {
											$(&quot;#&quot; + opt.addressElId).val(opt.address);
										}
										$(&quot;#&quot; + opt.provinceElId).change(function (){
											alert(&quot;执行change事件&quot;);
											self._changeProvince();
										});
										$(&quot;#&quot; + opt.cityElId).change(function() {
											self._changeCity();
										});
									}, 
									destroy : function() {
									}, 
									options : {
										provinceElId: &quot;provinceid&quot;,
										cityElId: &quot;cityid&quot;,
										areaElId: &quot;areaid&quot;,
										addressElId: &quot;address&quot;,
										province: null,
										city: null,
										area: null,
										address: null
									},
									_changeProvince: function() {
										var self = this, opt = self.options, $el = self.element;
										if($(&quot;#&quot; + opt.provinceElId).val() == &quot;&quot;) {
											return;
										}
										var data = {provinceid: $(&quot;#&quot; + opt.provinceElId).val()};
										$(&quot;#&quot; + opt.cityElId).empty();
										CommonUtils.post(&quot;/wholesaleweb/commonUtils.do?type=district_NOS&quot;, {rt: new Date().getTime(), data: JSON.stringify(data)} , function(result){
											if(result.ret == 0) {
												$(&quot;#&quot; + opt.cityElId).append(&quot;&lt;option value=&#x27;&#x27;&gt;--请选择--&lt;/option&gt;&quot;);
												$.each(result.data.rows, function(index, item) {
													$(&quot;#&quot; + opt.cityElId).append(&quot;&lt;option value=&#x27;&quot; + item.cityid + &quot;&#x27;&gt;&quot; + item.cityname + &quot;&lt;/option&gt;&quot;);
												});
												if(opt.city != null) {
													$(&quot;#&quot; + opt.cityElId).val(opt.city);
												}
												$(&quot;#&quot; + opt.cityElId).trigger(&quot;change&quot;);
											}
										});
									},
									_changeCity: function() {
										var self = this, opt = self.options, $el = self.element;
										if($(&quot;#&quot; + opt.cityElId).val() == &quot;&quot;) {
											return;
										}
										var data = {cityid: $(&quot;#&quot; + opt.cityElId).val()};
										$(&quot;#&quot; + opt.areaElId).empty();
										CommonUtils.post(&quot;/wholesaleweb/commonUtils.do?type=district_NOS&quot;, {rt: new Date().getTime(), data: JSON.stringify(data)} , function(result){
											if(result.ret == 0) {
												$(&quot;#&quot; + opt.areaElId).append(&quot;&lt;option value=&#x27;&#x27;&gt;--请选择--&lt;/option&gt;&quot;);
												$.each(result.data.rows, function(index, item) {
													$(&quot;#&quot; + opt.areaElId).append(&quot;&lt;option value=&#x27;&quot; + item.areaid + &quot;&#x27;&gt;&quot; + item.areaname + &quot;&lt;/option&gt;&quot;);
												});
												if(opt.area) {
													$(&quot;#&quot; + opt.areaElId).val(opt.area);
												}
											}
										});
									},
									province: function(provinceid) {
										var self = this, opt = self.options, $el = self.element;
										$(&quot;#&quot; + opt.provinceElId).val(provinceid);
										$(&quot;#&quot; + opt.provinceElId).trigger(&quot;change&quot;);
										return this._setOptions({ province: provinceid });
									},
									city: function(cityid) {
										var self = this, opt = self.options, $el = self.element;
										$(&quot;#&quot; + opt.cityElId).val(cityid);
										$(&quot;#&quot; + opt.cityElId).trigger(&quot;change&quot;);
										return this._setOptions({ city: cityid });
									},
									area: function(areaid) {
										var self = this, opt = self.options, $el = self.element;
										$(&quot;#&quot; + opt.areaElId).val(areaid);
										return this._setOptions({ area: areaid });
									},
									address: function(_address) {
										var self = this, opt = self.options, $el = self.element;
										$(&quot;#&quot; + opt.addressElId).val(_address);
										return this._setOptions({ address: _address });
									}
								});
							})(jQuery);


				=========================================================================================================
				=========================================================================================================
				52、validatebox.js验证
						依赖：
							&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/wholesaleweb/framework/jqueryui/js/jquery-ui/jquery-ui.min.css&quot; /&gt;
							&lt;script type=&quot;text/javascript&quot; src=&quot;/wholesaleweb/framework/jqueryui/js/jquery/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;
							&lt;script type=&quot;text/javascript&quot; src=&quot;/wholesaleweb/framework/jqueryui/js/jquery-ui/jquery-ui.min.js&quot;&gt;&lt;/script&gt;
							&lt;script type=&quot;text/javascript&quot; src=&quot;/wholesaleweb/static/js/jquery.validatebox.js&quot; &gt;&lt;/script&gt;
							&lt;script type=&quot;text/javascript&quot; src=&quot;/wholesaleweb/static/js/jquery.parser.js&quot; &gt;&lt;/script&gt;
							&lt;script type=&quot;text/javascript&quot; src=&quot;/wholesaleweb/static/js/jquery.tooltip.js&quot; &gt;&lt;/script&gt;

						使用：
							 邮箱验证：&lt;input type=&quot;text&quot; validtype=&quot;email&quot; required=&quot;true&quot; missingMessage=&quot;不能为空&quot; invalidMessage=&quot;请输入正确格式的电子邮件&quot; /&gt;&lt;br /&gt;
						    网址验证：&lt;input type=&quot;text&quot; validtype=&quot;url&quot; invalidMessage=&quot;url格式不正确[http://www.example.com]&quot; /&gt;&lt;br /&gt;
						    长度验证：&lt;input type=&quot;text&quot; validtype=&quot;length[8,20]&quot; invalidMessage=&quot;有效长度8-20&quot; /&gt;&lt;br /&gt;
						    手机验证：&lt;input type=&quot;text&quot; validtype=&quot;mobile&quot;  /&gt;&lt;br /&gt;
						    邮编验证：&lt;input type=&quot;text&quot; validtype=&quot;zipcode&quot; /&gt;&lt;br /&gt;
						    账号验证：&lt;input type=&quot;text&quot; validtype=&quot;account[8,20]&quot; /&gt;&lt;br /&gt;
						    汉子验证：&lt;input type=&quot;text&quot; validtype=&quot;CHS&quot; /&gt;&lt;br /&gt;
						    远程验证：&lt;input type=&quot;text&quot; validtype=&quot;remote[&#x27;checkname.aspx&#x27;,&#x27;name&#x27;]&quot; invalidMessage=&quot;用户名已存在&quot;/&gt;&lt;br /&gt;
							 身份证验证：&lt;input type=&quot;text&quot; validtype=&quot;idcard&quot; /&gt;&lt;br/&gt;
							 最小长度验证：&lt;input type=&quot;text&quot; validtype=&quot;minLength[2]&quot;/&gt;&lt;br/&gt;
							验证电话：&lt;input type=&quot;text&quot; validtype=&quot;phone&quot;/&gt;&lt;br/&gt;


							$(function () {
				            	//设置text需要验证
				           		 $(&#x27;input[type=text]&#x27;).validatebox();  //别忘了这一步
				       		 })
				        
				        
				        
				            $.extend($.fn.validatebox.defaults.rules, {  
				               idcard: {// 验证身份证  
				                   validator: function (value) {  
				                       return /^\d{15}(\d{2}[A-Za-z0-9])?$/i.test(value);  
				                   },  
				                   message: &#x27;身份证号码格式不正确&#x27;  
				               },  
				               minLength: {  
				                   validator: function (value, param) {  
				                       return value.length &gt;= param[0];  
				                   },  
				                   message: &#x27;请输入至少（2）个字符.&#x27;  
				               },  
				               length: { validator: function (value, param) {  
				                   var len = $.trim(value).length;  
				                   return len &gt;= param[0] &amp;&amp; len &lt;= param[1];  
				               },  
				                   message: &quot;输入内容长度必须介于{0}和{1}之间.&quot;  
				               },  
				               phone: {// 验证电话号码  
				                   validator: function (value) {  
				                       return /^((\d2,3)|(\d{3}\-))?(0\d2,3|0\d{2,3}-)?[1-9]\d{6,7}(\-\d{1,4})?$/i.test(value);  
				                   },  
				                   message: &#x27;格式不正确,请使用下面格式:020-88888888&#x27;  
				               },  
				               mobile: {// 验证手机号码  
				                   validator: function (value) {  
				                       return /^(13|15|18)\d{9}$/i.test(value);  
				                   },  
				                   message: &#x27;手机号码格式不正确&#x27;  
				               },  
				               intOrFloat: {// 验证整数或小数  
				                   validator: function (value) {  
				                       return /^\d+(\.\d+)?$/i.test(value);  
				                   },  
				                   message: &#x27;请输入数字，并确保格式正确&#x27;  
				               },  
				               currency: {// 验证货币  
				                   validator: function (value) {  
				                       return /^\d+(\.\d+)?$/i.test(value);  
				                   },  
				                   message: &#x27;货币格式不正确&#x27;  
				               },  
				               qq: {// 验证QQ,从10000开始  
				                   validator: function (value) {  
				                       return /^[1-9]\d{4,9}$/i.test(value);  
				                   },  
				                   message: &#x27;QQ号码格式不正确&#x27;  
				               },  
				               integer: {// 验证整数 可正负数  
				                   validator: function (value) {  
				                       //return /^[+]?[1-9]+\d*$/i.test(value);  
				      
				                       return /^([+]?[0-9])|([-]?[0-9])+\d*$/i.test(value);  
				                   },  
				                   message: &#x27;请输入整数&#x27;  
				               },  
				               age: {// 验证年龄  
				                   validator: function (value) {  
				                       return /^(?:[1-9][0-9]?|1[01][0-9]|120)$/i.test(value);  
				                   },  
				                   message: &#x27;年龄必须是0到120之间的整数&#x27;  
				               },  
				      
				               chinese: {// 验证中文  
				                   validator: function (value) {  
				                       return /^[\Α-\￥]+$/i.test(value);  
				                   },  
				                   message: &#x27;请输入中文&#x27;  
				               },  
				               english: {// 验证英语  
				                   validator: function (value) {  
				                       return /^[A-Za-z]+$/i.test(value);  
				                   },  
				                   message: &#x27;请输入英文&#x27;  
				               },  
				               unnormal: {// 验证是否包含空格和非法字符  
				                   validator: function (value) {  
				                       return /.+/i.test(value);  
				                   },  
				                   message: &#x27;输入值不能为空和包含其他非法字符&#x27;  
				               },  
				               username: {// 验证用户名  
				                   validator: function (value) {  
				                       return /^[a-zA-Z][a-zA-Z0-9_]{5,15}$/i.test(value);  
				                   },  
				                   message: &#x27;用户名不合法（字母开头，允许6-16字节，允许字母数字下划线）&#x27;  
				               },  
				               faxno: {// 验证传真  
				                   validator: function (value) {  
				                       //            return /^[+]{0,1}(\d){1,3}[ ]?([-]?((\d)|[ ]){1,12})+$/i.test(value);  
				                       return /^((\d2,3)|(\d{3}\-))?(0\d2,3|0\d{2,3}-)?[1-9]\d{6,7}(\-\d{1,4})?$/i.test(value);  
				                   },  
				                   message: &#x27;传真号码不正确&#x27;  
				               },  
				               zip: {// 验证邮政编码  
				                   validator: function (value) {  
				                       return /^[1-9]\d{5}$/i.test(value);  
				                   },  
				                   message: &#x27;邮政编码格式不正确&#x27;  
				               },  
				               ip: {// 验证IP地址  
				                   validator: function (value) {  
				                       return /d+.d+.d+.d+/i.test(value);  
				                   },  
				                   message: &#x27;IP地址格式不正确&#x27;  
				               },  
				               name: {// 验证姓名，可以是中文或英文  
				                   validator: function (value) {  
				                       return /^[\Α-\￥]+$/i.test(value) | /^\w+[\w\s]+\w+$/i.test(value);  
				                   },  
				                   message: &#x27;请输入姓名&#x27;  
				               },  
				               date: {// 验证姓名，可以是中文或英文  
				                   validator: function (value) {  
				                       //格式yyyy-MM-dd或yyyy-M-d  
				                       return /^(?:(?!0000)[0-9]{4}([-]?)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-]?)0?2\2(?:29))$/i.test(value);  
				                   },  
				                   message: &#x27;清输入合适的日期格式&#x27;  
				               },  
				               msn: {  
				                   validator: function (value) {  
				                       return /^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/.test(value);  
				                   },  
				                   message: &#x27;请输入有效的msn账号(例：abc@hotnail(msn/live).com)&#x27;  
				               },  
				               same: {  
				                   validator: function (value, param) {  
				                       if ($(&quot;#&quot; + param[0]).val() != &quot;&quot; &amp;&amp; value != &quot;&quot;) {  
				                           return $(&quot;#&quot; + param[0]).val() == value;  
				                       } else {  
				                           return true;  
				                       }  
				                   },  
				                   message: &#x27;两次输入的密码不一致！&#x27;  
				               }  
				           }); 


				=========================================================================================================
				=========================================================================================================
				52、
					pagination分页：
					设置属性：
					$(&#x27;#list&#x27;).datagrid({
						pagination: true
					})

					//监听事件
					$(&#x27;#list&#x27;).datagrid(&#x27;getPager&#x27;).pagination({
						onSelectPage: function(pageNumber, pageSize){
							$(&#x27;#searchBtn&#x27;).trigger(&#x27;click&#x27;);//主动触发
						}
					})


				=========================================================================================================
				=========================================================================================================
				53、下拉树
					$(&#x27;#companygoodsclassifyid&#x27;).combotree({
					    url: classifyQueryUrl,
					    method: &#x27;post&#x27;,
					    idField: &quot;companygoodsclassifyid&quot;,
						valueField: &quot;companygoodsclassifyid&quot;,
						textField: &quot;companygoodsclassifyname&quot;,
						panelWidth: 200,
						height: 30,
						editable: false,
						onBeforeLoad:function(node,param){
							param.data= JSON.stringify(data);
						},
						onSelect: function(node){
							$(&#x27;#companygoodsclassifyid&#x27;).val(node.id);
						},
						loadFilter: function(data){
							if (data.data){
								return data.data.rows;
							} else {
								return data.rows;
							}
						}
					});


				=========================================================================================================
				=========================================================================================================
				54、
					window.location.search方法是截取当前url中“?”后面的字符串， 
					例如：index.php?act=doctor,截取后的字符串就是act=doctor


				=========================================================================================================
				=========================================================================================================
				下拉搜索 打开对应
				55、
						$(&#x27;#search&#x27;).combobox({
						buttonAlign: &#x27;left&#x27;,
						buttonIcon: &#x27;icon-search&#x27;,
						prompt: &#x27;姓名/手机号&#x27;,
					    required: false,
					    multiple: false,
					    url: contractsQueryUrl,
					    valueField: &#x27;contractorinfoid&#x27;,
					    textField: &#x27;contactname&#x27;,
						loadFilter: function(data){
							if (data.data){
								return data.data.rows;
							} else {
								return data;
							}
						},
						onBeforeLoad: function(param){
							param.data = JSON.stringify({contactname: $(&#x27;#search&#x27;).combobox(&quot;getValue&quot;)});
						},
						onSelect : function(row){
							console.log(row);
							switch( row.scenetypeid ){
								case 3:
									$(&quot;#mytreemenu&quot;).find(&quot;.menu-item&quot;).eq(1).trigger(&quot;click&quot;);
									triggerTarget(row);
									break;
								case 2:
									$(&quot;#mytreemenu&quot;).find(&quot;.menu-item&quot;).eq(0).trigger(&quot;click&quot;);
									triggerTarget(row);
									break;
								case 4:
									$(&quot;#mytreemenu&quot;).find(&quot;.menu-item&quot;).eq(2).trigger(&quot;click&quot;);
									triggerTarget(row);
									break;
							}
						}
						});
						function triggerTarget(row){
							var timer = null;
							clearTimeout(timer);
							timer = setTimeout(function(){
								for( var i=0; i&lt;$(&quot;#mytreemenu&quot;).find(&quot;.menu-item-sub&quot;).length; i++ ){
									var id  = $(&quot;#mytreemenu&quot;).find(&quot;.menu-item-sub&quot;).eq(i).attr(&#x27;id&#x27;);
									var addressgroupid = id.split(&#x27;-&#x27;)[1];
									console.log(&#x27;addressgroupid&#x27;,addressgroupid)
									if( addressgroupid == row.addressgroupid ){
										$(&quot;#mytreemenu&quot;).find(&quot;.menu-item-sub&quot;).eq(i).trigger(&quot;click&quot;);
									}
								}
							},500)
						}

				=========================================================================================================
				=========================================================================================================
				56、prop获取属性
					http://www.jb51.net/article/59440.htm
					
					

				=========================================================================================================
				=========================================================================================================
				57、日期设置picker  api
						http://amsul.ca/pickadate.js/api/#method-set	
						function initDateRange(fromElId, toElId) {
							var picker_from = $(&#x27;#&#x27; + fromElId).pickadate({
								selectYears: true,
								selectMonths: true,
								onClose: function () {
									var fromDate = createDateArray(this.get(&#x27;select&#x27;, &#x27;yyyy-mm-dd&#x27;));
									fromDate[1] = fromDate[1] - 1;
									picker_to.data(&#x27;pickadate&#x27;).set(&#x27;min&#x27;, fromDate);
								},
								onStart : function(){
									 var calendar = this;
								}
							});
							var picker_to = $(&#x27;#&#x27; + toElId).pickadate({
								selectYears: true,
								selectMonths: true,
								onClose: function () {
									var toDate = createDateArray(this.get(&#x27;select&#x27;, &#x27;yyyy-mm-dd&#x27;));
									toDate[1] = toDate[1] - 1;
									picker_from.data(&#x27;pickadate&#x27;).set(&#x27;max&#x27;, toDate);
								}
							})
							
							return {
								calendar_from : picker_from.pickadate(&#x27;picker&#x27;),
								calendar_to : picker_to.data(&quot;pickadate&quot;)
							}
						}
						
						//todo 初始化日期、设置默认值
						function initDefaultDate(){
							var dateObj = initDateRange(&quot;createTimeStartInput&quot;,&quot;createTimeEndInput&quot;),
								arrDateForm = [],
								arrDateTo = [];
							$.extend(arrDateForm,createDateArray(new Date().format(&quot;yyyy-MM-dd&quot;)));
							$.extend(arrDateTo,createDateArray(new Date().format(&quot;yyyy-MM-dd&quot;)));
							arrDateForm[1] = arrDateForm[1] - 2;
							arrDateTo[1] = arrDateTo[1] - 1;
							dateObj.calendar_from.set(&#x27;select&#x27;,arrDateForm);
							dateObj.calendar_to.set(&#x27;select&#x27;,arrDateTo);
						}	
					

				=========================================================================================================
				=========================================================================================================
				58、标准时间转换
					new Date().toISOString().slice(0,10)

				=========================================================================================================
				=========================================================================================================
				59、
				//本月日期限制
				function limitDate_curMonth(){
					var arrForm = DateRangeUtil.getCurrentMonth()[0].format(&quot;yyyy-MM-dd&quot;).split(&#x27;-&#x27;);
					var arrTo = new Date().format(&quot;yyyy-MM-dd&quot;).split(&#x27;-&#x27;);
					arrForm[1] = arrForm[1] -1;
					arrTo[1] = arrTo[1] -1;
					dateObj = initDefaultDate(&quot;begincreatedtime&quot;,&quot;endcreatedtime&quot;);
					
					dateObj.calendar_to.set(&quot;max&quot;,new Date());
					dateObj.calendar_from.set(&quot;max&quot;,new Date());
					dateObj.calendar_from.set(&quot;min&quot;,arrForm);
					dateObj.calendar_to.set(&quot;min&quot;,arrForm);
					
					dateObj.calendar_from.set(&quot;select&quot;,arrForm);
					dateObj.calendar_to.set(&quot;select&quot;,new Date());
					
				}
				//上一月日期限制
				function limitDate_lastMonth(){
					var arrForm_lastMonth = DateRangeUtil.getPreviousMonth()[0].format(&quot;yyyy-MM-dd&quot;).split(&#x27;-&#x27;);
					var arrTo_lastMonth = DateRangeUtil.getPreviousMonth()[1].format(&quot;yyyy-MM-dd&quot;).split(&#x27;-&#x27;);
					arrForm_lastMonth[1] = arrForm_lastMonth[1] - 1;
					arrTo_lastMonth[1] =  arrTo_lastMonth[1] - 1;
					dateObj = initDefaultDate(&quot;begincreatedtime&quot;,&quot;endcreatedtime&quot;);
					
					dateObj.calendar_to.set(&quot;max&quot;,arrTo_lastMonth);
					dateObj.calendar_from.set(&quot;max&quot;,arrTo_lastMonth);
					dateObj.calendar_from.set(&quot;min&quot;,arrForm_lastMonth);
					dateObj.calendar_to.set(&quot;min&quot;,arrForm_lastMonth);
					
					dateObj.calendar_from.set(&quot;select&quot;,arrForm_lastMonth);
					dateObj.calendar_to.set(&quot;select&quot;,arrTo_lastMonth);
				}
				//本周日期限制
				function limitDate_curWeek(){
					var arrForm_curWeek = DateRangeUtil.getCurrentWeek()[0].format(&quot;yyyy-MM-dd&quot;).split(&#x27;-&#x27;);
					var arrTo_curWeek = new Date().format(&quot;yyyy-MM-dd&quot;).split(&#x27;-&#x27;);
					arrForm_curWeek[1] = arrForm_curWeek[1] -1;
					arrTo_curWeek[1] = arrTo_curWeek[1] -1;
					dateObj = initDefaultDate(&quot;begincreatedtime&quot;,&quot;endcreatedtime&quot;);
					
					dateObj.calendar_to.set(&quot;max&quot;,arrTo_curWeek);
					dateObj.calendar_from.set(&quot;max&quot;,arrTo_curWeek);
					dateObj.calendar_from.set(&quot;min&quot;,arrForm_curWeek);
					dateObj.calendar_to.set(&quot;min&quot;,arrForm_curWeek);
					
					dateObj.calendar_from.set(&quot;select&quot;,arrForm_curWeek);
					dateObj.calendar_to.set(&quot;select&quot;,arrTo_curWeek);
				}
				//上周日期限制
				function limitDate_lastWeek(){
					var arrForm_lastWeek = DateRangeUtil.getPreviousWeek()[0].format(&quot;yyyy-MM-dd&quot;).split(&#x27;-&#x27;);
					var arrTo_lastWeek = DateRangeUtil.getPreviousWeek()[1].format(&quot;yyyy-MM-dd&quot;).split(&#x27;-&#x27;);
					arrForm_lastWeek[1] = arrForm_lastWeek[1] -1;
					arrTo_lastWeek[1] = arrTo_lastWeek[1] -1;
					dateObj = initDefaultDate(&quot;begincreatedtime&quot;,&quot;endcreatedtime&quot;);
					
					dateObj.calendar_to.set(&quot;max&quot;,arrTo_lastWeek);
					dateObj.calendar_from.set(&quot;max&quot;,arrTo_lastWeek);
					dateObj.calendar_from.set(&quot;min&quot;,arrForm_lastWeek);
					dateObj.calendar_to.set(&quot;min&quot;,arrForm_lastWeek);
					
					dateObj.calendar_from.set(&quot;select&quot;,arrForm_lastWeek);
					dateObj.calendar_to.set(&quot;select&quot;,arrTo_lastWeek);
				}

				=========================================================================================================
				=========================================================================================================
				60、
				  标签内处理js:
				    &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;javascript:$(&quot;P&quot;).panel(&quot;open&quot;)&quot;&gt;Open&lt;/a&gt;


				=========================================================================================================
				=========================================================================================================
				61、
				  在线文档  搜索 
				  MDN，https://developer.mozilla.org/  

				  推荐： 深入HTML5  这本书



				=========================================================================================================
				=========================================================================================================
				62、Express 中间件写法
				  1. 模块直接输出中间件函数
				      如果中间件不需要配置对象，用这个方法：
				      module.exports = function(req, res, next){
				      // 中间件在这里……记得调用next() 或next(&#x27;route&#x27;)
				      // 除非这个中间件是终点
				      next();
				      }
				      使用这个中间件：
				      var stuff = require(&#x27;meadowlark-stuff&#x27;);
				      app.use(stuff);

				  2. 模块输出返回中间件的函数
				      如果中间件需要配置对象或者其他信息，用这个方法：
				      module.exports = function(config){
				      // 如果没有传入配置对象
				      // 一般会创建一个：
				      if(!config) config = {};
				        return function(req, res, next){
				        // 中间件在这里……记得调用next() 或next(&#x27;route&#x27;)
				        // 除非这个中间件是终点
				        next();
				      }
				      }
				      使用这个中间件：
				      var stuff = require(&#x27;meadowlark-stuff&#x27;)({ option: &#x27;my choice&#x27; });
				      app.use(stuff);

				  3. 模块输出包含中间件的对象
				      如果要输出多个相互关联的中间件，用这个办法：
				      module.exports = function(config){
				      // 如果没有传入配置对象
				      // 一般会创建一个：
				      if(!config) config = {};
				      return {
				      m1: function(req, res, next){
				      // 中间件在这里……记得调用next() 或next(&#x27;route&#x27;)
				      // 除非这个中间件是终点
				      next();
				      },
				      m2: function(req, res, next){
				      next();
				      }
				      }
				      }
				      使用这个中间件：
				      var stuff = require(&#x27;meadowlark-stuff&#x27;)({ option: &#x27;my choice&#x27; });
				      app.use(stuff.m1);
				      app.use(stuff.m2);

				=========================================================================================================
				=========================================================================================================
				63、https
				    互联网的本质，决定了客户端与服务端之间的传输的数据包有可能被人截取。
				    而https会对这些包进行加密，使得我们这个包很难被攻击者访问到。
				    要提供HTTPS，则需要有来自CA 的证书，那怎么才能得到这样的证书呢？大体上
				    有三种途径：你可以自己生成，也可以从免费CA 那里获取，或者从商业CA 那里买一个。

				    Express应用启用HTTPS
				    只要有了私钥和证书，在应用里使用它们很容易
				    切换到HTTPS 很简单。我建议你把私钥和SSL 证书放在ssl 子目录下（尽管放在项目
				根目录下的情况十分常见）
				    var https = require(&#x27;https&#x27;); // 一般在文件顶部
				    var options = {
				      key: fs.readFileSync(__dirname + &#x27;/ssl/meadowlark.pem&#x27;);
				      cert: fs.readFileSync(__dirname + &#x27;/ssl/meadowlark.crt&#x27;);
				    };
				    https.createServer(options, app).listen(app.get(&#x27;port&#x27;), function(){
				       console.log(&#x27;Express started in &#x27; + app.get(&#x27;env&#x27;) +
				       &#x27; mode on port &#x27; + app.get(&#x27;port&#x27;) + &#x27;.&#x27;);
				    });
				    就是这样。假如你用的还是3000 端口，现在可以连接到https://localhost:3000。如果你试
				着连接http://localhost:3000，只会访问超时

				    端口：
				        HTTPS 的标准端口是443。浏览器的处理也是一样的：如果你连接https://www.
				google.com:443，大多数浏览器都不会显示:443，但它们连的就是那个端口。
				        如果你的HTTP 用的不是端口80，HTTPS 不是443，则必须明确指定端口和协议以保证
				正确连接
				        如果你要在端口80 上运行HTTP，或者在443 上运行HTTPS，则不必明确指定端口，你
				只要考虑两点。
				            第一个是很多系统已经有运行在端口80 上的默认服务器了。
				            另一个要了解的是在大多数操作系统上，端口1~1024 需要提升权限才能打开




				=========================================================================================================
				=========================================================================================================
				64、
				  给用户创建一个模型 models/user.js
				    var mongoose = require(&quot;mongoose&quot;);
				    var userSchema = mongoose.Schema({
				        authId : String,
				        name :String,
				        email : String,
				        role : String,
				        created :　Date
				    });
				    var User = mongoose.model(&#x27;User&#x27;, userSchema);
				    module.exports = User;


				    模型绝对是最最重要的组件
				    我建议你在项目中创建一个叫models 的子目录来存放模型。只要你有要实现的逻辑，或要
				存储的数据，都应该在models 目录下的文件里完成。比如说，你可能要把客户数据和逻辑
				放在文件models/customer.js 中：
				    var mongoose = require(&#x27;mongoose&#x27;);
				    var Orders = require(&#x27;./orders.js&#x27;);
				    var customerSchema = mongoose.Schema({
				            firstName: String,
				            lastName: String,
				            email: String,
				            address1: String,
				            address2: String,
				            city: String,
				            state: String,
				            zip: String,
				            phone: String,
				            salesNotes: [{
				            date: Date,
				               salespersonId: Number,
				               notes: String,
				            }],
				        });
				        customerSchema.methods.getOrders = function(){
				           return Orders.find({ customerId: this._id });
				        };
				        var Customer = mongoose.model(&#x27;Customer&#x27;, customerSchema);
				        modules.export = Customer;



				=========================================================================================================
				=========================================================================================================
				65、
				    视图模型
				      要创建一个视图显示客户信息，还有一串订单。然而我们的Customer 模型不太好用。里面有我们不想显示的数据（销售记录），用视图模型很方便
				      创建文件夹viewModels
				      里面创建客户的视图模型文件：customer.js
				          var Customer = require(&#x27;../model/customer.js&#x27;);
				          // 联合各域的辅助函数
				          function smartJoin(arr, separator){
				            if(!separator) separator = &#x27; &#x27;;
				                return arr.filter(function(elt){
				                return elt!==undefined &amp;&amp;
				                elt!==null &amp;&amp;
				                elt.toString().trim() !== &#x27;&#x27;;
				            }).join(separator);
				          }
				          module.exports = function(customerId){
				                var customer = Customer.findById(customerId);
				                if(!customer) return { error: &#x27;Unknown customer ID: &#x27; +
				                req.params.customerId };

				                var orders = customer.getOrders().map(function(order){
				                    return {
				                      orderNumber: order.orderNumber,
				                      date: order.date,
				                      status: order.status,
				                      url: &#x27;/orders/&#x27; + order.orderNumber,
				                    }
				                });

				                return {
				                      firstName: customer.firstName,
				                      lastName: customer.lastName,
				                      name: smartJoin([customer.firstName, customer.lastName]),
				                      email: customer.email,
				                      address1: customer.address1,
				                      address2: customer.address2,
				                      city: customer.city,
				                      state: customer.state,
				                      zip: customer.zip,
				                      fullAddress: smartJoin([
				                          customer.address1,
				                          customer.address2,
				                          customer.city + &#x27;, &#x27; +
				                          customer.state + &#x27; &#x27; +
				                          customer.zip,
				                      ], &#x27;&lt;br&gt;&#x27;),
				                      phone: customer.phone,
				                      orders: customer.getOrders().map(function(order){
				                            return {
				                                orderNumber: order.orderNumber,
				                                date: order.date,
				                                status: order.status,
				                                url: &#x27;/orders/&#x27; + order.orderNumber,
				                            }
				                      }),
				                }
				          }

				          视图模型的概念对于保护模型的完整性和范围是必不可少的

				          可以借用Underscore， 做更多精心的对象组成，你可以克隆一个对象，只挑选你想要的属性，
				或者相反，克隆对象时忽略特定的属性
				          install with npm install --save underscore
				          重写上面的例子：
				                var _ = require(&#x27;underscore&#x27;);
				                // 得到一个客户视图模型
				            function getCustomerViewModel(customerId) {
				                    var customer = Customer.findById(customerId);
				                    if(!customer) return { error: &#x27;Unknown customer ID: &#x27; +
				                    req.params.customerId };
				                    var orders = customer.getOrders().map(function(order){
				                          return {
				                          orderNumber: order.orderNumber,
				                          date: order.date,
				                          status: order.status,
				                          url: &#x27;/orders/&#x27; + order.orderNumber,
				                          }
				                    });
				                    var vm = _.omit(customer, &#x27;salesNotes&#x27;);

				                return _.extend(vm, {
				                    name: smartJoin([vm.firstName, vm.lastName]),
				                    fullAddress: smartJoin([
				                    customer.address1,
				                    customer.address2,
				                    customer.city + &#x27;, &#x27; +
				                    customer.state + &#x27; &#x27; +
				                    customer.zip,
				                    ], &#x27;&lt;br&gt;&#x27;),
				                    orders: customer.getOrders().map(function(order){
				                            return {
				                            orderNumber: order.orderNumber,
				                            date: order.date,
				                            status: order.status,
				                            url: &#x27;/orders/&#x27; + order.orderNumber,
				                            }
				                    }),
				                });
				          }


				=========================================================================================================
				=========================================================================================================
				66、
				    控制器
				    控制器负责处理用户交互，并根据用户交互选择恰当的视图来显
				    需要一个“客户控制器”，它负责客户信息的显示和编辑，包括客户下的订单
				            controllers/customer.js
				      
				      var Customer = require(&#x27;../models/customer.js&#x27;);
				      var customerViewModel = require(&#x27;../viewModels/customer.js&#x27;);
				        exports = {
				            registerRoutes: function(app) {
				                  app.get(&#x27;/customer/:id&#x27;, this.home);
				                  app.get(&#x27;/customer/:id/preferences&#x27;, this.preferences);
				                  app.get(&#x27;/orders/:id&#x27;, this.orders);
				                  app.post(&#x27;/customer/:id/update&#x27;, this.ajaxUpdate);
				            }
				            home: function(req, res, next) {
				            var customer = Customer.findById(req.params.id);
				            if(!customer) return next(); // 将这个传给404 处理器
				              res.render(&#x27;customer/home&#x27;, customerViewModel(customer));
				            }
				            preferences: function(req, res, next) {
				                var customer = Customer.findById(req.params.id);
				                if(!customer) return next(); // 将这个传给404 处理器
				                res.render(&#x27;customer/preferences&#x27;, customerViewModel(customer));
				            }
				            orders: function(req, res, next) {
				                  var customer = Customer.findById(req.params.id);
				                  if(!customer) return next(); // 将这个传给404 处理器
				                  res.render(&#x27;customer/preferences&#x27;, customerViewModel(customer));
				            }
				            ajaxUpdate: function(req, res) {
				                var customer = Customer.findById(req.params.id);
				                if(!customer) return res.json({ error: &#x27;Invalid ID.&#x27;});
				                if(req.body.firstName){
				                    if(typeof req.body.firstName !== &#x27;string&#x27; ||
				                    req.body.firstName.trim() === &#x27;&#x27;)
				                    return res.json({ error: &#x27;Invalid name.&#x27;});
				                    customer.firstName = req.body.firstName;
				                }
				               // 等等……
				               customer.save();
				               return res.json({ success: true });
				            }




				=========================================================================================================
				=========================================================================================================
				67,MySql
					

					$(&#x27;#ddv-&#x27;+index).datagrid({
								fitColumns:true,
								collapsible: false,
								columns:[[
									{field:&#x27;goodsname&#x27;,title:&#x27;商品名称&#x27;, align:&#x27;center&#x27;,width:60, formatter: function(value, row, index){
										if(row[&quot;giftflag&quot;] == 1) {
											return &quot;[赠品]&quot; + value;
										} else {
											return value;
										}
									}},
									{field:&#x27;goodsspec&#x27;,title:&#x27;商品条码&#x27;,align:&#x27;center&#x27;, width:40},
									{field:&#x27;goodssn&#x27;,title:&#x27;规格&#x27;,align:&#x27;center&#x27;, width:40},
									{field:&#x27;totalvolume&#x27;,title:&#x27;体积&#x27;, align:&#x27;center&#x27;,width:40},
									{field:&#x27;totalweight&#x27;,title:&#x27;重量&#x27;,align:&#x27;center&#x27;, width:40},
									{field:&#x27;packageqty&#x27;,title:&#x27;出库数量&#x27;, align:&#x27;center&#x27;,width:40},
									{field:&#x27;goodsalesprice&#x27;,title:&#x27;售价&#x27;, align:&#x27;center&#x27;,width:40,formatter:function(value,row,index){
										if(value!=null)
											return value.toFixed(2);
									}}
								]],
								onLoadSuccess:function(){
									$(&#x27;#shippment-list&#x27;).datagrid(&#x27;fixDetailRowHeight&#x27;,index);
								}
							});
							$(&#x27;#ddv-&#x27;+index).datagrid(&#x27;loadData&#x27;, data.orderlist);
							$(&#x27;#ddv-&#x27; + index).datagrid(&#x27;appendRow&#x27;, {
								goodsalesunit: &#x27;合计&#x27;,
								goodsqty: row.totgoodsqty,
								totalmoney: row.totgoodsmoney
							});
							$(&#x27;#shippment-list&#x27;).datagrid(&#x27;fixDetailRowHeight&#x27;,index);	

					

								</code>
							</pre>
					</div>
						<div class="col-md-4">
							<!-- <pre style="margin-bottom: 10px; background: hsl(30, 20%, 25%); ">
								<code class="language-css" style="color:#fff; font-size:15px; text-shadow: none;">
							
								
								</code>
							</pre> -->
						</div>
					</div>
				</div>
					

